function x1(e, r) { for (var i = 0; i < r.length; i++) { const s = r[i]; if (typeof s != "string" && !Array.isArray(s)) { for (const a in s) if (a !== "default" && !(a in e)) { const c = Object.getOwnPropertyDescriptor(s, a); c && Object.defineProperty(e, a, c.get ? c : { enumerable: !0, get: () => s[a] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const a of document.querySelectorAll('link[rel="modulepreload"]')) s(a); new MutationObserver(a => { for (const c of a) if (c.type === "childList") for (const u of c.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && s(u) }).observe(document, { childList: !0, subtree: !0 }); function i(a) { const c = {}; return a.integrity && (c.integrity = a.integrity), a.referrerPolicy && (c.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? c.credentials = "include" : a.crossOrigin === "anonymous" ? c.credentials = "omit" : c.credentials = "same-origin", c } function s(a) { if (a.ep) return; a.ep = !0; const c = i(a); fetch(a.href, c) } })(); function Hg(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Dc = { exports: {} }, co = {}, _c = { exports: {} }, be = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wh; function w1() { if (Wh) return be; Wh = 1; var e = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), u = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), v = Symbol.iterator; function S(M) { return M === null || typeof M != "object" ? null : (M = v && M[v] || M["@@iterator"], typeof M == "function" ? M : null) } var k = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, P = Object.assign, C = {}; function N(M, W, oe) { this.props = M, this.context = W, this.refs = C, this.updater = oe || k } N.prototype.isReactComponent = {}, N.prototype.setState = function (M, W) { if (typeof M != "object" && typeof M != "function" && M != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, M, W, "setState") }, N.prototype.forceUpdate = function (M) { this.updater.enqueueForceUpdate(this, M, "forceUpdate") }; function j() { } j.prototype = N.prototype; function E(M, W, oe) { this.props = M, this.context = W, this.refs = C, this.updater = oe || k } var R = E.prototype = new j; R.constructor = E, P(R, N.prototype), R.isPureReactComponent = !0; var O = Array.isArray, V = Object.prototype.hasOwnProperty, B = { current: null }, z = { key: !0, ref: !0, __self: !0, __source: !0 }; function F(M, W, oe) { var ae, we = {}, Ce = null, K = null; if (W != null) for (ae in W.ref !== void 0 && (K = W.ref), W.key !== void 0 && (Ce = "" + W.key), W) V.call(W, ae) && !z.hasOwnProperty(ae) && (we[ae] = W[ae]); var ce = arguments.length - 2; if (ce === 1) we.children = oe; else if (1 < ce) { for (var ve = Array(ce), Se = 0; Se < ce; Se++)ve[Se] = arguments[Se + 2]; we.children = ve } if (M && M.defaultProps) for (ae in ce = M.defaultProps, ce) we[ae] === void 0 && (we[ae] = ce[ae]); return { $$typeof: e, type: M, key: Ce, ref: K, props: we, _owner: B.current } } function Z(M, W) { return { $$typeof: e, type: M.type, key: W, ref: M.ref, props: M.props, _owner: M._owner } } function ie(M) { return typeof M == "object" && M !== null && M.$$typeof === e } function fe(M) { var W = { "=": "=0", ":": "=2" }; return "$" + M.replace(/[=:]/g, function (oe) { return W[oe] }) } var me = /\/+/g; function ge(M, W) { return typeof M == "object" && M !== null && M.key != null ? fe("" + M.key) : W.toString(36) } function pe(M, W, oe, ae, we) { var Ce = typeof M; (Ce === "undefined" || Ce === "boolean") && (M = null); var K = !1; if (M === null) K = !0; else switch (Ce) { case "string": case "number": K = !0; break; case "object": switch (M.$$typeof) { case e: case r: K = !0 } }if (K) return K = M, we = we(K), M = ae === "" ? "." + ge(K, 0) : ae, O(we) ? (oe = "", M != null && (oe = M.replace(me, "$&/") + "/"), pe(we, W, oe, "", function (Se) { return Se })) : we != null && (ie(we) && (we = Z(we, oe + (!we.key || K && K.key === we.key ? "" : ("" + we.key).replace(me, "$&/") + "/") + M)), W.push(we)), 1; if (K = 0, ae = ae === "" ? "." : ae + ":", O(M)) for (var ce = 0; ce < M.length; ce++) { Ce = M[ce]; var ve = ae + ge(Ce, ce); K += pe(Ce, W, oe, ve, we) } else if (ve = S(M), typeof ve == "function") for (M = ve.call(M), ce = 0; !(Ce = M.next()).done;)Ce = Ce.value, ve = ae + ge(Ce, ce++), K += pe(Ce, W, oe, ve, we); else if (Ce === "object") throw W = String(M), Error("Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(M).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead."); return K } function xe(M, W, oe) { if (M == null) return M; var ae = [], we = 0; return pe(M, ae, "", "", function (Ce) { return W.call(oe, Ce, we++) }), ae } function se(M) { if (M._status === -1) { var W = M._result; W = W(), W.then(function (oe) { (M._status === 0 || M._status === -1) && (M._status = 1, M._result = oe) }, function (oe) { (M._status === 0 || M._status === -1) && (M._status = 2, M._result = oe) }), M._status === -1 && (M._status = 0, M._result = W) } if (M._status === 1) return M._result.default; throw M._result } var q = { current: null }, I = { transition: null }, X = { ReactCurrentDispatcher: q, ReactCurrentBatchConfig: I, ReactCurrentOwner: B }; function G() { throw Error("act(...) is not supported in production builds of React.") } return be.Children = { map: xe, forEach: function (M, W, oe) { xe(M, function () { W.apply(this, arguments) }, oe) }, count: function (M) { var W = 0; return xe(M, function () { W++ }), W }, toArray: function (M) { return xe(M, function (W) { return W }) || [] }, only: function (M) { if (!ie(M)) throw Error("React.Children.only expected to receive a single React element child."); return M } }, be.Component = N, be.Fragment = i, be.Profiler = a, be.PureComponent = E, be.StrictMode = s, be.Suspense = h, be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = X, be.act = G, be.cloneElement = function (M, W, oe) { if (M == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + M + "."); var ae = P({}, M.props), we = M.key, Ce = M.ref, K = M._owner; if (W != null) { if (W.ref !== void 0 && (Ce = W.ref, K = B.current), W.key !== void 0 && (we = "" + W.key), M.type && M.type.defaultProps) var ce = M.type.defaultProps; for (ve in W) V.call(W, ve) && !z.hasOwnProperty(ve) && (ae[ve] = W[ve] === void 0 && ce !== void 0 ? ce[ve] : W[ve]) } var ve = arguments.length - 2; if (ve === 1) ae.children = oe; else if (1 < ve) { ce = Array(ve); for (var Se = 0; Se < ve; Se++)ce[Se] = arguments[Se + 2]; ae.children = ce } return { $$typeof: e, type: M.type, key: we, ref: Ce, props: ae, _owner: K } }, be.createContext = function (M) { return M = { $$typeof: u, _currentValue: M, _currentValue2: M, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, M.Provider = { $$typeof: c, _context: M }, M.Consumer = M }, be.createElement = F, be.createFactory = function (M) { var W = F.bind(null, M); return W.type = M, W }, be.createRef = function () { return { current: null } }, be.forwardRef = function (M) { return { $$typeof: f, render: M } }, be.isValidElement = ie, be.lazy = function (M) { return { $$typeof: y, _payload: { _status: -1, _result: M }, _init: se } }, be.memo = function (M, W) { return { $$typeof: g, type: M, compare: W === void 0 ? null : W } }, be.startTransition = function (M) { var W = I.transition; I.transition = {}; try { M() } finally { I.transition = W } }, be.unstable_act = G, be.useCallback = function (M, W) { return q.current.useCallback(M, W) }, be.useContext = function (M) { return q.current.useContext(M) }, be.useDebugValue = function () { }, be.useDeferredValue = function (M) { return q.current.useDeferredValue(M) }, be.useEffect = function (M, W) { return q.current.useEffect(M, W) }, be.useId = function () { return q.current.useId() }, be.useImperativeHandle = function (M, W, oe) { return q.current.useImperativeHandle(M, W, oe) }, be.useInsertionEffect = function (M, W) { return q.current.useInsertionEffect(M, W) }, be.useLayoutEffect = function (M, W) { return q.current.useLayoutEffect(M, W) }, be.useMemo = function (M, W) { return q.current.useMemo(M, W) }, be.useReducer = function (M, W, oe) { return q.current.useReducer(M, W, oe) }, be.useRef = function (M) { return q.current.useRef(M) }, be.useState = function (M) { return q.current.useState(M) }, be.useSyncExternalStore = function (M, W, oe) { return q.current.useSyncExternalStore(M, W, oe) }, be.useTransition = function () { return q.current.useTransition() }, be.version = "18.3.1", be } var $h; function Zu() { return $h || ($h = 1, _c.exports = w1()), _c.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Uh; function S1() { if (Uh) return co; Uh = 1; var e = Zu(), r = Symbol.for("react.element"), i = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, a = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, c = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(f, h, g) { var y, v = {}, S = null, k = null; g !== void 0 && (S = "" + g), h.key !== void 0 && (S = "" + h.key), h.ref !== void 0 && (k = h.ref); for (y in h) s.call(h, y) && !c.hasOwnProperty(y) && (v[y] = h[y]); if (f && f.defaultProps) for (y in h = f.defaultProps, h) v[y] === void 0 && (v[y] = h[y]); return { $$typeof: r, type: f, key: S, ref: k, props: v, _owner: a.current } } return co.Fragment = i, co.jsx = u, co.jsxs = u, co } var Hh; function C1() { return Hh || (Hh = 1, Dc.exports = S1()), Dc.exports } var p = C1(), Ys = {}, Lc = { exports: {} }, St = {}, Oc = { exports: {} }, Vc = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Kh; function k1() { return Kh || (Kh = 1, (function (e) { function r(I, X) { var G = I.length; I.push(X); e: for (; 0 < G;) { var M = G - 1 >>> 1, W = I[M]; if (0 < a(W, X)) I[M] = X, I[G] = W, G = M; else break e } } function i(I) { return I.length === 0 ? null : I[0] } function s(I) { if (I.length === 0) return null; var X = I[0], G = I.pop(); if (G !== X) { I[0] = G; e: for (var M = 0, W = I.length, oe = W >>> 1; M < oe;) { var ae = 2 * (M + 1) - 1, we = I[ae], Ce = ae + 1, K = I[Ce]; if (0 > a(we, G)) Ce < W && 0 > a(K, we) ? (I[M] = K, I[Ce] = G, M = Ce) : (I[M] = we, I[ae] = G, M = ae); else if (Ce < W && 0 > a(K, G)) I[M] = K, I[Ce] = G, M = Ce; else break e } } return X } function a(I, X) { var G = I.sortIndex - X.sortIndex; return G !== 0 ? G : I.id - X.id } if (typeof performance == "object" && typeof performance.now == "function") { var c = performance; e.unstable_now = function () { return c.now() } } else { var u = Date, f = u.now(); e.unstable_now = function () { return u.now() - f } } var h = [], g = [], y = 1, v = null, S = 3, k = !1, P = !1, C = !1, N = typeof setTimeout == "function" ? setTimeout : null, j = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function R(I) { for (var X = i(g); X !== null;) { if (X.callback === null) s(g); else if (X.startTime <= I) s(g), X.sortIndex = X.expirationTime, r(h, X); else break; X = i(g) } } function O(I) { if (C = !1, R(I), !P) if (i(h) !== null) P = !0, se(V); else { var X = i(g); X !== null && q(O, X.startTime - I) } } function V(I, X) { P = !1, C && (C = !1, j(F), F = -1), k = !0; var G = S; try { for (R(X), v = i(h); v !== null && (!(v.expirationTime > X) || I && !fe());) { var M = v.callback; if (typeof M == "function") { v.callback = null, S = v.priorityLevel; var W = M(v.expirationTime <= X); X = e.unstable_now(), typeof W == "function" ? v.callback = W : v === i(h) && s(h), R(X) } else s(h); v = i(h) } if (v !== null) var oe = !0; else { var ae = i(g); ae !== null && q(O, ae.startTime - X), oe = !1 } return oe } finally { v = null, S = G, k = !1 } } var B = !1, z = null, F = -1, Z = 5, ie = -1; function fe() { return !(e.unstable_now() - ie < Z) } function me() { if (z !== null) { var I = e.unstable_now(); ie = I; var X = !0; try { X = z(!0, I) } finally { X ? ge() : (B = !1, z = null) } } else B = !1 } var ge; if (typeof E == "function") ge = function () { E(me) }; else if (typeof MessageChannel < "u") { var pe = new MessageChannel, xe = pe.port2; pe.port1.onmessage = me, ge = function () { xe.postMessage(null) } } else ge = function () { N(me, 0) }; function se(I) { z = I, B || (B = !0, ge()) } function q(I, X) { F = N(function () { I(e.unstable_now()) }, X) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (I) { I.callback = null }, e.unstable_continueExecution = function () { P || k || (P = !0, se(V)) }, e.unstable_forceFrameRate = function (I) { 0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Z = 0 < I ? Math.floor(1e3 / I) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return S }, e.unstable_getFirstCallbackNode = function () { return i(h) }, e.unstable_next = function (I) { switch (S) { case 1: case 2: case 3: var X = 3; break; default: X = S }var G = S; S = X; try { return I() } finally { S = G } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (I, X) { switch (I) { case 1: case 2: case 3: case 4: case 5: break; default: I = 3 }var G = S; S = I; try { return X() } finally { S = G } }, e.unstable_scheduleCallback = function (I, X, G) { var M = e.unstable_now(); switch (typeof G == "object" && G !== null ? (G = G.delay, G = typeof G == "number" && 0 < G ? M + G : M) : G = M, I) { case 1: var W = -1; break; case 2: W = 250; break; case 5: W = 1073741823; break; case 4: W = 1e4; break; default: W = 5e3 }return W = G + W, I = { id: y++, callback: X, priorityLevel: I, startTime: G, expirationTime: W, sortIndex: -1 }, G > M ? (I.sortIndex = G, r(g, I), i(h) === null && I === i(g) && (C ? (j(F), F = -1) : C = !0, q(O, G - M))) : (I.sortIndex = W, r(h, I), P || k || (P = !0, se(V))), I }, e.unstable_shouldYield = fe, e.unstable_wrapCallback = function (I) { var X = S; return function () { var G = S; S = X; try { return I.apply(this, arguments) } finally { S = G } } } })(Vc)), Vc } var Gh; function b1() { return Gh || (Gh = 1, Oc.exports = k1()), Oc.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Yh; function N1() {
  if (Yh) return St; Yh = 1; var e = Zu(), r = b1(); function i(t) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, o = 1; o < arguments.length; o++)n += "&args[]=" + encodeURIComponent(arguments[o]); return "Minified React error #" + t + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var s = new Set, a = {}; function c(t, n) { u(t, n), u(t + "Capture", n) } function u(t, n) { for (a[t] = n, t = 0; t < n.length; t++)s.add(n[t]) } var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, v = {}; function S(t) { return h.call(v, t) ? !0 : h.call(y, t) ? !1 : g.test(t) ? v[t] = !0 : (y[t] = !0, !1) } function k(t, n, o, l) { if (o !== null && o.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return l ? !1 : o !== null ? !o.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function P(t, n, o, l) { if (n === null || typeof n > "u" || k(t, n, o, l)) return !0; if (l) return !1; if (o !== null) switch (o.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function C(t, n, o, l, d, m, x) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = l, this.attributeNamespace = d, this.mustUseProperty = o, this.propertyName = t, this.type = n, this.sanitizeURL = m, this.removeEmptyString = x } var N = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { N[t] = new C(t, 0, !1, t, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var n = t[0]; N[n] = new C(n, 1, !1, t[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { N[t] = new C(t, 2, !1, t.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { N[t] = new C(t, 2, !1, t, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { N[t] = new C(t, 3, !1, t.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (t) { N[t] = new C(t, 3, !0, t, null, !1, !1) }), ["capture", "download"].forEach(function (t) { N[t] = new C(t, 4, !1, t, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (t) { N[t] = new C(t, 6, !1, t, null, !1, !1) }), ["rowSpan", "start"].forEach(function (t) { N[t] = new C(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var j = /[\-:]([a-z])/g; function E(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var n = t.replace(j, E); N[n] = new C(n, 1, !1, t, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var n = t.replace(j, E); N[n] = new C(n, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var n = t.replace(j, E); N[n] = new C(n, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (t) { N[t] = new C(t, 1, !1, t.toLowerCase(), null, !1, !1) }), N.xlinkHref = new C("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (t) { N[t] = new C(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function R(t, n, o, l) { var d = N.hasOwnProperty(n) ? N[n] : null; (d !== null ? d.type !== 0 : l || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (P(n, o, d, l) && (o = null), l || d === null ? S(n) && (o === null ? t.removeAttribute(n) : t.setAttribute(n, "" + o)) : d.mustUseProperty ? t[d.propertyName] = o === null ? d.type === 3 ? !1 : "" : o : (n = d.attributeName, l = d.attributeNamespace, o === null ? t.removeAttribute(n) : (d = d.type, o = d === 3 || d === 4 && o === !0 ? "" : "" + o, l ? t.setAttributeNS(l, n, o) : t.setAttribute(n, o)))) } var O = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, V = Symbol.for("react.element"), B = Symbol.for("react.portal"), z = Symbol.for("react.fragment"), F = Symbol.for("react.strict_mode"), Z = Symbol.for("react.profiler"), ie = Symbol.for("react.provider"), fe = Symbol.for("react.context"), me = Symbol.for("react.forward_ref"), ge = Symbol.for("react.suspense"), pe = Symbol.for("react.suspense_list"), xe = Symbol.for("react.memo"), se = Symbol.for("react.lazy"), q = Symbol.for("react.offscreen"), I = Symbol.iterator; function X(t) { return t === null || typeof t != "object" ? null : (t = I && t[I] || t["@@iterator"], typeof t == "function" ? t : null) } var G = Object.assign, M; function W(t) {
    if (M === void 0) try { throw Error() } catch (o) { var n = o.stack.trim().match(/\n( *(at )?)/); M = n && n[1] || "" } return `
`+ M + t
  } var oe = !1; function ae(t, n) {
    if (!t || oe) return ""; oe = !0; var o = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (L) { var l = L } Reflect.construct(t, [], n) } else { try { n.call() } catch (L) { l = L } t.call(n.prototype) } else { try { throw Error() } catch (L) { l = L } t() } } catch (L) {
      if (L && l && typeof L.stack == "string") {
        for (var d = L.stack.split(`
`), m = l.stack.split(`
`), x = d.length - 1, b = m.length - 1; 1 <= x && 0 <= b && d[x] !== m[b];)b--; for (; 1 <= x && 0 <= b; x--, b--)if (d[x] !== m[b]) {
          if (x !== 1 || b !== 1) do if (x--, b--, 0 > b || d[x] !== m[b]) {
            var T = `
`+ d[x].replace(" at new ", " at "); return t.displayName && T.includes("<anonymous>") && (T = T.replace("<anonymous>", t.displayName)), T
          } while (1 <= x && 0 <= b); break
        }
      }
    } finally { oe = !1, Error.prepareStackTrace = o } return (t = t ? t.displayName || t.name : "") ? W(t) : ""
  } function we(t) { switch (t.tag) { case 5: return W(t.type); case 16: return W("Lazy"); case 13: return W("Suspense"); case 19: return W("SuspenseList"); case 0: case 2: case 15: return t = ae(t.type, !1), t; case 11: return t = ae(t.type.render, !1), t; case 1: return t = ae(t.type, !0), t; default: return "" } } function Ce(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case z: return "Fragment"; case B: return "Portal"; case Z: return "Profiler"; case F: return "StrictMode"; case ge: return "Suspense"; case pe: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case fe: return (t.displayName || "Context") + ".Consumer"; case ie: return (t._context.displayName || "Context") + ".Provider"; case me: var n = t.render; return t = t.displayName, t || (t = n.displayName || n.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case xe: return n = t.displayName || null, n !== null ? n : Ce(t.type) || "Memo"; case se: n = t._payload, t = t._init; try { return Ce(t(n)) } catch { } }return null } function K(t) { var n = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = n.render, t = t.displayName || t.name || "", n.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Ce(n); case 8: return n === F ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function ce(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function ve(t) { var n = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function Se(t) { var n = ve(t) ? "checked" : "value", o = Object.getOwnPropertyDescriptor(t.constructor.prototype, n), l = "" + t[n]; if (!t.hasOwnProperty(n) && typeof o < "u" && typeof o.get == "function" && typeof o.set == "function") { var d = o.get, m = o.set; return Object.defineProperty(t, n, { configurable: !0, get: function () { return d.call(this) }, set: function (x) { l = "" + x, m.call(this, x) } }), Object.defineProperty(t, n, { enumerable: o.enumerable }), { getValue: function () { return l }, setValue: function (x) { l = "" + x }, stopTracking: function () { t._valueTracker = null, delete t[n] } } } } function Pe(t) { t._valueTracker || (t._valueTracker = Se(t)) } function Re(t) { if (!t) return !1; var n = t._valueTracker; if (!n) return !0; var o = n.getValue(), l = ""; return t && (l = ve(t) ? t.checked ? "true" : "false" : t.value), t = l, t !== o ? (n.setValue(t), !0) : !1 } function rt(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function zt(t, n) { var o = n.checked; return G({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: o ?? t._wrapperState.initialChecked }) } function Tr(t, n) { var o = n.defaultValue == null ? "" : n.defaultValue, l = n.checked != null ? n.checked : n.defaultChecked; o = ce(n.value != null ? n.value : o), t._wrapperState = { initialChecked: l, initialValue: o, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function jr(t, n) { n = n.checked, n != null && R(t, "checked", n, !1) } function rr(t, n) { jr(t, n); var o = ce(n.value), l = n.type; if (o != null) l === "number" ? (o === 0 && t.value === "" || t.value != o) && (t.value = "" + o) : t.value !== "" + o && (t.value = "" + o); else if (l === "submit" || l === "reset") { t.removeAttribute("value"); return } n.hasOwnProperty("value") ? $a(t, n.type, o) : n.hasOwnProperty("defaultValue") && $a(t, n.type, ce(n.defaultValue)), n.checked == null && n.defaultChecked != null && (t.defaultChecked = !!n.defaultChecked) } function qd(t, n, o) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var l = n.type; if (!(l !== "submit" && l !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + t._wrapperState.initialValue, o || n === t.value || (t.value = n), t.defaultValue = n } o = t.name, o !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, o !== "" && (t.name = o) } function $a(t, n, o) { (n !== "number" || rt(t.ownerDocument) !== t) && (o == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + o && (t.defaultValue = "" + o)) } var bi = Array.isArray; function Ar(t, n, o, l) { if (t = t.options, n) { n = {}; for (var d = 0; d < o.length; d++)n["$" + o[d]] = !0; for (o = 0; o < t.length; o++)d = n.hasOwnProperty("$" + t[o].value), t[o].selected !== d && (t[o].selected = d), d && l && (t[o].defaultSelected = !0) } else { for (o = "" + ce(o), n = null, d = 0; d < t.length; d++) { if (t[d].value === o) { t[d].selected = !0, l && (t[d].defaultSelected = !0); return } n !== null || t[d].disabled || (n = t[d]) } n !== null && (n.selected = !0) } } function Ua(t, n) { if (n.dangerouslySetInnerHTML != null) throw Error(i(91)); return G({}, n, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Qd(t, n) { var o = n.value; if (o == null) { if (o = n.children, n = n.defaultValue, o != null) { if (n != null) throw Error(i(92)); if (bi(o)) { if (1 < o.length) throw Error(i(93)); o = o[0] } n = o } n == null && (n = ""), o = n } t._wrapperState = { initialValue: ce(o) } } function Zd(t, n) { var o = ce(n.value), l = ce(n.defaultValue); o != null && (o = "" + o, o !== t.value && (t.value = o), n.defaultValue == null && t.defaultValue !== o && (t.defaultValue = o)), l != null && (t.defaultValue = "" + l) } function Jd(t) { var n = t.textContent; n === t._wrapperState.initialValue && n !== "" && n !== null && (t.value = n) } function ef(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Ha(t, n) { return t == null || t === "http://www.w3.org/1999/xhtml" ? ef(n) : t === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var zo, tf = (function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, o, l, d) { MSApp.execUnsafeLocalFunction(function () { return t(n, o, l, d) }) } : t })(function (t, n) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = n; else { for (zo = zo || document.createElement("div"), zo.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = zo.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; n.firstChild;)t.appendChild(n.firstChild) } }); function Ni(t, n) { if (n) { var o = t.firstChild; if (o && o === t.lastChild && o.nodeType === 3) { o.nodeValue = n; return } } t.textContent = n } var Pi = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, kx = ["Webkit", "ms", "Moz", "O"]; Object.keys(Pi).forEach(function (t) { kx.forEach(function (n) { n = n + t.charAt(0).toUpperCase() + t.substring(1), Pi[n] = Pi[t] }) }); function nf(t, n, o) { return n == null || typeof n == "boolean" || n === "" ? "" : o || typeof n != "number" || n === 0 || Pi.hasOwnProperty(t) && Pi[t] ? ("" + n).trim() : n + "px" } function rf(t, n) { t = t.style; for (var o in n) if (n.hasOwnProperty(o)) { var l = o.indexOf("--") === 0, d = nf(o, n[o], l); o === "float" && (o = "cssFloat"), l ? t.setProperty(o, d) : t[o] = d } } var bx = G({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Ka(t, n) { if (n) { if (bx[t] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(i(137, t)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(i(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(i(61)) } if (n.style != null && typeof n.style != "object") throw Error(i(62)) } } function Ga(t, n) { if (t.indexOf("-") === -1) return typeof n.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ya = null; function Xa(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var qa = null, Rr = null, Mr = null; function of(t) { if (t = Yi(t)) { if (typeof qa != "function") throw Error(i(280)); var n = t.stateNode; n && (n = cs(n), qa(t.stateNode, t.type, n)) } } function sf(t) { Rr ? Mr ? Mr.push(t) : Mr = [t] : Rr = t } function af() { if (Rr) { var t = Rr, n = Mr; if (Mr = Rr = null, of(t), n) for (t = 0; t < n.length; t++)of(n[t]) } } function lf(t, n) { return t(n) } function cf() { } var Qa = !1; function uf(t, n, o) { if (Qa) return t(n, o); Qa = !0; try { return lf(t, n, o) } finally { Qa = !1, (Rr !== null || Mr !== null) && (cf(), af()) } } function Ei(t, n) { var o = t.stateNode; if (o === null) return null; var l = cs(o); if (l === null) return null; o = l[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (l = !l.disabled) || (t = t.type, l = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !l; break e; default: t = !1 }if (t) return null; if (o && typeof o != "function") throw Error(i(231, n, typeof o)); return o } var Za = !1; if (f) try { var Ti = {}; Object.defineProperty(Ti, "passive", { get: function () { Za = !0 } }), window.addEventListener("test", Ti, Ti), window.removeEventListener("test", Ti, Ti) } catch { Za = !1 } function Nx(t, n, o, l, d, m, x, b, T) { var L = Array.prototype.slice.call(arguments, 3); try { n.apply(o, L) } catch (U) { this.onError(U) } } var ji = !1, Bo = null, Wo = !1, Ja = null, Px = { onError: function (t) { ji = !0, Bo = t } }; function Ex(t, n, o, l, d, m, x, b, T) { ji = !1, Bo = null, Nx.apply(Px, arguments) } function Tx(t, n, o, l, d, m, x, b, T) { if (Ex.apply(this, arguments), ji) { if (ji) { var L = Bo; ji = !1, Bo = null } else throw Error(i(198)); Wo || (Wo = !0, Ja = L) } } function ir(t) { var n = t, o = t; if (t.alternate) for (; n.return;)n = n.return; else { t = n; do n = t, (n.flags & 4098) !== 0 && (o = n.return), t = n.return; while (t) } return n.tag === 3 ? o : null } function df(t) { if (t.tag === 13) { var n = t.memoizedState; if (n === null && (t = t.alternate, t !== null && (n = t.memoizedState)), n !== null) return n.dehydrated } return null } function ff(t) { if (ir(t) !== t) throw Error(i(188)) } function jx(t) { var n = t.alternate; if (!n) { if (n = ir(t), n === null) throw Error(i(188)); return n !== t ? null : t } for (var o = t, l = n; ;) { var d = o.return; if (d === null) break; var m = d.alternate; if (m === null) { if (l = d.return, l !== null) { o = l; continue } break } if (d.child === m.child) { for (m = d.child; m;) { if (m === o) return ff(d), t; if (m === l) return ff(d), n; m = m.sibling } throw Error(i(188)) } if (o.return !== l.return) o = d, l = m; else { for (var x = !1, b = d.child; b;) { if (b === o) { x = !0, o = d, l = m; break } if (b === l) { x = !0, l = d, o = m; break } b = b.sibling } if (!x) { for (b = m.child; b;) { if (b === o) { x = !0, o = m, l = d; break } if (b === l) { x = !0, l = m, o = d; break } b = b.sibling } if (!x) throw Error(i(189)) } } if (o.alternate !== l) throw Error(i(190)) } if (o.tag !== 3) throw Error(i(188)); return o.stateNode.current === o ? t : n } function pf(t) { return t = jx(t), t !== null ? hf(t) : null } function hf(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var n = hf(t); if (n !== null) return n; t = t.sibling } return null } var mf = r.unstable_scheduleCallback, gf = r.unstable_cancelCallback, Ax = r.unstable_shouldYield, Rx = r.unstable_requestPaint, Ue = r.unstable_now, Mx = r.unstable_getCurrentPriorityLevel, el = r.unstable_ImmediatePriority, yf = r.unstable_UserBlockingPriority, $o = r.unstable_NormalPriority, Ix = r.unstable_LowPriority, vf = r.unstable_IdlePriority, Uo = null, en = null; function Dx(t) { if (en && typeof en.onCommitFiberRoot == "function") try { en.onCommitFiberRoot(Uo, t, void 0, (t.current.flags & 128) === 128) } catch { } } var Bt = Math.clz32 ? Math.clz32 : Ox, _x = Math.log, Lx = Math.LN2; function Ox(t) { return t >>>= 0, t === 0 ? 32 : 31 - (_x(t) / Lx | 0) | 0 } var Ho = 64, Ko = 4194304; function Ai(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function Go(t, n) { var o = t.pendingLanes; if (o === 0) return 0; var l = 0, d = t.suspendedLanes, m = t.pingedLanes, x = o & 268435455; if (x !== 0) { var b = x & ~d; b !== 0 ? l = Ai(b) : (m &= x, m !== 0 && (l = Ai(m))) } else x = o & ~d, x !== 0 ? l = Ai(x) : m !== 0 && (l = Ai(m)); if (l === 0) return 0; if (n !== 0 && n !== l && (n & d) === 0 && (d = l & -l, m = n & -n, d >= m || d === 16 && (m & 4194240) !== 0)) return n; if ((l & 4) !== 0 && (l |= o & 16), n = t.entangledLanes, n !== 0) for (t = t.entanglements, n &= l; 0 < n;)o = 31 - Bt(n), d = 1 << o, l |= t[o], n &= ~d; return l } function Vx(t, n) { switch (t) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Fx(t, n) { for (var o = t.suspendedLanes, l = t.pingedLanes, d = t.expirationTimes, m = t.pendingLanes; 0 < m;) { var x = 31 - Bt(m), b = 1 << x, T = d[x]; T === -1 ? ((b & o) === 0 || (b & l) !== 0) && (d[x] = Vx(b, n)) : T <= n && (t.expiredLanes |= b), m &= ~b } } function tl(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function xf() { var t = Ho; return Ho <<= 1, (Ho & 4194240) === 0 && (Ho = 64), t } function nl(t) { for (var n = [], o = 0; 31 > o; o++)n.push(t); return n } function Ri(t, n, o) { t.pendingLanes |= n, n !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, n = 31 - Bt(n), t[n] = o } function zx(t, n) { var o = t.pendingLanes & ~n; t.pendingLanes = n, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= n, t.mutableReadLanes &= n, t.entangledLanes &= n, n = t.entanglements; var l = t.eventTimes; for (t = t.expirationTimes; 0 < o;) { var d = 31 - Bt(o), m = 1 << d; n[d] = 0, l[d] = -1, t[d] = -1, o &= ~m } } function rl(t, n) { var o = t.entangledLanes |= n; for (t = t.entanglements; o;) { var l = 31 - Bt(o), d = 1 << l; d & n | t[l] & n && (t[l] |= n), o &= ~d } } var Ae = 0; function wf(t) { return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Sf, il, Cf, kf, bf, ol = !1, Yo = [], En = null, Tn = null, jn = null, Mi = new Map, Ii = new Map, An = [], Bx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Nf(t, n) { switch (t) { case "focusin": case "focusout": En = null; break; case "dragenter": case "dragleave": Tn = null; break; case "mouseover": case "mouseout": jn = null; break; case "pointerover": case "pointerout": Mi.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ii.delete(n.pointerId) } } function Di(t, n, o, l, d, m) { return t === null || t.nativeEvent !== m ? (t = { blockedOn: n, domEventName: o, eventSystemFlags: l, nativeEvent: m, targetContainers: [d] }, n !== null && (n = Yi(n), n !== null && il(n)), t) : (t.eventSystemFlags |= l, n = t.targetContainers, d !== null && n.indexOf(d) === -1 && n.push(d), t) } function Wx(t, n, o, l, d) { switch (n) { case "focusin": return En = Di(En, t, n, o, l, d), !0; case "dragenter": return Tn = Di(Tn, t, n, o, l, d), !0; case "mouseover": return jn = Di(jn, t, n, o, l, d), !0; case "pointerover": var m = d.pointerId; return Mi.set(m, Di(Mi.get(m) || null, t, n, o, l, d)), !0; case "gotpointercapture": return m = d.pointerId, Ii.set(m, Di(Ii.get(m) || null, t, n, o, l, d)), !0 }return !1 } function Pf(t) { var n = or(t.target); if (n !== null) { var o = ir(n); if (o !== null) { if (n = o.tag, n === 13) { if (n = df(o), n !== null) { t.blockedOn = n, bf(t.priority, function () { Cf(o) }); return } } else if (n === 3 && o.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = o.tag === 3 ? o.stateNode.containerInfo : null; return } } } t.blockedOn = null } function Xo(t) { if (t.blockedOn !== null) return !1; for (var n = t.targetContainers; 0 < n.length;) { var o = al(t.domEventName, t.eventSystemFlags, n[0], t.nativeEvent); if (o === null) { o = t.nativeEvent; var l = new o.constructor(o.type, o); Ya = l, o.target.dispatchEvent(l), Ya = null } else return n = Yi(o), n !== null && il(n), t.blockedOn = o, !1; n.shift() } return !0 } function Ef(t, n, o) { Xo(t) && o.delete(n) } function $x() { ol = !1, En !== null && Xo(En) && (En = null), Tn !== null && Xo(Tn) && (Tn = null), jn !== null && Xo(jn) && (jn = null), Mi.forEach(Ef), Ii.forEach(Ef) } function _i(t, n) { t.blockedOn === n && (t.blockedOn = null, ol || (ol = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, $x))) } function Li(t) { function n(d) { return _i(d, t) } if (0 < Yo.length) { _i(Yo[0], t); for (var o = 1; o < Yo.length; o++) { var l = Yo[o]; l.blockedOn === t && (l.blockedOn = null) } } for (En !== null && _i(En, t), Tn !== null && _i(Tn, t), jn !== null && _i(jn, t), Mi.forEach(n), Ii.forEach(n), o = 0; o < An.length; o++)l = An[o], l.blockedOn === t && (l.blockedOn = null); for (; 0 < An.length && (o = An[0], o.blockedOn === null);)Pf(o), o.blockedOn === null && An.shift() } var Ir = O.ReactCurrentBatchConfig, qo = !0; function Ux(t, n, o, l) { var d = Ae, m = Ir.transition; Ir.transition = null; try { Ae = 1, sl(t, n, o, l) } finally { Ae = d, Ir.transition = m } } function Hx(t, n, o, l) { var d = Ae, m = Ir.transition; Ir.transition = null; try { Ae = 4, sl(t, n, o, l) } finally { Ae = d, Ir.transition = m } } function sl(t, n, o, l) { if (qo) { var d = al(t, n, o, l); if (d === null) bl(t, n, l, Qo, o), Nf(t, l); else if (Wx(d, t, n, o, l)) l.stopPropagation(); else if (Nf(t, l), n & 4 && -1 < Bx.indexOf(t)) { for (; d !== null;) { var m = Yi(d); if (m !== null && Sf(m), m = al(t, n, o, l), m === null && bl(t, n, l, Qo, o), m === d) break; d = m } d !== null && l.stopPropagation() } else bl(t, n, l, null, o) } } var Qo = null; function al(t, n, o, l) { if (Qo = null, t = Xa(l), t = or(t), t !== null) if (n = ir(t), n === null) t = null; else if (o = n.tag, o === 13) { if (t = df(n), t !== null) return t; t = null } else if (o === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; t = null } else n !== t && (t = null); return Qo = t, null } function Tf(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Mx()) { case el: return 1; case yf: return 4; case $o: case Ix: return 16; case vf: return 536870912; default: return 16 }default: return 16 } } var Rn = null, ll = null, Zo = null; function jf() { if (Zo) return Zo; var t, n = ll, o = n.length, l, d = "value" in Rn ? Rn.value : Rn.textContent, m = d.length; for (t = 0; t < o && n[t] === d[t]; t++); var x = o - t; for (l = 1; l <= x && n[o - l] === d[m - l]; l++); return Zo = d.slice(t, 1 < l ? 1 - l : void 0) } function Jo(t) { var n = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && n === 13 && (t = 13)) : t = n, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function es() { return !0 } function Af() { return !1 } function kt(t) { function n(o, l, d, m, x) { this._reactName = o, this._targetInst = d, this.type = l, this.nativeEvent = m, this.target = x, this.currentTarget = null; for (var b in t) t.hasOwnProperty(b) && (o = t[b], this[b] = o ? o(m) : m[b]); return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? es : Af, this.isPropagationStopped = Af, this } return G(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var o = this.nativeEvent; o && (o.preventDefault ? o.preventDefault() : typeof o.returnValue != "unknown" && (o.returnValue = !1), this.isDefaultPrevented = es) }, stopPropagation: function () { var o = this.nativeEvent; o && (o.stopPropagation ? o.stopPropagation() : typeof o.cancelBubble != "unknown" && (o.cancelBubble = !0), this.isPropagationStopped = es) }, persist: function () { }, isPersistent: es }), n } var Dr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, cl = kt(Dr), Oi = G({}, Dr, { view: 0, detail: 0 }), Kx = kt(Oi), ul, dl, Vi, ts = G({}, Oi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: pl, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Vi && (Vi && t.type === "mousemove" ? (ul = t.screenX - Vi.screenX, dl = t.screenY - Vi.screenY) : dl = ul = 0, Vi = t), ul) }, movementY: function (t) { return "movementY" in t ? t.movementY : dl } }), Rf = kt(ts), Gx = G({}, ts, { dataTransfer: 0 }), Yx = kt(Gx), Xx = G({}, Oi, { relatedTarget: 0 }), fl = kt(Xx), qx = G({}, Dr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Qx = kt(qx), Zx = G({}, Dr, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), Jx = kt(Zx), ew = G({}, Dr, { data: 0 }), Mf = kt(ew), tw = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, nw = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, rw = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function iw(t) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(t) : (t = rw[t]) ? !!n[t] : !1 } function pl() { return iw } var ow = G({}, Oi, { key: function (t) { if (t.key) { var n = tw[t.key] || t.key; if (n !== "Unidentified") return n } return t.type === "keypress" ? (t = Jo(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? nw[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: pl, charCode: function (t) { return t.type === "keypress" ? Jo(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? Jo(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), sw = kt(ow), aw = G({}, ts, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), If = kt(aw), lw = G({}, Oi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: pl }), cw = kt(lw), uw = G({}, Dr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), dw = kt(uw), fw = G({}, ts, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), pw = kt(fw), hw = [9, 13, 27, 32], hl = f && "CompositionEvent" in window, Fi = null; f && "documentMode" in document && (Fi = document.documentMode); var mw = f && "TextEvent" in window && !Fi, Df = f && (!hl || Fi && 8 < Fi && 11 >= Fi), _f = " ", Lf = !1; function Of(t, n) { switch (t) { case "keyup": return hw.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Vf(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var _r = !1; function gw(t, n) { switch (t) { case "compositionend": return Vf(n); case "keypress": return n.which !== 32 ? null : (Lf = !0, _f); case "textInput": return t = n.data, t === _f && Lf ? null : t; default: return null } } function yw(t, n) { if (_r) return t === "compositionend" || !hl && Of(t, n) ? (t = jf(), Zo = ll = Rn = null, _r = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return Df && n.locale !== "ko" ? null : n.data; default: return null } } var vw = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Ff(t) { var n = t && t.nodeName && t.nodeName.toLowerCase(); return n === "input" ? !!vw[t.type] : n === "textarea" } function zf(t, n, o, l) { sf(l), n = ss(n, "onChange"), 0 < n.length && (o = new cl("onChange", "change", null, o, l), t.push({ event: o, listeners: n })) } var zi = null, Bi = null; function xw(t) { ip(t, 0) } function ns(t) { var n = zr(t); if (Re(n)) return t } function ww(t, n) { if (t === "change") return n } var Bf = !1; if (f) { var ml; if (f) { var gl = "oninput" in document; if (!gl) { var Wf = document.createElement("div"); Wf.setAttribute("oninput", "return;"), gl = typeof Wf.oninput == "function" } ml = gl } else ml = !1; Bf = ml && (!document.documentMode || 9 < document.documentMode) } function $f() { zi && (zi.detachEvent("onpropertychange", Uf), Bi = zi = null) } function Uf(t) { if (t.propertyName === "value" && ns(Bi)) { var n = []; zf(n, Bi, t, Xa(t)), uf(xw, n) } } function Sw(t, n, o) { t === "focusin" ? ($f(), zi = n, Bi = o, zi.attachEvent("onpropertychange", Uf)) : t === "focusout" && $f() } function Cw(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return ns(Bi) } function kw(t, n) { if (t === "click") return ns(n) } function bw(t, n) { if (t === "input" || t === "change") return ns(n) } function Nw(t, n) { return t === n && (t !== 0 || 1 / t === 1 / n) || t !== t && n !== n } var Wt = typeof Object.is == "function" ? Object.is : Nw; function Wi(t, n) { if (Wt(t, n)) return !0; if (typeof t != "object" || t === null || typeof n != "object" || n === null) return !1; var o = Object.keys(t), l = Object.keys(n); if (o.length !== l.length) return !1; for (l = 0; l < o.length; l++) { var d = o[l]; if (!h.call(n, d) || !Wt(t[d], n[d])) return !1 } return !0 } function Hf(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function Kf(t, n) { var o = Hf(t); t = 0; for (var l; o;) { if (o.nodeType === 3) { if (l = t + o.textContent.length, t <= n && l >= n) return { node: o, offset: n - t }; t = l } e: { for (; o;) { if (o.nextSibling) { o = o.nextSibling; break e } o = o.parentNode } o = void 0 } o = Hf(o) } } function Gf(t, n) { return t && n ? t === n ? !0 : t && t.nodeType === 3 ? !1 : n && n.nodeType === 3 ? Gf(t, n.parentNode) : "contains" in t ? t.contains(n) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(n) & 16) : !1 : !1 } function Yf() { for (var t = window, n = rt(); n instanceof t.HTMLIFrameElement;) { try { var o = typeof n.contentWindow.location.href == "string" } catch { o = !1 } if (o) t = n.contentWindow; else break; n = rt(t.document) } return n } function yl(t) { var n = t && t.nodeName && t.nodeName.toLowerCase(); return n && (n === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || n === "textarea" || t.contentEditable === "true") } function Pw(t) { var n = Yf(), o = t.focusedElem, l = t.selectionRange; if (n !== o && o && o.ownerDocument && Gf(o.ownerDocument.documentElement, o)) { if (l !== null && yl(o)) { if (n = l.start, t = l.end, t === void 0 && (t = n), "selectionStart" in o) o.selectionStart = n, o.selectionEnd = Math.min(t, o.value.length); else if (t = (n = o.ownerDocument || document) && n.defaultView || window, t.getSelection) { t = t.getSelection(); var d = o.textContent.length, m = Math.min(l.start, d); l = l.end === void 0 ? m : Math.min(l.end, d), !t.extend && m > l && (d = l, l = m, m = d), d = Kf(o, m); var x = Kf(o, l); d && x && (t.rangeCount !== 1 || t.anchorNode !== d.node || t.anchorOffset !== d.offset || t.focusNode !== x.node || t.focusOffset !== x.offset) && (n = n.createRange(), n.setStart(d.node, d.offset), t.removeAllRanges(), m > l ? (t.addRange(n), t.extend(x.node, x.offset)) : (n.setEnd(x.node, x.offset), t.addRange(n))) } } for (n = [], t = o; t = t.parentNode;)t.nodeType === 1 && n.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof o.focus == "function" && o.focus(), o = 0; o < n.length; o++)t = n[o], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var Ew = f && "documentMode" in document && 11 >= document.documentMode, Lr = null, vl = null, $i = null, xl = !1; function Xf(t, n, o) { var l = o.window === o ? o.document : o.nodeType === 9 ? o : o.ownerDocument; xl || Lr == null || Lr !== rt(l) || (l = Lr, "selectionStart" in l && yl(l) ? l = { start: l.selectionStart, end: l.selectionEnd } : (l = (l.ownerDocument && l.ownerDocument.defaultView || window).getSelection(), l = { anchorNode: l.anchorNode, anchorOffset: l.anchorOffset, focusNode: l.focusNode, focusOffset: l.focusOffset }), $i && Wi($i, l) || ($i = l, l = ss(vl, "onSelect"), 0 < l.length && (n = new cl("onSelect", "select", null, n, o), t.push({ event: n, listeners: l }), n.target = Lr))) } function rs(t, n) { var o = {}; return o[t.toLowerCase()] = n.toLowerCase(), o["Webkit" + t] = "webkit" + n, o["Moz" + t] = "moz" + n, o } var Or = { animationend: rs("Animation", "AnimationEnd"), animationiteration: rs("Animation", "AnimationIteration"), animationstart: rs("Animation", "AnimationStart"), transitionend: rs("Transition", "TransitionEnd") }, wl = {}, qf = {}; f && (qf = document.createElement("div").style, "AnimationEvent" in window || (delete Or.animationend.animation, delete Or.animationiteration.animation, delete Or.animationstart.animation), "TransitionEvent" in window || delete Or.transitionend.transition); function is(t) { if (wl[t]) return wl[t]; if (!Or[t]) return t; var n = Or[t], o; for (o in n) if (n.hasOwnProperty(o) && o in qf) return wl[t] = n[o]; return t } var Qf = is("animationend"), Zf = is("animationiteration"), Jf = is("animationstart"), ep = is("transitionend"), tp = new Map, np = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Mn(t, n) { tp.set(t, n), c(n, [t]) } for (var Sl = 0; Sl < np.length; Sl++) { var Cl = np[Sl], Tw = Cl.toLowerCase(), jw = Cl[0].toUpperCase() + Cl.slice(1); Mn(Tw, "on" + jw) } Mn(Qf, "onAnimationEnd"), Mn(Zf, "onAnimationIteration"), Mn(Jf, "onAnimationStart"), Mn("dblclick", "onDoubleClick"), Mn("focusin", "onFocus"), Mn("focusout", "onBlur"), Mn(ep, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), c("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), c("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), c("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Ui = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Aw = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ui)); function rp(t, n, o) { var l = t.type || "unknown-event"; t.currentTarget = o, Tx(l, n, void 0, t), t.currentTarget = null } function ip(t, n) { n = (n & 4) !== 0; for (var o = 0; o < t.length; o++) { var l = t[o], d = l.event; l = l.listeners; e: { var m = void 0; if (n) for (var x = l.length - 1; 0 <= x; x--) { var b = l[x], T = b.instance, L = b.currentTarget; if (b = b.listener, T !== m && d.isPropagationStopped()) break e; rp(d, b, L), m = T } else for (x = 0; x < l.length; x++) { if (b = l[x], T = b.instance, L = b.currentTarget, b = b.listener, T !== m && d.isPropagationStopped()) break e; rp(d, b, L), m = T } } } if (Wo) throw t = Ja, Wo = !1, Ja = null, t } function De(t, n) { var o = n[Al]; o === void 0 && (o = n[Al] = new Set); var l = t + "__bubble"; o.has(l) || (op(n, t, 2, !1), o.add(l)) } function kl(t, n, o) { var l = 0; n && (l |= 4), op(o, t, l, n) } var os = "_reactListening" + Math.random().toString(36).slice(2); function Hi(t) { if (!t[os]) { t[os] = !0, s.forEach(function (o) { o !== "selectionchange" && (Aw.has(o) || kl(o, !1, t), kl(o, !0, t)) }); var n = t.nodeType === 9 ? t : t.ownerDocument; n === null || n[os] || (n[os] = !0, kl("selectionchange", !1, n)) } } function op(t, n, o, l) { switch (Tf(n)) { case 1: var d = Ux; break; case 4: d = Hx; break; default: d = sl }o = d.bind(null, n, o, t), d = void 0, !Za || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (d = !0), l ? d !== void 0 ? t.addEventListener(n, o, { capture: !0, passive: d }) : t.addEventListener(n, o, !0) : d !== void 0 ? t.addEventListener(n, o, { passive: d }) : t.addEventListener(n, o, !1) } function bl(t, n, o, l, d) { var m = l; if ((n & 1) === 0 && (n & 2) === 0 && l !== null) e: for (; ;) { if (l === null) return; var x = l.tag; if (x === 3 || x === 4) { var b = l.stateNode.containerInfo; if (b === d || b.nodeType === 8 && b.parentNode === d) break; if (x === 4) for (x = l.return; x !== null;) { var T = x.tag; if ((T === 3 || T === 4) && (T = x.stateNode.containerInfo, T === d || T.nodeType === 8 && T.parentNode === d)) return; x = x.return } for (; b !== null;) { if (x = or(b), x === null) return; if (T = x.tag, T === 5 || T === 6) { l = m = x; continue e } b = b.parentNode } } l = l.return } uf(function () { var L = m, U = Xa(o), H = []; e: { var $ = tp.get(t); if ($ !== void 0) { var Q = cl, ee = t; switch (t) { case "keypress": if (Jo(o) === 0) break e; case "keydown": case "keyup": Q = sw; break; case "focusin": ee = "focus", Q = fl; break; case "focusout": ee = "blur", Q = fl; break; case "beforeblur": case "afterblur": Q = fl; break; case "click": if (o.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Q = Rf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Q = Yx; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Q = cw; break; case Qf: case Zf: case Jf: Q = Qx; break; case ep: Q = dw; break; case "scroll": Q = Kx; break; case "wheel": Q = pw; break; case "copy": case "cut": case "paste": Q = Jx; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Q = If }var re = (n & 4) !== 0, He = !re && t === "scroll", D = re ? $ !== null ? $ + "Capture" : null : $; re = []; for (var A = L, _; A !== null;) { _ = A; var Y = _.stateNode; if (_.tag === 5 && Y !== null && (_ = Y, D !== null && (Y = Ei(A, D), Y != null && re.push(Ki(A, Y, _)))), He) break; A = A.return } 0 < re.length && ($ = new Q($, ee, null, o, U), H.push({ event: $, listeners: re })) } } if ((n & 7) === 0) { e: { if ($ = t === "mouseover" || t === "pointerover", Q = t === "mouseout" || t === "pointerout", $ && o !== Ya && (ee = o.relatedTarget || o.fromElement) && (or(ee) || ee[pn])) break e; if ((Q || $) && ($ = U.window === U ? U : ($ = U.ownerDocument) ? $.defaultView || $.parentWindow : window, Q ? (ee = o.relatedTarget || o.toElement, Q = L, ee = ee ? or(ee) : null, ee !== null && (He = ir(ee), ee !== He || ee.tag !== 5 && ee.tag !== 6) && (ee = null)) : (Q = null, ee = L), Q !== ee)) { if (re = Rf, Y = "onMouseLeave", D = "onMouseEnter", A = "mouse", (t === "pointerout" || t === "pointerover") && (re = If, Y = "onPointerLeave", D = "onPointerEnter", A = "pointer"), He = Q == null ? $ : zr(Q), _ = ee == null ? $ : zr(ee), $ = new re(Y, A + "leave", Q, o, U), $.target = He, $.relatedTarget = _, Y = null, or(U) === L && (re = new re(D, A + "enter", ee, o, U), re.target = _, re.relatedTarget = He, Y = re), He = Y, Q && ee) t: { for (re = Q, D = ee, A = 0, _ = re; _; _ = Vr(_))A++; for (_ = 0, Y = D; Y; Y = Vr(Y))_++; for (; 0 < A - _;)re = Vr(re), A--; for (; 0 < _ - A;)D = Vr(D), _--; for (; A--;) { if (re === D || D !== null && re === D.alternate) break t; re = Vr(re), D = Vr(D) } re = null } else re = null; Q !== null && sp(H, $, Q, re, !1), ee !== null && He !== null && sp(H, He, ee, re, !0) } } e: { if ($ = L ? zr(L) : window, Q = $.nodeName && $.nodeName.toLowerCase(), Q === "select" || Q === "input" && $.type === "file") var le = ww; else if (Ff($)) if (Bf) le = bw; else { le = Cw; var ue = Sw } else (Q = $.nodeName) && Q.toLowerCase() === "input" && ($.type === "checkbox" || $.type === "radio") && (le = kw); if (le && (le = le(t, L))) { zf(H, le, o, U); break e } ue && ue(t, $, L), t === "focusout" && (ue = $._wrapperState) && ue.controlled && $.type === "number" && $a($, "number", $.value) } switch (ue = L ? zr(L) : window, t) { case "focusin": (Ff(ue) || ue.contentEditable === "true") && (Lr = ue, vl = L, $i = null); break; case "focusout": $i = vl = Lr = null; break; case "mousedown": xl = !0; break; case "contextmenu": case "mouseup": case "dragend": xl = !1, Xf(H, o, U); break; case "selectionchange": if (Ew) break; case "keydown": case "keyup": Xf(H, o, U) }var de; if (hl) e: { switch (t) { case "compositionstart": var ye = "onCompositionStart"; break e; case "compositionend": ye = "onCompositionEnd"; break e; case "compositionupdate": ye = "onCompositionUpdate"; break e }ye = void 0 } else _r ? Of(t, o) && (ye = "onCompositionEnd") : t === "keydown" && o.keyCode === 229 && (ye = "onCompositionStart"); ye && (Df && o.locale !== "ko" && (_r || ye !== "onCompositionStart" ? ye === "onCompositionEnd" && _r && (de = jf()) : (Rn = U, ll = "value" in Rn ? Rn.value : Rn.textContent, _r = !0)), ue = ss(L, ye), 0 < ue.length && (ye = new Mf(ye, t, null, o, U), H.push({ event: ye, listeners: ue }), de ? ye.data = de : (de = Vf(o), de !== null && (ye.data = de)))), (de = mw ? gw(t, o) : yw(t, o)) && (L = ss(L, "onBeforeInput"), 0 < L.length && (U = new Mf("onBeforeInput", "beforeinput", null, o, U), H.push({ event: U, listeners: L }), U.data = de)) } ip(H, n) }) } function Ki(t, n, o) { return { instance: t, listener: n, currentTarget: o } } function ss(t, n) { for (var o = n + "Capture", l = []; t !== null;) { var d = t, m = d.stateNode; d.tag === 5 && m !== null && (d = m, m = Ei(t, o), m != null && l.unshift(Ki(t, m, d)), m = Ei(t, n), m != null && l.push(Ki(t, m, d))), t = t.return } return l } function Vr(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function sp(t, n, o, l, d) { for (var m = n._reactName, x = []; o !== null && o !== l;) { var b = o, T = b.alternate, L = b.stateNode; if (T !== null && T === l) break; b.tag === 5 && L !== null && (b = L, d ? (T = Ei(o, m), T != null && x.unshift(Ki(o, T, b))) : d || (T = Ei(o, m), T != null && x.push(Ki(o, T, b)))), o = o.return } x.length !== 0 && t.push({ event: n, listeners: x }) } var Rw = /\r\n?/g, Mw = /\u0000|\uFFFD/g; function ap(t) {
    return (typeof t == "string" ? t : "" + t).replace(Rw, `
`).replace(Mw, "")
  } function as(t, n, o) { if (n = ap(n), ap(t) !== n && o) throw Error(i(425)) } function ls() { } var Nl = null, Pl = null; function El(t, n) { return t === "textarea" || t === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var Tl = typeof setTimeout == "function" ? setTimeout : void 0, Iw = typeof clearTimeout == "function" ? clearTimeout : void 0, lp = typeof Promise == "function" ? Promise : void 0, Dw = typeof queueMicrotask == "function" ? queueMicrotask : typeof lp < "u" ? function (t) { return lp.resolve(null).then(t).catch(_w) } : Tl; function _w(t) { setTimeout(function () { throw t }) } function jl(t, n) { var o = n, l = 0; do { var d = o.nextSibling; if (t.removeChild(o), d && d.nodeType === 8) if (o = d.data, o === "/$") { if (l === 0) { t.removeChild(d), Li(n); return } l-- } else o !== "$" && o !== "$?" && o !== "$!" || l++; o = d } while (o); Li(n) } function In(t) { for (; t != null; t = t.nextSibling) { var n = t.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = t.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return t } function cp(t) { t = t.previousSibling; for (var n = 0; t;) { if (t.nodeType === 8) { var o = t.data; if (o === "$" || o === "$!" || o === "$?") { if (n === 0) return t; n-- } else o === "/$" && n++ } t = t.previousSibling } return null } var Fr = Math.random().toString(36).slice(2), tn = "__reactFiber$" + Fr, Gi = "__reactProps$" + Fr, pn = "__reactContainer$" + Fr, Al = "__reactEvents$" + Fr, Lw = "__reactListeners$" + Fr, Ow = "__reactHandles$" + Fr; function or(t) { var n = t[tn]; if (n) return n; for (var o = t.parentNode; o;) { if (n = o[pn] || o[tn]) { if (o = n.alternate, n.child !== null || o !== null && o.child !== null) for (t = cp(t); t !== null;) { if (o = t[tn]) return o; t = cp(t) } return n } t = o, o = t.parentNode } return null } function Yi(t) { return t = t[tn] || t[pn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function zr(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(i(33)) } function cs(t) { return t[Gi] || null } var Rl = [], Br = -1; function Dn(t) { return { current: t } } function _e(t) { 0 > Br || (t.current = Rl[Br], Rl[Br] = null, Br--) } function Me(t, n) { Br++, Rl[Br] = t.current, t.current = n } var _n = {}, lt = Dn(_n), gt = Dn(!1), sr = _n; function Wr(t, n) { var o = t.type.contextTypes; if (!o) return _n; var l = t.stateNode; if (l && l.__reactInternalMemoizedUnmaskedChildContext === n) return l.__reactInternalMemoizedMaskedChildContext; var d = {}, m; for (m in o) d[m] = n[m]; return l && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = n, t.__reactInternalMemoizedMaskedChildContext = d), d } function yt(t) { return t = t.childContextTypes, t != null } function us() { _e(gt), _e(lt) } function up(t, n, o) { if (lt.current !== _n) throw Error(i(168)); Me(lt, n), Me(gt, o) } function dp(t, n, o) { var l = t.stateNode; if (n = n.childContextTypes, typeof l.getChildContext != "function") return o; l = l.getChildContext(); for (var d in l) if (!(d in n)) throw Error(i(108, K(t) || "Unknown", d)); return G({}, o, l) } function ds(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || _n, sr = lt.current, Me(lt, t), Me(gt, gt.current), !0 } function fp(t, n, o) { var l = t.stateNode; if (!l) throw Error(i(169)); o ? (t = dp(t, n, sr), l.__reactInternalMemoizedMergedChildContext = t, _e(gt), _e(lt), Me(lt, t)) : _e(gt), Me(gt, o) } var hn = null, fs = !1, Ml = !1; function pp(t) { hn === null ? hn = [t] : hn.push(t) } function Vw(t) { fs = !0, pp(t) } function Ln() { if (!Ml && hn !== null) { Ml = !0; var t = 0, n = Ae; try { var o = hn; for (Ae = 1; t < o.length; t++) { var l = o[t]; do l = l(!0); while (l !== null) } hn = null, fs = !1 } catch (d) { throw hn !== null && (hn = hn.slice(t + 1)), mf(el, Ln), d } finally { Ae = n, Ml = !1 } } return null } var $r = [], Ur = 0, ps = null, hs = 0, At = [], Rt = 0, ar = null, mn = 1, gn = ""; function lr(t, n) { $r[Ur++] = hs, $r[Ur++] = ps, ps = t, hs = n } function hp(t, n, o) { At[Rt++] = mn, At[Rt++] = gn, At[Rt++] = ar, ar = t; var l = mn; t = gn; var d = 32 - Bt(l) - 1; l &= ~(1 << d), o += 1; var m = 32 - Bt(n) + d; if (30 < m) { var x = d - d % 5; m = (l & (1 << x) - 1).toString(32), l >>= x, d -= x, mn = 1 << 32 - Bt(n) + d | o << d | l, gn = m + t } else mn = 1 << m | o << d | l, gn = t } function Il(t) { t.return !== null && (lr(t, 1), hp(t, 1, 0)) } function Dl(t) { for (; t === ps;)ps = $r[--Ur], $r[Ur] = null, hs = $r[--Ur], $r[Ur] = null; for (; t === ar;)ar = At[--Rt], At[Rt] = null, gn = At[--Rt], At[Rt] = null, mn = At[--Rt], At[Rt] = null } var bt = null, Nt = null, Le = !1, $t = null; function mp(t, n) { var o = _t(5, null, null, 0); o.elementType = "DELETED", o.stateNode = n, o.return = t, n = t.deletions, n === null ? (t.deletions = [o], t.flags |= 16) : n.push(o) } function gp(t, n) { switch (t.tag) { case 5: var o = t.type; return n = n.nodeType !== 1 || o.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (t.stateNode = n, bt = t, Nt = In(n.firstChild), !0) : !1; case 6: return n = t.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (t.stateNode = n, bt = t, Nt = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (o = ar !== null ? { id: mn, overflow: gn } : null, t.memoizedState = { dehydrated: n, treeContext: o, retryLane: 1073741824 }, o = _t(18, null, null, 0), o.stateNode = n, o.return = t, t.child = o, bt = t, Nt = null, !0) : !1; default: return !1 } } function _l(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Ll(t) { if (Le) { var n = Nt; if (n) { var o = n; if (!gp(t, n)) { if (_l(t)) throw Error(i(418)); n = In(o.nextSibling); var l = bt; n && gp(t, n) ? mp(l, o) : (t.flags = t.flags & -4097 | 2, Le = !1, bt = t) } } else { if (_l(t)) throw Error(i(418)); t.flags = t.flags & -4097 | 2, Le = !1, bt = t } } } function yp(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; bt = t } function ms(t) { if (t !== bt) return !1; if (!Le) return yp(t), Le = !0, !1; var n; if ((n = t.tag !== 3) && !(n = t.tag !== 5) && (n = t.type, n = n !== "head" && n !== "body" && !El(t.type, t.memoizedProps)), n && (n = Nt)) { if (_l(t)) throw vp(), Error(i(418)); for (; n;)mp(t, n), n = In(n.nextSibling) } if (yp(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(i(317)); e: { for (t = t.nextSibling, n = 0; t;) { if (t.nodeType === 8) { var o = t.data; if (o === "/$") { if (n === 0) { Nt = In(t.nextSibling); break e } n-- } else o !== "$" && o !== "$!" && o !== "$?" || n++ } t = t.nextSibling } Nt = null } } else Nt = bt ? In(t.stateNode.nextSibling) : null; return !0 } function vp() { for (var t = Nt; t;)t = In(t.nextSibling) } function Hr() { Nt = bt = null, Le = !1 } function Ol(t) { $t === null ? $t = [t] : $t.push(t) } var Fw = O.ReactCurrentBatchConfig; function Xi(t, n, o) { if (t = o.ref, t !== null && typeof t != "function" && typeof t != "object") { if (o._owner) { if (o = o._owner, o) { if (o.tag !== 1) throw Error(i(309)); var l = o.stateNode } if (!l) throw Error(i(147, t)); var d = l, m = "" + t; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === m ? n.ref : (n = function (x) { var b = d.refs; x === null ? delete b[m] : b[m] = x }, n._stringRef = m, n) } if (typeof t != "string") throw Error(i(284)); if (!o._owner) throw Error(i(290, t)) } return t } function gs(t, n) { throw t = Object.prototype.toString.call(n), Error(i(31, t === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : t)) } function xp(t) { var n = t._init; return n(t._payload) } function wp(t) { function n(D, A) { if (t) { var _ = D.deletions; _ === null ? (D.deletions = [A], D.flags |= 16) : _.push(A) } } function o(D, A) { if (!t) return null; for (; A !== null;)n(D, A), A = A.sibling; return null } function l(D, A) { for (D = new Map; A !== null;)A.key !== null ? D.set(A.key, A) : D.set(A.index, A), A = A.sibling; return D } function d(D, A) { return D = Un(D, A), D.index = 0, D.sibling = null, D } function m(D, A, _) { return D.index = _, t ? (_ = D.alternate, _ !== null ? (_ = _.index, _ < A ? (D.flags |= 2, A) : _) : (D.flags |= 2, A)) : (D.flags |= 1048576, A) } function x(D) { return t && D.alternate === null && (D.flags |= 2), D } function b(D, A, _, Y) { return A === null || A.tag !== 6 ? (A = Tc(_, D.mode, Y), A.return = D, A) : (A = d(A, _), A.return = D, A) } function T(D, A, _, Y) { var le = _.type; return le === z ? U(D, A, _.props.children, Y, _.key) : A !== null && (A.elementType === le || typeof le == "object" && le !== null && le.$$typeof === se && xp(le) === A.type) ? (Y = d(A, _.props), Y.ref = Xi(D, A, _), Y.return = D, Y) : (Y = zs(_.type, _.key, _.props, null, D.mode, Y), Y.ref = Xi(D, A, _), Y.return = D, Y) } function L(D, A, _, Y) { return A === null || A.tag !== 4 || A.stateNode.containerInfo !== _.containerInfo || A.stateNode.implementation !== _.implementation ? (A = jc(_, D.mode, Y), A.return = D, A) : (A = d(A, _.children || []), A.return = D, A) } function U(D, A, _, Y, le) { return A === null || A.tag !== 7 ? (A = gr(_, D.mode, Y, le), A.return = D, A) : (A = d(A, _), A.return = D, A) } function H(D, A, _) { if (typeof A == "string" && A !== "" || typeof A == "number") return A = Tc("" + A, D.mode, _), A.return = D, A; if (typeof A == "object" && A !== null) { switch (A.$$typeof) { case V: return _ = zs(A.type, A.key, A.props, null, D.mode, _), _.ref = Xi(D, null, A), _.return = D, _; case B: return A = jc(A, D.mode, _), A.return = D, A; case se: var Y = A._init; return H(D, Y(A._payload), _) }if (bi(A) || X(A)) return A = gr(A, D.mode, _, null), A.return = D, A; gs(D, A) } return null } function $(D, A, _, Y) { var le = A !== null ? A.key : null; if (typeof _ == "string" && _ !== "" || typeof _ == "number") return le !== null ? null : b(D, A, "" + _, Y); if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case V: return _.key === le ? T(D, A, _, Y) : null; case B: return _.key === le ? L(D, A, _, Y) : null; case se: return le = _._init, $(D, A, le(_._payload), Y) }if (bi(_) || X(_)) return le !== null ? null : U(D, A, _, Y, null); gs(D, _) } return null } function Q(D, A, _, Y, le) { if (typeof Y == "string" && Y !== "" || typeof Y == "number") return D = D.get(_) || null, b(A, D, "" + Y, le); if (typeof Y == "object" && Y !== null) { switch (Y.$$typeof) { case V: return D = D.get(Y.key === null ? _ : Y.key) || null, T(A, D, Y, le); case B: return D = D.get(Y.key === null ? _ : Y.key) || null, L(A, D, Y, le); case se: var ue = Y._init; return Q(D, A, _, ue(Y._payload), le) }if (bi(Y) || X(Y)) return D = D.get(_) || null, U(A, D, Y, le, null); gs(A, Y) } return null } function ee(D, A, _, Y) { for (var le = null, ue = null, de = A, ye = A = 0, nt = null; de !== null && ye < _.length; ye++) { de.index > ye ? (nt = de, de = null) : nt = de.sibling; var Te = $(D, de, _[ye], Y); if (Te === null) { de === null && (de = nt); break } t && de && Te.alternate === null && n(D, de), A = m(Te, A, ye), ue === null ? le = Te : ue.sibling = Te, ue = Te, de = nt } if (ye === _.length) return o(D, de), Le && lr(D, ye), le; if (de === null) { for (; ye < _.length; ye++)de = H(D, _[ye], Y), de !== null && (A = m(de, A, ye), ue === null ? le = de : ue.sibling = de, ue = de); return Le && lr(D, ye), le } for (de = l(D, de); ye < _.length; ye++)nt = Q(de, D, ye, _[ye], Y), nt !== null && (t && nt.alternate !== null && de.delete(nt.key === null ? ye : nt.key), A = m(nt, A, ye), ue === null ? le = nt : ue.sibling = nt, ue = nt); return t && de.forEach(function (Hn) { return n(D, Hn) }), Le && lr(D, ye), le } function re(D, A, _, Y) { var le = X(_); if (typeof le != "function") throw Error(i(150)); if (_ = le.call(_), _ == null) throw Error(i(151)); for (var ue = le = null, de = A, ye = A = 0, nt = null, Te = _.next(); de !== null && !Te.done; ye++, Te = _.next()) { de.index > ye ? (nt = de, de = null) : nt = de.sibling; var Hn = $(D, de, Te.value, Y); if (Hn === null) { de === null && (de = nt); break } t && de && Hn.alternate === null && n(D, de), A = m(Hn, A, ye), ue === null ? le = Hn : ue.sibling = Hn, ue = Hn, de = nt } if (Te.done) return o(D, de), Le && lr(D, ye), le; if (de === null) { for (; !Te.done; ye++, Te = _.next())Te = H(D, Te.value, Y), Te !== null && (A = m(Te, A, ye), ue === null ? le = Te : ue.sibling = Te, ue = Te); return Le && lr(D, ye), le } for (de = l(D, de); !Te.done; ye++, Te = _.next())Te = Q(de, D, ye, Te.value, Y), Te !== null && (t && Te.alternate !== null && de.delete(Te.key === null ? ye : Te.key), A = m(Te, A, ye), ue === null ? le = Te : ue.sibling = Te, ue = Te); return t && de.forEach(function (v1) { return n(D, v1) }), Le && lr(D, ye), le } function He(D, A, _, Y) { if (typeof _ == "object" && _ !== null && _.type === z && _.key === null && (_ = _.props.children), typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case V: e: { for (var le = _.key, ue = A; ue !== null;) { if (ue.key === le) { if (le = _.type, le === z) { if (ue.tag === 7) { o(D, ue.sibling), A = d(ue, _.props.children), A.return = D, D = A; break e } } else if (ue.elementType === le || typeof le == "object" && le !== null && le.$$typeof === se && xp(le) === ue.type) { o(D, ue.sibling), A = d(ue, _.props), A.ref = Xi(D, ue, _), A.return = D, D = A; break e } o(D, ue); break } else n(D, ue); ue = ue.sibling } _.type === z ? (A = gr(_.props.children, D.mode, Y, _.key), A.return = D, D = A) : (Y = zs(_.type, _.key, _.props, null, D.mode, Y), Y.ref = Xi(D, A, _), Y.return = D, D = Y) } return x(D); case B: e: { for (ue = _.key; A !== null;) { if (A.key === ue) if (A.tag === 4 && A.stateNode.containerInfo === _.containerInfo && A.stateNode.implementation === _.implementation) { o(D, A.sibling), A = d(A, _.children || []), A.return = D, D = A; break e } else { o(D, A); break } else n(D, A); A = A.sibling } A = jc(_, D.mode, Y), A.return = D, D = A } return x(D); case se: return ue = _._init, He(D, A, ue(_._payload), Y) }if (bi(_)) return ee(D, A, _, Y); if (X(_)) return re(D, A, _, Y); gs(D, _) } return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _, A !== null && A.tag === 6 ? (o(D, A.sibling), A = d(A, _), A.return = D, D = A) : (o(D, A), A = Tc(_, D.mode, Y), A.return = D, D = A), x(D)) : o(D, A) } return He } var Kr = wp(!0), Sp = wp(!1), ys = Dn(null), vs = null, Gr = null, Vl = null; function Fl() { Vl = Gr = vs = null } function zl(t) { var n = ys.current; _e(ys), t._currentValue = n } function Bl(t, n, o) { for (; t !== null;) { var l = t.alternate; if ((t.childLanes & n) !== n ? (t.childLanes |= n, l !== null && (l.childLanes |= n)) : l !== null && (l.childLanes & n) !== n && (l.childLanes |= n), t === o) break; t = t.return } } function Yr(t, n) { vs = t, Vl = Gr = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & n) !== 0 && (vt = !0), t.firstContext = null) } function Mt(t) { var n = t._currentValue; if (Vl !== t) if (t = { context: t, memoizedValue: n, next: null }, Gr === null) { if (vs === null) throw Error(i(308)); Gr = t, vs.dependencies = { lanes: 0, firstContext: t } } else Gr = Gr.next = t; return n } var cr = null; function Wl(t) { cr === null ? cr = [t] : cr.push(t) } function Cp(t, n, o, l) { var d = n.interleaved; return d === null ? (o.next = o, Wl(n)) : (o.next = d.next, d.next = o), n.interleaved = o, yn(t, l) } function yn(t, n) { t.lanes |= n; var o = t.alternate; for (o !== null && (o.lanes |= n), o = t, t = t.return; t !== null;)t.childLanes |= n, o = t.alternate, o !== null && (o.childLanes |= n), o = t, t = t.return; return o.tag === 3 ? o.stateNode : null } var On = !1; function $l(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function kp(t, n) { t = t.updateQueue, n.updateQueue === t && (n.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function vn(t, n) { return { eventTime: t, lane: n, tag: 0, payload: null, callback: null, next: null } } function Vn(t, n, o) { var l = t.updateQueue; if (l === null) return null; if (l = l.shared, (Ee & 2) !== 0) { var d = l.pending; return d === null ? n.next = n : (n.next = d.next, d.next = n), l.pending = n, yn(t, o) } return d = l.interleaved, d === null ? (n.next = n, Wl(l)) : (n.next = d.next, d.next = n), l.interleaved = n, yn(t, o) } function xs(t, n, o) { if (n = n.updateQueue, n !== null && (n = n.shared, (o & 4194240) !== 0)) { var l = n.lanes; l &= t.pendingLanes, o |= l, n.lanes = o, rl(t, o) } } function bp(t, n) { var o = t.updateQueue, l = t.alternate; if (l !== null && (l = l.updateQueue, o === l)) { var d = null, m = null; if (o = o.firstBaseUpdate, o !== null) { do { var x = { eventTime: o.eventTime, lane: o.lane, tag: o.tag, payload: o.payload, callback: o.callback, next: null }; m === null ? d = m = x : m = m.next = x, o = o.next } while (o !== null); m === null ? d = m = n : m = m.next = n } else d = m = n; o = { baseState: l.baseState, firstBaseUpdate: d, lastBaseUpdate: m, shared: l.shared, effects: l.effects }, t.updateQueue = o; return } t = o.lastBaseUpdate, t === null ? o.firstBaseUpdate = n : t.next = n, o.lastBaseUpdate = n } function ws(t, n, o, l) { var d = t.updateQueue; On = !1; var m = d.firstBaseUpdate, x = d.lastBaseUpdate, b = d.shared.pending; if (b !== null) { d.shared.pending = null; var T = b, L = T.next; T.next = null, x === null ? m = L : x.next = L, x = T; var U = t.alternate; U !== null && (U = U.updateQueue, b = U.lastBaseUpdate, b !== x && (b === null ? U.firstBaseUpdate = L : b.next = L, U.lastBaseUpdate = T)) } if (m !== null) { var H = d.baseState; x = 0, U = L = T = null, b = m; do { var $ = b.lane, Q = b.eventTime; if ((l & $) === $) { U !== null && (U = U.next = { eventTime: Q, lane: 0, tag: b.tag, payload: b.payload, callback: b.callback, next: null }); e: { var ee = t, re = b; switch ($ = n, Q = o, re.tag) { case 1: if (ee = re.payload, typeof ee == "function") { H = ee.call(Q, H, $); break e } H = ee; break e; case 3: ee.flags = ee.flags & -65537 | 128; case 0: if (ee = re.payload, $ = typeof ee == "function" ? ee.call(Q, H, $) : ee, $ == null) break e; H = G({}, H, $); break e; case 2: On = !0 } } b.callback !== null && b.lane !== 0 && (t.flags |= 64, $ = d.effects, $ === null ? d.effects = [b] : $.push(b)) } else Q = { eventTime: Q, lane: $, tag: b.tag, payload: b.payload, callback: b.callback, next: null }, U === null ? (L = U = Q, T = H) : U = U.next = Q, x |= $; if (b = b.next, b === null) { if (b = d.shared.pending, b === null) break; $ = b, b = $.next, $.next = null, d.lastBaseUpdate = $, d.shared.pending = null } } while (!0); if (U === null && (T = H), d.baseState = T, d.firstBaseUpdate = L, d.lastBaseUpdate = U, n = d.shared.interleaved, n !== null) { d = n; do x |= d.lane, d = d.next; while (d !== n) } else m === null && (d.shared.lanes = 0); fr |= x, t.lanes = x, t.memoizedState = H } } function Np(t, n, o) { if (t = n.effects, n.effects = null, t !== null) for (n = 0; n < t.length; n++) { var l = t[n], d = l.callback; if (d !== null) { if (l.callback = null, l = o, typeof d != "function") throw Error(i(191, d)); d.call(l) } } } var qi = {}, nn = Dn(qi), Qi = Dn(qi), Zi = Dn(qi); function ur(t) { if (t === qi) throw Error(i(174)); return t } function Ul(t, n) { switch (Me(Zi, n), Me(Qi, t), Me(nn, qi), t = n.nodeType, t) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : Ha(null, ""); break; default: t = t === 8 ? n.parentNode : n, n = t.namespaceURI || null, t = t.tagName, n = Ha(n, t) }_e(nn), Me(nn, n) } function Xr() { _e(nn), _e(Qi), _e(Zi) } function Pp(t) { ur(Zi.current); var n = ur(nn.current), o = Ha(n, t.type); n !== o && (Me(Qi, t), Me(nn, o)) } function Hl(t) { Qi.current === t && (_e(nn), _e(Qi)) } var Ve = Dn(0); function Ss(t) { for (var n = t; n !== null;) { if (n.tag === 13) { var o = n.memoizedState; if (o !== null && (o = o.dehydrated, o === null || o.data === "$?" || o.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if ((n.flags & 128) !== 0) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var Kl = []; function Gl() { for (var t = 0; t < Kl.length; t++)Kl[t]._workInProgressVersionPrimary = null; Kl.length = 0 } var Cs = O.ReactCurrentDispatcher, Yl = O.ReactCurrentBatchConfig, dr = 0, Fe = null, qe = null, et = null, ks = !1, Ji = !1, eo = 0, zw = 0; function ct() { throw Error(i(321)) } function Xl(t, n) { if (n === null) return !1; for (var o = 0; o < n.length && o < t.length; o++)if (!Wt(t[o], n[o])) return !1; return !0 } function ql(t, n, o, l, d, m) { if (dr = m, Fe = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, Cs.current = t === null || t.memoizedState === null ? Uw : Hw, t = o(l, d), Ji) { m = 0; do { if (Ji = !1, eo = 0, 25 <= m) throw Error(i(301)); m += 1, et = qe = null, n.updateQueue = null, Cs.current = Kw, t = o(l, d) } while (Ji) } if (Cs.current = Ps, n = qe !== null && qe.next !== null, dr = 0, et = qe = Fe = null, ks = !1, n) throw Error(i(300)); return t } function Ql() { var t = eo !== 0; return eo = 0, t } function rn() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return et === null ? Fe.memoizedState = et = t : et = et.next = t, et } function It() { if (qe === null) { var t = Fe.alternate; t = t !== null ? t.memoizedState : null } else t = qe.next; var n = et === null ? Fe.memoizedState : et.next; if (n !== null) et = n, qe = t; else { if (t === null) throw Error(i(310)); qe = t, t = { memoizedState: qe.memoizedState, baseState: qe.baseState, baseQueue: qe.baseQueue, queue: qe.queue, next: null }, et === null ? Fe.memoizedState = et = t : et = et.next = t } return et } function to(t, n) { return typeof n == "function" ? n(t) : n } function Zl(t) { var n = It(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = t; var l = qe, d = l.baseQueue, m = o.pending; if (m !== null) { if (d !== null) { var x = d.next; d.next = m.next, m.next = x } l.baseQueue = d = m, o.pending = null } if (d !== null) { m = d.next, l = l.baseState; var b = x = null, T = null, L = m; do { var U = L.lane; if ((dr & U) === U) T !== null && (T = T.next = { lane: 0, action: L.action, hasEagerState: L.hasEagerState, eagerState: L.eagerState, next: null }), l = L.hasEagerState ? L.eagerState : t(l, L.action); else { var H = { lane: U, action: L.action, hasEagerState: L.hasEagerState, eagerState: L.eagerState, next: null }; T === null ? (b = T = H, x = l) : T = T.next = H, Fe.lanes |= U, fr |= U } L = L.next } while (L !== null && L !== m); T === null ? x = l : T.next = b, Wt(l, n.memoizedState) || (vt = !0), n.memoizedState = l, n.baseState = x, n.baseQueue = T, o.lastRenderedState = l } if (t = o.interleaved, t !== null) { d = t; do m = d.lane, Fe.lanes |= m, fr |= m, d = d.next; while (d !== t) } else d === null && (o.lanes = 0); return [n.memoizedState, o.dispatch] } function Jl(t) { var n = It(), o = n.queue; if (o === null) throw Error(i(311)); o.lastRenderedReducer = t; var l = o.dispatch, d = o.pending, m = n.memoizedState; if (d !== null) { o.pending = null; var x = d = d.next; do m = t(m, x.action), x = x.next; while (x !== d); Wt(m, n.memoizedState) || (vt = !0), n.memoizedState = m, n.baseQueue === null && (n.baseState = m), o.lastRenderedState = m } return [m, l] } function Ep() { } function Tp(t, n) { var o = Fe, l = It(), d = n(), m = !Wt(l.memoizedState, d); if (m && (l.memoizedState = d, vt = !0), l = l.queue, ec(Rp.bind(null, o, l, t), [t]), l.getSnapshot !== n || m || et !== null && et.memoizedState.tag & 1) { if (o.flags |= 2048, no(9, Ap.bind(null, o, l, d, n), void 0, null), tt === null) throw Error(i(349)); (dr & 30) !== 0 || jp(o, n, d) } return d } function jp(t, n, o) { t.flags |= 16384, t = { getSnapshot: n, value: o }, n = Fe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Fe.updateQueue = n, n.stores = [t]) : (o = n.stores, o === null ? n.stores = [t] : o.push(t)) } function Ap(t, n, o, l) { n.value = o, n.getSnapshot = l, Mp(n) && Ip(t) } function Rp(t, n, o) { return o(function () { Mp(n) && Ip(t) }) } function Mp(t) { var n = t.getSnapshot; t = t.value; try { var o = n(); return !Wt(t, o) } catch { return !0 } } function Ip(t) { var n = yn(t, 1); n !== null && Gt(n, t, 1, -1) } function Dp(t) { var n = rn(); return typeof t == "function" && (t = t()), n.memoizedState = n.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: to, lastRenderedState: t }, n.queue = t, t = t.dispatch = $w.bind(null, Fe, t), [n.memoizedState, t] } function no(t, n, o, l) { return t = { tag: t, create: n, destroy: o, deps: l, next: null }, n = Fe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, Fe.updateQueue = n, n.lastEffect = t.next = t) : (o = n.lastEffect, o === null ? n.lastEffect = t.next = t : (l = o.next, o.next = t, t.next = l, n.lastEffect = t)), t } function _p() { return It().memoizedState } function bs(t, n, o, l) { var d = rn(); Fe.flags |= t, d.memoizedState = no(1 | n, o, void 0, l === void 0 ? null : l) } function Ns(t, n, o, l) { var d = It(); l = l === void 0 ? null : l; var m = void 0; if (qe !== null) { var x = qe.memoizedState; if (m = x.destroy, l !== null && Xl(l, x.deps)) { d.memoizedState = no(n, o, m, l); return } } Fe.flags |= t, d.memoizedState = no(1 | n, o, m, l) } function Lp(t, n) { return bs(8390656, 8, t, n) } function ec(t, n) { return Ns(2048, 8, t, n) } function Op(t, n) { return Ns(4, 2, t, n) } function Vp(t, n) { return Ns(4, 4, t, n) } function Fp(t, n) { if (typeof n == "function") return t = t(), n(t), function () { n(null) }; if (n != null) return t = t(), n.current = t, function () { n.current = null } } function zp(t, n, o) { return o = o != null ? o.concat([t]) : null, Ns(4, 4, Fp.bind(null, n, t), o) } function tc() { } function Bp(t, n) { var o = It(); n = n === void 0 ? null : n; var l = o.memoizedState; return l !== null && n !== null && Xl(n, l[1]) ? l[0] : (o.memoizedState = [t, n], t) } function Wp(t, n) { var o = It(); n = n === void 0 ? null : n; var l = o.memoizedState; return l !== null && n !== null && Xl(n, l[1]) ? l[0] : (t = t(), o.memoizedState = [t, n], t) } function $p(t, n, o) { return (dr & 21) === 0 ? (t.baseState && (t.baseState = !1, vt = !0), t.memoizedState = o) : (Wt(o, n) || (o = xf(), Fe.lanes |= o, fr |= o, t.baseState = !0), n) } function Bw(t, n) { var o = Ae; Ae = o !== 0 && 4 > o ? o : 4, t(!0); var l = Yl.transition; Yl.transition = {}; try { t(!1), n() } finally { Ae = o, Yl.transition = l } } function Up() { return It().memoizedState } function Ww(t, n, o) { var l = Wn(t); if (o = { lane: l, action: o, hasEagerState: !1, eagerState: null, next: null }, Hp(t)) Kp(n, o); else if (o = Cp(t, n, o, l), o !== null) { var d = ht(); Gt(o, t, l, d), Gp(o, n, l) } } function $w(t, n, o) { var l = Wn(t), d = { lane: l, action: o, hasEagerState: !1, eagerState: null, next: null }; if (Hp(t)) Kp(n, d); else { var m = t.alternate; if (t.lanes === 0 && (m === null || m.lanes === 0) && (m = n.lastRenderedReducer, m !== null)) try { var x = n.lastRenderedState, b = m(x, o); if (d.hasEagerState = !0, d.eagerState = b, Wt(b, x)) { var T = n.interleaved; T === null ? (d.next = d, Wl(n)) : (d.next = T.next, T.next = d), n.interleaved = d; return } } catch { } finally { } o = Cp(t, n, d, l), o !== null && (d = ht(), Gt(o, t, l, d), Gp(o, n, l)) } } function Hp(t) { var n = t.alternate; return t === Fe || n !== null && n === Fe } function Kp(t, n) { Ji = ks = !0; var o = t.pending; o === null ? n.next = n : (n.next = o.next, o.next = n), t.pending = n } function Gp(t, n, o) { if ((o & 4194240) !== 0) { var l = n.lanes; l &= t.pendingLanes, o |= l, n.lanes = o, rl(t, o) } } var Ps = { readContext: Mt, useCallback: ct, useContext: ct, useEffect: ct, useImperativeHandle: ct, useInsertionEffect: ct, useLayoutEffect: ct, useMemo: ct, useReducer: ct, useRef: ct, useState: ct, useDebugValue: ct, useDeferredValue: ct, useTransition: ct, useMutableSource: ct, useSyncExternalStore: ct, useId: ct, unstable_isNewReconciler: !1 }, Uw = { readContext: Mt, useCallback: function (t, n) { return rn().memoizedState = [t, n === void 0 ? null : n], t }, useContext: Mt, useEffect: Lp, useImperativeHandle: function (t, n, o) { return o = o != null ? o.concat([t]) : null, bs(4194308, 4, Fp.bind(null, n, t), o) }, useLayoutEffect: function (t, n) { return bs(4194308, 4, t, n) }, useInsertionEffect: function (t, n) { return bs(4, 2, t, n) }, useMemo: function (t, n) { var o = rn(); return n = n === void 0 ? null : n, t = t(), o.memoizedState = [t, n], t }, useReducer: function (t, n, o) { var l = rn(); return n = o !== void 0 ? o(n) : n, l.memoizedState = l.baseState = n, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: n }, l.queue = t, t = t.dispatch = Ww.bind(null, Fe, t), [l.memoizedState, t] }, useRef: function (t) { var n = rn(); return t = { current: t }, n.memoizedState = t }, useState: Dp, useDebugValue: tc, useDeferredValue: function (t) { return rn().memoizedState = t }, useTransition: function () { var t = Dp(!1), n = t[0]; return t = Bw.bind(null, t[1]), rn().memoizedState = t, [n, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, n, o) { var l = Fe, d = rn(); if (Le) { if (o === void 0) throw Error(i(407)); o = o() } else { if (o = n(), tt === null) throw Error(i(349)); (dr & 30) !== 0 || jp(l, n, o) } d.memoizedState = o; var m = { value: o, getSnapshot: n }; return d.queue = m, Lp(Rp.bind(null, l, m, t), [t]), l.flags |= 2048, no(9, Ap.bind(null, l, m, o, n), void 0, null), o }, useId: function () { var t = rn(), n = tt.identifierPrefix; if (Le) { var o = gn, l = mn; o = (l & ~(1 << 32 - Bt(l) - 1)).toString(32) + o, n = ":" + n + "R" + o, o = eo++, 0 < o && (n += "H" + o.toString(32)), n += ":" } else o = zw++, n = ":" + n + "r" + o.toString(32) + ":"; return t.memoizedState = n }, unstable_isNewReconciler: !1 }, Hw = { readContext: Mt, useCallback: Bp, useContext: Mt, useEffect: ec, useImperativeHandle: zp, useInsertionEffect: Op, useLayoutEffect: Vp, useMemo: Wp, useReducer: Zl, useRef: _p, useState: function () { return Zl(to) }, useDebugValue: tc, useDeferredValue: function (t) { var n = It(); return $p(n, qe.memoizedState, t) }, useTransition: function () { var t = Zl(to)[0], n = It().memoizedState; return [t, n] }, useMutableSource: Ep, useSyncExternalStore: Tp, useId: Up, unstable_isNewReconciler: !1 }, Kw = { readContext: Mt, useCallback: Bp, useContext: Mt, useEffect: ec, useImperativeHandle: zp, useInsertionEffect: Op, useLayoutEffect: Vp, useMemo: Wp, useReducer: Jl, useRef: _p, useState: function () { return Jl(to) }, useDebugValue: tc, useDeferredValue: function (t) { var n = It(); return qe === null ? n.memoizedState = t : $p(n, qe.memoizedState, t) }, useTransition: function () { var t = Jl(to)[0], n = It().memoizedState; return [t, n] }, useMutableSource: Ep, useSyncExternalStore: Tp, useId: Up, unstable_isNewReconciler: !1 }; function Ut(t, n) { if (t && t.defaultProps) { n = G({}, n), t = t.defaultProps; for (var o in t) n[o] === void 0 && (n[o] = t[o]); return n } return n } function nc(t, n, o, l) { n = t.memoizedState, o = o(l, n), o = o == null ? n : G({}, n, o), t.memoizedState = o, t.lanes === 0 && (t.updateQueue.baseState = o) } var Es = { isMounted: function (t) { return (t = t._reactInternals) ? ir(t) === t : !1 }, enqueueSetState: function (t, n, o) { t = t._reactInternals; var l = ht(), d = Wn(t), m = vn(l, d); m.payload = n, o != null && (m.callback = o), n = Vn(t, m, d), n !== null && (Gt(n, t, d, l), xs(n, t, d)) }, enqueueReplaceState: function (t, n, o) { t = t._reactInternals; var l = ht(), d = Wn(t), m = vn(l, d); m.tag = 1, m.payload = n, o != null && (m.callback = o), n = Vn(t, m, d), n !== null && (Gt(n, t, d, l), xs(n, t, d)) }, enqueueForceUpdate: function (t, n) { t = t._reactInternals; var o = ht(), l = Wn(t), d = vn(o, l); d.tag = 2, n != null && (d.callback = n), n = Vn(t, d, l), n !== null && (Gt(n, t, l, o), xs(n, t, l)) } }; function Yp(t, n, o, l, d, m, x) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(l, m, x) : n.prototype && n.prototype.isPureReactComponent ? !Wi(o, l) || !Wi(d, m) : !0 } function Xp(t, n, o) { var l = !1, d = _n, m = n.contextType; return typeof m == "object" && m !== null ? m = Mt(m) : (d = yt(n) ? sr : lt.current, l = n.contextTypes, m = (l = l != null) ? Wr(t, d) : _n), n = new n(o, m), t.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = Es, t.stateNode = n, n._reactInternals = t, l && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = d, t.__reactInternalMemoizedMaskedChildContext = m), n } function qp(t, n, o, l) { t = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(o, l), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(o, l), n.state !== t && Es.enqueueReplaceState(n, n.state, null) } function rc(t, n, o, l) { var d = t.stateNode; d.props = o, d.state = t.memoizedState, d.refs = {}, $l(t); var m = n.contextType; typeof m == "object" && m !== null ? d.context = Mt(m) : (m = yt(n) ? sr : lt.current, d.context = Wr(t, m)), d.state = t.memoizedState, m = n.getDerivedStateFromProps, typeof m == "function" && (nc(t, n, m, o), d.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof d.getSnapshotBeforeUpdate == "function" || typeof d.UNSAFE_componentWillMount != "function" && typeof d.componentWillMount != "function" || (n = d.state, typeof d.componentWillMount == "function" && d.componentWillMount(), typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), n !== d.state && Es.enqueueReplaceState(d, d.state, null), ws(t, o, d, l), d.state = t.memoizedState), typeof d.componentDidMount == "function" && (t.flags |= 4194308) } function qr(t, n) {
    try { var o = "", l = n; do o += we(l), l = l.return; while (l); var d = o } catch (m) {
      d = `
Error generating stack: `+ m.message + `
`+ m.stack
    } return { value: t, source: n, stack: d, digest: null }
  } function ic(t, n, o) { return { value: t, source: null, stack: o ?? null, digest: n ?? null } } function oc(t, n) { try { console.error(n.value) } catch (o) { setTimeout(function () { throw o }) } } var Gw = typeof WeakMap == "function" ? WeakMap : Map; function Qp(t, n, o) { o = vn(-1, o), o.tag = 3, o.payload = { element: null }; var l = n.value; return o.callback = function () { Ds || (Ds = !0, wc = l), oc(t, n) }, o } function Zp(t, n, o) { o = vn(-1, o), o.tag = 3; var l = t.type.getDerivedStateFromError; if (typeof l == "function") { var d = n.value; o.payload = function () { return l(d) }, o.callback = function () { oc(t, n) } } var m = t.stateNode; return m !== null && typeof m.componentDidCatch == "function" && (o.callback = function () { oc(t, n), typeof l != "function" && (zn === null ? zn = new Set([this]) : zn.add(this)); var x = n.stack; this.componentDidCatch(n.value, { componentStack: x !== null ? x : "" }) }), o } function Jp(t, n, o) { var l = t.pingCache; if (l === null) { l = t.pingCache = new Gw; var d = new Set; l.set(n, d) } else d = l.get(n), d === void 0 && (d = new Set, l.set(n, d)); d.has(o) || (d.add(o), t = a1.bind(null, t, n, o), n.then(t, t)) } function eh(t) { do { var n; if ((n = t.tag === 13) && (n = t.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return t; t = t.return } while (t !== null); return null } function th(t, n, o, l, d) { return (t.mode & 1) === 0 ? (t === n ? t.flags |= 65536 : (t.flags |= 128, o.flags |= 131072, o.flags &= -52805, o.tag === 1 && (o.alternate === null ? o.tag = 17 : (n = vn(-1, 1), n.tag = 2, Vn(o, n, 1))), o.lanes |= 1), t) : (t.flags |= 65536, t.lanes = d, t) } var Yw = O.ReactCurrentOwner, vt = !1; function pt(t, n, o, l) { n.child = t === null ? Sp(n, null, o, l) : Kr(n, t.child, o, l) } function nh(t, n, o, l, d) { o = o.render; var m = n.ref; return Yr(n, d), l = ql(t, n, o, l, m, d), o = Ql(), t !== null && !vt ? (n.updateQueue = t.updateQueue, n.flags &= -2053, t.lanes &= ~d, xn(t, n, d)) : (Le && o && Il(n), n.flags |= 1, pt(t, n, l, d), n.child) } function rh(t, n, o, l, d) { if (t === null) { var m = o.type; return typeof m == "function" && !Ec(m) && m.defaultProps === void 0 && o.compare === null && o.defaultProps === void 0 ? (n.tag = 15, n.type = m, ih(t, n, m, l, d)) : (t = zs(o.type, null, l, n, n.mode, d), t.ref = n.ref, t.return = n, n.child = t) } if (m = t.child, (t.lanes & d) === 0) { var x = m.memoizedProps; if (o = o.compare, o = o !== null ? o : Wi, o(x, l) && t.ref === n.ref) return xn(t, n, d) } return n.flags |= 1, t = Un(m, l), t.ref = n.ref, t.return = n, n.child = t } function ih(t, n, o, l, d) { if (t !== null) { var m = t.memoizedProps; if (Wi(m, l) && t.ref === n.ref) if (vt = !1, n.pendingProps = l = m, (t.lanes & d) !== 0) (t.flags & 131072) !== 0 && (vt = !0); else return n.lanes = t.lanes, xn(t, n, d) } return sc(t, n, o, l, d) } function oh(t, n, o) { var l = n.pendingProps, d = l.children, m = t !== null ? t.memoizedState : null; if (l.mode === "hidden") if ((n.mode & 1) === 0) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Me(Zr, Pt), Pt |= o; else { if ((o & 1073741824) === 0) return t = m !== null ? m.baseLanes | o : o, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, n.updateQueue = null, Me(Zr, Pt), Pt |= t, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, l = m !== null ? m.baseLanes : o, Me(Zr, Pt), Pt |= l } else m !== null ? (l = m.baseLanes | o, n.memoizedState = null) : l = o, Me(Zr, Pt), Pt |= l; return pt(t, n, d, o), n.child } function sh(t, n) { var o = n.ref; (t === null && o !== null || t !== null && t.ref !== o) && (n.flags |= 512, n.flags |= 2097152) } function sc(t, n, o, l, d) { var m = yt(o) ? sr : lt.current; return m = Wr(n, m), Yr(n, d), o = ql(t, n, o, l, m, d), l = Ql(), t !== null && !vt ? (n.updateQueue = t.updateQueue, n.flags &= -2053, t.lanes &= ~d, xn(t, n, d)) : (Le && l && Il(n), n.flags |= 1, pt(t, n, o, d), n.child) } function ah(t, n, o, l, d) { if (yt(o)) { var m = !0; ds(n) } else m = !1; if (Yr(n, d), n.stateNode === null) js(t, n), Xp(n, o, l), rc(n, o, l, d), l = !0; else if (t === null) { var x = n.stateNode, b = n.memoizedProps; x.props = b; var T = x.context, L = o.contextType; typeof L == "object" && L !== null ? L = Mt(L) : (L = yt(o) ? sr : lt.current, L = Wr(n, L)); var U = o.getDerivedStateFromProps, H = typeof U == "function" || typeof x.getSnapshotBeforeUpdate == "function"; H || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (b !== l || T !== L) && qp(n, x, l, L), On = !1; var $ = n.memoizedState; x.state = $, ws(n, l, x, d), T = n.memoizedState, b !== l || $ !== T || gt.current || On ? (typeof U == "function" && (nc(n, o, U, l), T = n.memoizedState), (b = On || Yp(n, o, b, l, $, T, L)) ? (H || typeof x.UNSAFE_componentWillMount != "function" && typeof x.componentWillMount != "function" || (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof x.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = l, n.memoizedState = T), x.props = l, x.state = T, x.context = L, l = b) : (typeof x.componentDidMount == "function" && (n.flags |= 4194308), l = !1) } else { x = n.stateNode, kp(t, n), b = n.memoizedProps, L = n.type === n.elementType ? b : Ut(n.type, b), x.props = L, H = n.pendingProps, $ = x.context, T = o.contextType, typeof T == "object" && T !== null ? T = Mt(T) : (T = yt(o) ? sr : lt.current, T = Wr(n, T)); var Q = o.getDerivedStateFromProps; (U = typeof Q == "function" || typeof x.getSnapshotBeforeUpdate == "function") || typeof x.UNSAFE_componentWillReceiveProps != "function" && typeof x.componentWillReceiveProps != "function" || (b !== H || $ !== T) && qp(n, x, l, T), On = !1, $ = n.memoizedState, x.state = $, ws(n, l, x, d); var ee = n.memoizedState; b !== H || $ !== ee || gt.current || On ? (typeof Q == "function" && (nc(n, o, Q, l), ee = n.memoizedState), (L = On || Yp(n, o, L, l, $, ee, T) || !1) ? (U || typeof x.UNSAFE_componentWillUpdate != "function" && typeof x.componentWillUpdate != "function" || (typeof x.componentWillUpdate == "function" && x.componentWillUpdate(l, ee, T), typeof x.UNSAFE_componentWillUpdate == "function" && x.UNSAFE_componentWillUpdate(l, ee, T)), typeof x.componentDidUpdate == "function" && (n.flags |= 4), typeof x.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof x.componentDidUpdate != "function" || b === t.memoizedProps && $ === t.memoizedState || (n.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || b === t.memoizedProps && $ === t.memoizedState || (n.flags |= 1024), n.memoizedProps = l, n.memoizedState = ee), x.props = l, x.state = ee, x.context = T, l = L) : (typeof x.componentDidUpdate != "function" || b === t.memoizedProps && $ === t.memoizedState || (n.flags |= 4), typeof x.getSnapshotBeforeUpdate != "function" || b === t.memoizedProps && $ === t.memoizedState || (n.flags |= 1024), l = !1) } return ac(t, n, o, l, m, d) } function ac(t, n, o, l, d, m) { sh(t, n); var x = (n.flags & 128) !== 0; if (!l && !x) return d && fp(n, o, !1), xn(t, n, m); l = n.stateNode, Yw.current = n; var b = x && typeof o.getDerivedStateFromError != "function" ? null : l.render(); return n.flags |= 1, t !== null && x ? (n.child = Kr(n, t.child, null, m), n.child = Kr(n, null, b, m)) : pt(t, n, b, m), n.memoizedState = l.state, d && fp(n, o, !0), n.child } function lh(t) { var n = t.stateNode; n.pendingContext ? up(t, n.pendingContext, n.pendingContext !== n.context) : n.context && up(t, n.context, !1), Ul(t, n.containerInfo) } function ch(t, n, o, l, d) { return Hr(), Ol(d), n.flags |= 256, pt(t, n, o, l), n.child } var lc = { dehydrated: null, treeContext: null, retryLane: 0 }; function cc(t) { return { baseLanes: t, cachePool: null, transitions: null } } function uh(t, n, o) { var l = n.pendingProps, d = Ve.current, m = !1, x = (n.flags & 128) !== 0, b; if ((b = x) || (b = t !== null && t.memoizedState === null ? !1 : (d & 2) !== 0), b ? (m = !0, n.flags &= -129) : (t === null || t.memoizedState !== null) && (d |= 1), Me(Ve, d & 1), t === null) return Ll(n), t = n.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((n.mode & 1) === 0 ? n.lanes = 1 : t.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824, null) : (x = l.children, t = l.fallback, m ? (l = n.mode, m = n.child, x = { mode: "hidden", children: x }, (l & 1) === 0 && m !== null ? (m.childLanes = 0, m.pendingProps = x) : m = Bs(x, l, 0, null), t = gr(t, l, o, null), m.return = n, t.return = n, m.sibling = t, n.child = m, n.child.memoizedState = cc(o), n.memoizedState = lc, t) : uc(n, x)); if (d = t.memoizedState, d !== null && (b = d.dehydrated, b !== null)) return Xw(t, n, x, l, b, d, o); if (m) { m = l.fallback, x = n.mode, d = t.child, b = d.sibling; var T = { mode: "hidden", children: l.children }; return (x & 1) === 0 && n.child !== d ? (l = n.child, l.childLanes = 0, l.pendingProps = T, n.deletions = null) : (l = Un(d, T), l.subtreeFlags = d.subtreeFlags & 14680064), b !== null ? m = Un(b, m) : (m = gr(m, x, o, null), m.flags |= 2), m.return = n, l.return = n, l.sibling = m, n.child = l, l = m, m = n.child, x = t.child.memoizedState, x = x === null ? cc(o) : { baseLanes: x.baseLanes | o, cachePool: null, transitions: x.transitions }, m.memoizedState = x, m.childLanes = t.childLanes & ~o, n.memoizedState = lc, l } return m = t.child, t = m.sibling, l = Un(m, { mode: "visible", children: l.children }), (n.mode & 1) === 0 && (l.lanes = o), l.return = n, l.sibling = null, t !== null && (o = n.deletions, o === null ? (n.deletions = [t], n.flags |= 16) : o.push(t)), n.child = l, n.memoizedState = null, l } function uc(t, n) { return n = Bs({ mode: "visible", children: n }, t.mode, 0, null), n.return = t, t.child = n } function Ts(t, n, o, l) { return l !== null && Ol(l), Kr(n, t.child, null, o), t = uc(n, n.pendingProps.children), t.flags |= 2, n.memoizedState = null, t } function Xw(t, n, o, l, d, m, x) { if (o) return n.flags & 256 ? (n.flags &= -257, l = ic(Error(i(422))), Ts(t, n, x, l)) : n.memoizedState !== null ? (n.child = t.child, n.flags |= 128, null) : (m = l.fallback, d = n.mode, l = Bs({ mode: "visible", children: l.children }, d, 0, null), m = gr(m, d, x, null), m.flags |= 2, l.return = n, m.return = n, l.sibling = m, n.child = l, (n.mode & 1) !== 0 && Kr(n, t.child, null, x), n.child.memoizedState = cc(x), n.memoizedState = lc, m); if ((n.mode & 1) === 0) return Ts(t, n, x, null); if (d.data === "$!") { if (l = d.nextSibling && d.nextSibling.dataset, l) var b = l.dgst; return l = b, m = Error(i(419)), l = ic(m, l, void 0), Ts(t, n, x, l) } if (b = (x & t.childLanes) !== 0, vt || b) { if (l = tt, l !== null) { switch (x & -x) { case 4: d = 2; break; case 16: d = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: d = 32; break; case 536870912: d = 268435456; break; default: d = 0 }d = (d & (l.suspendedLanes | x)) !== 0 ? 0 : d, d !== 0 && d !== m.retryLane && (m.retryLane = d, yn(t, d), Gt(l, t, d, -1)) } return Pc(), l = ic(Error(i(421))), Ts(t, n, x, l) } return d.data === "$?" ? (n.flags |= 128, n.child = t.child, n = l1.bind(null, t), d._reactRetry = n, null) : (t = m.treeContext, Nt = In(d.nextSibling), bt = n, Le = !0, $t = null, t !== null && (At[Rt++] = mn, At[Rt++] = gn, At[Rt++] = ar, mn = t.id, gn = t.overflow, ar = n), n = uc(n, l.children), n.flags |= 4096, n) } function dh(t, n, o) { t.lanes |= n; var l = t.alternate; l !== null && (l.lanes |= n), Bl(t.return, n, o) } function dc(t, n, o, l, d) { var m = t.memoizedState; m === null ? t.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: l, tail: o, tailMode: d } : (m.isBackwards = n, m.rendering = null, m.renderingStartTime = 0, m.last = l, m.tail = o, m.tailMode = d) } function fh(t, n, o) { var l = n.pendingProps, d = l.revealOrder, m = l.tail; if (pt(t, n, l.children, o), l = Ve.current, (l & 2) !== 0) l = l & 1 | 2, n.flags |= 128; else { if (t !== null && (t.flags & 128) !== 0) e: for (t = n.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && dh(t, o, n); else if (t.tag === 19) dh(t, o, n); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === n) break e; for (; t.sibling === null;) { if (t.return === null || t.return === n) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } l &= 1 } if (Me(Ve, l), (n.mode & 1) === 0) n.memoizedState = null; else switch (d) { case "forwards": for (o = n.child, d = null; o !== null;)t = o.alternate, t !== null && Ss(t) === null && (d = o), o = o.sibling; o = d, o === null ? (d = n.child, n.child = null) : (d = o.sibling, o.sibling = null), dc(n, !1, d, o, m); break; case "backwards": for (o = null, d = n.child, n.child = null; d !== null;) { if (t = d.alternate, t !== null && Ss(t) === null) { n.child = d; break } t = d.sibling, d.sibling = o, o = d, d = t } dc(n, !0, o, null, m); break; case "together": dc(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function js(t, n) { (n.mode & 1) === 0 && t !== null && (t.alternate = null, n.alternate = null, n.flags |= 2) } function xn(t, n, o) { if (t !== null && (n.dependencies = t.dependencies), fr |= n.lanes, (o & n.childLanes) === 0) return null; if (t !== null && n.child !== t.child) throw Error(i(153)); if (n.child !== null) { for (t = n.child, o = Un(t, t.pendingProps), n.child = o, o.return = n; t.sibling !== null;)t = t.sibling, o = o.sibling = Un(t, t.pendingProps), o.return = n; o.sibling = null } return n.child } function qw(t, n, o) { switch (n.tag) { case 3: lh(n), Hr(); break; case 5: Pp(n); break; case 1: yt(n.type) && ds(n); break; case 4: Ul(n, n.stateNode.containerInfo); break; case 10: var l = n.type._context, d = n.memoizedProps.value; Me(ys, l._currentValue), l._currentValue = d; break; case 13: if (l = n.memoizedState, l !== null) return l.dehydrated !== null ? (Me(Ve, Ve.current & 1), n.flags |= 128, null) : (o & n.child.childLanes) !== 0 ? uh(t, n, o) : (Me(Ve, Ve.current & 1), t = xn(t, n, o), t !== null ? t.sibling : null); Me(Ve, Ve.current & 1); break; case 19: if (l = (o & n.childLanes) !== 0, (t.flags & 128) !== 0) { if (l) return fh(t, n, o); n.flags |= 128 } if (d = n.memoizedState, d !== null && (d.rendering = null, d.tail = null, d.lastEffect = null), Me(Ve, Ve.current), l) break; return null; case 22: case 23: return n.lanes = 0, oh(t, n, o) }return xn(t, n, o) } var ph, fc, hh, mh; ph = function (t, n) { for (var o = n.child; o !== null;) { if (o.tag === 5 || o.tag === 6) t.appendChild(o.stateNode); else if (o.tag !== 4 && o.child !== null) { o.child.return = o, o = o.child; continue } if (o === n) break; for (; o.sibling === null;) { if (o.return === null || o.return === n) return; o = o.return } o.sibling.return = o.return, o = o.sibling } }, fc = function () { }, hh = function (t, n, o, l) { var d = t.memoizedProps; if (d !== l) { t = n.stateNode, ur(nn.current); var m = null; switch (o) { case "input": d = zt(t, d), l = zt(t, l), m = []; break; case "select": d = G({}, d, { value: void 0 }), l = G({}, l, { value: void 0 }), m = []; break; case "textarea": d = Ua(t, d), l = Ua(t, l), m = []; break; default: typeof d.onClick != "function" && typeof l.onClick == "function" && (t.onclick = ls) }Ka(o, l); var x; o = null; for (L in d) if (!l.hasOwnProperty(L) && d.hasOwnProperty(L) && d[L] != null) if (L === "style") { var b = d[L]; for (x in b) b.hasOwnProperty(x) && (o || (o = {}), o[x] = "") } else L !== "dangerouslySetInnerHTML" && L !== "children" && L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && L !== "autoFocus" && (a.hasOwnProperty(L) ? m || (m = []) : (m = m || []).push(L, null)); for (L in l) { var T = l[L]; if (b = d?.[L], l.hasOwnProperty(L) && T !== b && (T != null || b != null)) if (L === "style") if (b) { for (x in b) !b.hasOwnProperty(x) || T && T.hasOwnProperty(x) || (o || (o = {}), o[x] = ""); for (x in T) T.hasOwnProperty(x) && b[x] !== T[x] && (o || (o = {}), o[x] = T[x]) } else o || (m || (m = []), m.push(L, o)), o = T; else L === "dangerouslySetInnerHTML" ? (T = T ? T.__html : void 0, b = b ? b.__html : void 0, T != null && b !== T && (m = m || []).push(L, T)) : L === "children" ? typeof T != "string" && typeof T != "number" || (m = m || []).push(L, "" + T) : L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && (a.hasOwnProperty(L) ? (T != null && L === "onScroll" && De("scroll", t), m || b === T || (m = [])) : (m = m || []).push(L, T)) } o && (m = m || []).push("style", o); var L = m; (n.updateQueue = L) && (n.flags |= 4) } }, mh = function (t, n, o, l) { o !== l && (n.flags |= 4) }; function ro(t, n) { if (!Le) switch (t.tailMode) { case "hidden": n = t.tail; for (var o = null; n !== null;)n.alternate !== null && (o = n), n = n.sibling; o === null ? t.tail = null : o.sibling = null; break; case "collapsed": o = t.tail; for (var l = null; o !== null;)o.alternate !== null && (l = o), o = o.sibling; l === null ? n || t.tail === null ? t.tail = null : t.tail.sibling = null : l.sibling = null } } function ut(t) { var n = t.alternate !== null && t.alternate.child === t.child, o = 0, l = 0; if (n) for (var d = t.child; d !== null;)o |= d.lanes | d.childLanes, l |= d.subtreeFlags & 14680064, l |= d.flags & 14680064, d.return = t, d = d.sibling; else for (d = t.child; d !== null;)o |= d.lanes | d.childLanes, l |= d.subtreeFlags, l |= d.flags, d.return = t, d = d.sibling; return t.subtreeFlags |= l, t.childLanes = o, n } function Qw(t, n, o) { var l = n.pendingProps; switch (Dl(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ut(n), null; case 1: return yt(n.type) && us(), ut(n), null; case 3: return l = n.stateNode, Xr(), _e(gt), _e(lt), Gl(), l.pendingContext && (l.context = l.pendingContext, l.pendingContext = null), (t === null || t.child === null) && (ms(n) ? n.flags |= 4 : t === null || t.memoizedState.isDehydrated && (n.flags & 256) === 0 || (n.flags |= 1024, $t !== null && (kc($t), $t = null))), fc(t, n), ut(n), null; case 5: Hl(n); var d = ur(Zi.current); if (o = n.type, t !== null && n.stateNode != null) hh(t, n, o, l, d), t.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!l) { if (n.stateNode === null) throw Error(i(166)); return ut(n), null } if (t = ur(nn.current), ms(n)) { l = n.stateNode, o = n.type; var m = n.memoizedProps; switch (l[tn] = n, l[Gi] = m, t = (n.mode & 1) !== 0, o) { case "dialog": De("cancel", l), De("close", l); break; case "iframe": case "object": case "embed": De("load", l); break; case "video": case "audio": for (d = 0; d < Ui.length; d++)De(Ui[d], l); break; case "source": De("error", l); break; case "img": case "image": case "link": De("error", l), De("load", l); break; case "details": De("toggle", l); break; case "input": Tr(l, m), De("invalid", l); break; case "select": l._wrapperState = { wasMultiple: !!m.multiple }, De("invalid", l); break; case "textarea": Qd(l, m), De("invalid", l) }Ka(o, m), d = null; for (var x in m) if (m.hasOwnProperty(x)) { var b = m[x]; x === "children" ? typeof b == "string" ? l.textContent !== b && (m.suppressHydrationWarning !== !0 && as(l.textContent, b, t), d = ["children", b]) : typeof b == "number" && l.textContent !== "" + b && (m.suppressHydrationWarning !== !0 && as(l.textContent, b, t), d = ["children", "" + b]) : a.hasOwnProperty(x) && b != null && x === "onScroll" && De("scroll", l) } switch (o) { case "input": Pe(l), qd(l, m, !0); break; case "textarea": Pe(l), Jd(l); break; case "select": case "option": break; default: typeof m.onClick == "function" && (l.onclick = ls) }l = d, n.updateQueue = l, l !== null && (n.flags |= 4) } else { x = d.nodeType === 9 ? d : d.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = ef(o)), t === "http://www.w3.org/1999/xhtml" ? o === "script" ? (t = x.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof l.is == "string" ? t = x.createElement(o, { is: l.is }) : (t = x.createElement(o), o === "select" && (x = t, l.multiple ? x.multiple = !0 : l.size && (x.size = l.size))) : t = x.createElementNS(t, o), t[tn] = n, t[Gi] = l, ph(t, n, !1, !1), n.stateNode = t; e: { switch (x = Ga(o, l), o) { case "dialog": De("cancel", t), De("close", t), d = l; break; case "iframe": case "object": case "embed": De("load", t), d = l; break; case "video": case "audio": for (d = 0; d < Ui.length; d++)De(Ui[d], t); d = l; break; case "source": De("error", t), d = l; break; case "img": case "image": case "link": De("error", t), De("load", t), d = l; break; case "details": De("toggle", t), d = l; break; case "input": Tr(t, l), d = zt(t, l), De("invalid", t); break; case "option": d = l; break; case "select": t._wrapperState = { wasMultiple: !!l.multiple }, d = G({}, l, { value: void 0 }), De("invalid", t); break; case "textarea": Qd(t, l), d = Ua(t, l), De("invalid", t); break; default: d = l }Ka(o, d), b = d; for (m in b) if (b.hasOwnProperty(m)) { var T = b[m]; m === "style" ? rf(t, T) : m === "dangerouslySetInnerHTML" ? (T = T ? T.__html : void 0, T != null && tf(t, T)) : m === "children" ? typeof T == "string" ? (o !== "textarea" || T !== "") && Ni(t, T) : typeof T == "number" && Ni(t, "" + T) : m !== "suppressContentEditableWarning" && m !== "suppressHydrationWarning" && m !== "autoFocus" && (a.hasOwnProperty(m) ? T != null && m === "onScroll" && De("scroll", t) : T != null && R(t, m, T, x)) } switch (o) { case "input": Pe(t), qd(t, l, !1); break; case "textarea": Pe(t), Jd(t); break; case "option": l.value != null && t.setAttribute("value", "" + ce(l.value)); break; case "select": t.multiple = !!l.multiple, m = l.value, m != null ? Ar(t, !!l.multiple, m, !1) : l.defaultValue != null && Ar(t, !!l.multiple, l.defaultValue, !0); break; default: typeof d.onClick == "function" && (t.onclick = ls) }switch (o) { case "button": case "input": case "select": case "textarea": l = !!l.autoFocus; break e; case "img": l = !0; break e; default: l = !1 } } l && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return ut(n), null; case 6: if (t && n.stateNode != null) mh(t, n, t.memoizedProps, l); else { if (typeof l != "string" && n.stateNode === null) throw Error(i(166)); if (o = ur(Zi.current), ur(nn.current), ms(n)) { if (l = n.stateNode, o = n.memoizedProps, l[tn] = n, (m = l.nodeValue !== o) && (t = bt, t !== null)) switch (t.tag) { case 3: as(l.nodeValue, o, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && as(l.nodeValue, o, (t.mode & 1) !== 0) }m && (n.flags |= 4) } else l = (o.nodeType === 9 ? o : o.ownerDocument).createTextNode(l), l[tn] = n, n.stateNode = l } return ut(n), null; case 13: if (_e(Ve), l = n.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (Le && Nt !== null && (n.mode & 1) !== 0 && (n.flags & 128) === 0) vp(), Hr(), n.flags |= 98560, m = !1; else if (m = ms(n), l !== null && l.dehydrated !== null) { if (t === null) { if (!m) throw Error(i(318)); if (m = n.memoizedState, m = m !== null ? m.dehydrated : null, !m) throw Error(i(317)); m[tn] = n } else Hr(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4; ut(n), m = !1 } else $t !== null && (kc($t), $t = null), m = !0; if (!m) return n.flags & 65536 ? n : null } return (n.flags & 128) !== 0 ? (n.lanes = o, n) : (l = l !== null, l !== (t !== null && t.memoizedState !== null) && l && (n.child.flags |= 8192, (n.mode & 1) !== 0 && (t === null || (Ve.current & 1) !== 0 ? Qe === 0 && (Qe = 3) : Pc())), n.updateQueue !== null && (n.flags |= 4), ut(n), null); case 4: return Xr(), fc(t, n), t === null && Hi(n.stateNode.containerInfo), ut(n), null; case 10: return zl(n.type._context), ut(n), null; case 17: return yt(n.type) && us(), ut(n), null; case 19: if (_e(Ve), m = n.memoizedState, m === null) return ut(n), null; if (l = (n.flags & 128) !== 0, x = m.rendering, x === null) if (l) ro(m, !1); else { if (Qe !== 0 || t !== null && (t.flags & 128) !== 0) for (t = n.child; t !== null;) { if (x = Ss(t), x !== null) { for (n.flags |= 128, ro(m, !1), l = x.updateQueue, l !== null && (n.updateQueue = l, n.flags |= 4), n.subtreeFlags = 0, l = o, o = n.child; o !== null;)m = o, t = l, m.flags &= 14680066, x = m.alternate, x === null ? (m.childLanes = 0, m.lanes = t, m.child = null, m.subtreeFlags = 0, m.memoizedProps = null, m.memoizedState = null, m.updateQueue = null, m.dependencies = null, m.stateNode = null) : (m.childLanes = x.childLanes, m.lanes = x.lanes, m.child = x.child, m.subtreeFlags = 0, m.deletions = null, m.memoizedProps = x.memoizedProps, m.memoizedState = x.memoizedState, m.updateQueue = x.updateQueue, m.type = x.type, t = x.dependencies, m.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), o = o.sibling; return Me(Ve, Ve.current & 1 | 2), n.child } t = t.sibling } m.tail !== null && Ue() > Jr && (n.flags |= 128, l = !0, ro(m, !1), n.lanes = 4194304) } else { if (!l) if (t = Ss(x), t !== null) { if (n.flags |= 128, l = !0, o = t.updateQueue, o !== null && (n.updateQueue = o, n.flags |= 4), ro(m, !0), m.tail === null && m.tailMode === "hidden" && !x.alternate && !Le) return ut(n), null } else 2 * Ue() - m.renderingStartTime > Jr && o !== 1073741824 && (n.flags |= 128, l = !0, ro(m, !1), n.lanes = 4194304); m.isBackwards ? (x.sibling = n.child, n.child = x) : (o = m.last, o !== null ? o.sibling = x : n.child = x, m.last = x) } return m.tail !== null ? (n = m.tail, m.rendering = n, m.tail = n.sibling, m.renderingStartTime = Ue(), n.sibling = null, o = Ve.current, Me(Ve, l ? o & 1 | 2 : o & 1), n) : (ut(n), null); case 22: case 23: return Nc(), l = n.memoizedState !== null, t !== null && t.memoizedState !== null !== l && (n.flags |= 8192), l && (n.mode & 1) !== 0 ? (Pt & 1073741824) !== 0 && (ut(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : ut(n), null; case 24: return null; case 25: return null }throw Error(i(156, n.tag)) } function Zw(t, n) { switch (Dl(n), n.tag) { case 1: return yt(n.type) && us(), t = n.flags, t & 65536 ? (n.flags = t & -65537 | 128, n) : null; case 3: return Xr(), _e(gt), _e(lt), Gl(), t = n.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (n.flags = t & -65537 | 128, n) : null; case 5: return Hl(n), null; case 13: if (_e(Ve), t = n.memoizedState, t !== null && t.dehydrated !== null) { if (n.alternate === null) throw Error(i(340)); Hr() } return t = n.flags, t & 65536 ? (n.flags = t & -65537 | 128, n) : null; case 19: return _e(Ve), null; case 4: return Xr(), null; case 10: return zl(n.type._context), null; case 22: case 23: return Nc(), null; case 24: return null; default: return null } } var As = !1, dt = !1, Jw = typeof WeakSet == "function" ? WeakSet : Set, J = null; function Qr(t, n) { var o = t.ref; if (o !== null) if (typeof o == "function") try { o(null) } catch (l) { Be(t, n, l) } else o.current = null } function pc(t, n, o) { try { o() } catch (l) { Be(t, n, l) } } var gh = !1; function e1(t, n) { if (Nl = qo, t = Yf(), yl(t)) { if ("selectionStart" in t) var o = { start: t.selectionStart, end: t.selectionEnd }; else e: { o = (o = t.ownerDocument) && o.defaultView || window; var l = o.getSelection && o.getSelection(); if (l && l.rangeCount !== 0) { o = l.anchorNode; var d = l.anchorOffset, m = l.focusNode; l = l.focusOffset; try { o.nodeType, m.nodeType } catch { o = null; break e } var x = 0, b = -1, T = -1, L = 0, U = 0, H = t, $ = null; t: for (; ;) { for (var Q; H !== o || d !== 0 && H.nodeType !== 3 || (b = x + d), H !== m || l !== 0 && H.nodeType !== 3 || (T = x + l), H.nodeType === 3 && (x += H.nodeValue.length), (Q = H.firstChild) !== null;)$ = H, H = Q; for (; ;) { if (H === t) break t; if ($ === o && ++L === d && (b = x), $ === m && ++U === l && (T = x), (Q = H.nextSibling) !== null) break; H = $, $ = H.parentNode } H = Q } o = b === -1 || T === -1 ? null : { start: b, end: T } } else o = null } o = o || { start: 0, end: 0 } } else o = null; for (Pl = { focusedElem: t, selectionRange: o }, qo = !1, J = n; J !== null;)if (n = J, t = n.child, (n.subtreeFlags & 1028) !== 0 && t !== null) t.return = n, J = t; else for (; J !== null;) { n = J; try { var ee = n.alternate; if ((n.flags & 1024) !== 0) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (ee !== null) { var re = ee.memoizedProps, He = ee.memoizedState, D = n.stateNode, A = D.getSnapshotBeforeUpdate(n.elementType === n.type ? re : Ut(n.type, re), He); D.__reactInternalSnapshotBeforeUpdate = A } break; case 3: var _ = n.stateNode.containerInfo; _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(i(163)) } } catch (Y) { Be(n, n.return, Y) } if (t = n.sibling, t !== null) { t.return = n.return, J = t; break } J = n.return } return ee = gh, gh = !1, ee } function io(t, n, o) { var l = n.updateQueue; if (l = l !== null ? l.lastEffect : null, l !== null) { var d = l = l.next; do { if ((d.tag & t) === t) { var m = d.destroy; d.destroy = void 0, m !== void 0 && pc(n, o, m) } d = d.next } while (d !== l) } } function Rs(t, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var o = n = n.next; do { if ((o.tag & t) === t) { var l = o.create; o.destroy = l() } o = o.next } while (o !== n) } } function hc(t) { var n = t.ref; if (n !== null) { var o = t.stateNode; switch (t.tag) { case 5: t = o; break; default: t = o }typeof n == "function" ? n(t) : n.current = t } } function yh(t) { var n = t.alternate; n !== null && (t.alternate = null, yh(n)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (n = t.stateNode, n !== null && (delete n[tn], delete n[Gi], delete n[Al], delete n[Lw], delete n[Ow])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function vh(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function xh(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || vh(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function mc(t, n, o) { var l = t.tag; if (l === 5 || l === 6) t = t.stateNode, n ? o.nodeType === 8 ? o.parentNode.insertBefore(t, n) : o.insertBefore(t, n) : (o.nodeType === 8 ? (n = o.parentNode, n.insertBefore(t, o)) : (n = o, n.appendChild(t)), o = o._reactRootContainer, o != null || n.onclick !== null || (n.onclick = ls)); else if (l !== 4 && (t = t.child, t !== null)) for (mc(t, n, o), t = t.sibling; t !== null;)mc(t, n, o), t = t.sibling } function gc(t, n, o) { var l = t.tag; if (l === 5 || l === 6) t = t.stateNode, n ? o.insertBefore(t, n) : o.appendChild(t); else if (l !== 4 && (t = t.child, t !== null)) for (gc(t, n, o), t = t.sibling; t !== null;)gc(t, n, o), t = t.sibling } var it = null, Ht = !1; function Fn(t, n, o) { for (o = o.child; o !== null;)wh(t, n, o), o = o.sibling } function wh(t, n, o) { if (en && typeof en.onCommitFiberUnmount == "function") try { en.onCommitFiberUnmount(Uo, o) } catch { } switch (o.tag) { case 5: dt || Qr(o, n); case 6: var l = it, d = Ht; it = null, Fn(t, n, o), it = l, Ht = d, it !== null && (Ht ? (t = it, o = o.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(o) : t.removeChild(o)) : it.removeChild(o.stateNode)); break; case 18: it !== null && (Ht ? (t = it, o = o.stateNode, t.nodeType === 8 ? jl(t.parentNode, o) : t.nodeType === 1 && jl(t, o), Li(t)) : jl(it, o.stateNode)); break; case 4: l = it, d = Ht, it = o.stateNode.containerInfo, Ht = !0, Fn(t, n, o), it = l, Ht = d; break; case 0: case 11: case 14: case 15: if (!dt && (l = o.updateQueue, l !== null && (l = l.lastEffect, l !== null))) { d = l = l.next; do { var m = d, x = m.destroy; m = m.tag, x !== void 0 && ((m & 2) !== 0 || (m & 4) !== 0) && pc(o, n, x), d = d.next } while (d !== l) } Fn(t, n, o); break; case 1: if (!dt && (Qr(o, n), l = o.stateNode, typeof l.componentWillUnmount == "function")) try { l.props = o.memoizedProps, l.state = o.memoizedState, l.componentWillUnmount() } catch (b) { Be(o, n, b) } Fn(t, n, o); break; case 21: Fn(t, n, o); break; case 22: o.mode & 1 ? (dt = (l = dt) || o.memoizedState !== null, Fn(t, n, o), dt = l) : Fn(t, n, o); break; default: Fn(t, n, o) } } function Sh(t) { var n = t.updateQueue; if (n !== null) { t.updateQueue = null; var o = t.stateNode; o === null && (o = t.stateNode = new Jw), n.forEach(function (l) { var d = c1.bind(null, t, l); o.has(l) || (o.add(l), l.then(d, d)) }) } } function Kt(t, n) { var o = n.deletions; if (o !== null) for (var l = 0; l < o.length; l++) { var d = o[l]; try { var m = t, x = n, b = x; e: for (; b !== null;) { switch (b.tag) { case 5: it = b.stateNode, Ht = !1; break e; case 3: it = b.stateNode.containerInfo, Ht = !0; break e; case 4: it = b.stateNode.containerInfo, Ht = !0; break e }b = b.return } if (it === null) throw Error(i(160)); wh(m, x, d), it = null, Ht = !1; var T = d.alternate; T !== null && (T.return = null), d.return = null } catch (L) { Be(d, n, L) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)Ch(n, t), n = n.sibling } function Ch(t, n) { var o = t.alternate, l = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Kt(n, t), on(t), l & 4) { try { io(3, t, t.return), Rs(3, t) } catch (re) { Be(t, t.return, re) } try { io(5, t, t.return) } catch (re) { Be(t, t.return, re) } } break; case 1: Kt(n, t), on(t), l & 512 && o !== null && Qr(o, o.return); break; case 5: if (Kt(n, t), on(t), l & 512 && o !== null && Qr(o, o.return), t.flags & 32) { var d = t.stateNode; try { Ni(d, "") } catch (re) { Be(t, t.return, re) } } if (l & 4 && (d = t.stateNode, d != null)) { var m = t.memoizedProps, x = o !== null ? o.memoizedProps : m, b = t.type, T = t.updateQueue; if (t.updateQueue = null, T !== null) try { b === "input" && m.type === "radio" && m.name != null && jr(d, m), Ga(b, x); var L = Ga(b, m); for (x = 0; x < T.length; x += 2) { var U = T[x], H = T[x + 1]; U === "style" ? rf(d, H) : U === "dangerouslySetInnerHTML" ? tf(d, H) : U === "children" ? Ni(d, H) : R(d, U, H, L) } switch (b) { case "input": rr(d, m); break; case "textarea": Zd(d, m); break; case "select": var $ = d._wrapperState.wasMultiple; d._wrapperState.wasMultiple = !!m.multiple; var Q = m.value; Q != null ? Ar(d, !!m.multiple, Q, !1) : $ !== !!m.multiple && (m.defaultValue != null ? Ar(d, !!m.multiple, m.defaultValue, !0) : Ar(d, !!m.multiple, m.multiple ? [] : "", !1)) }d[Gi] = m } catch (re) { Be(t, t.return, re) } } break; case 6: if (Kt(n, t), on(t), l & 4) { if (t.stateNode === null) throw Error(i(162)); d = t.stateNode, m = t.memoizedProps; try { d.nodeValue = m } catch (re) { Be(t, t.return, re) } } break; case 3: if (Kt(n, t), on(t), l & 4 && o !== null && o.memoizedState.isDehydrated) try { Li(n.containerInfo) } catch (re) { Be(t, t.return, re) } break; case 4: Kt(n, t), on(t); break; case 13: Kt(n, t), on(t), d = t.child, d.flags & 8192 && (m = d.memoizedState !== null, d.stateNode.isHidden = m, !m || d.alternate !== null && d.alternate.memoizedState !== null || (xc = Ue())), l & 4 && Sh(t); break; case 22: if (U = o !== null && o.memoizedState !== null, t.mode & 1 ? (dt = (L = dt) || U, Kt(n, t), dt = L) : Kt(n, t), on(t), l & 8192) { if (L = t.memoizedState !== null, (t.stateNode.isHidden = L) && !U && (t.mode & 1) !== 0) for (J = t, U = t.child; U !== null;) { for (H = J = U; J !== null;) { switch ($ = J, Q = $.child, $.tag) { case 0: case 11: case 14: case 15: io(4, $, $.return); break; case 1: Qr($, $.return); var ee = $.stateNode; if (typeof ee.componentWillUnmount == "function") { l = $, o = $.return; try { n = l, ee.props = n.memoizedProps, ee.state = n.memoizedState, ee.componentWillUnmount() } catch (re) { Be(l, o, re) } } break; case 5: Qr($, $.return); break; case 22: if ($.memoizedState !== null) { Nh(H); continue } }Q !== null ? (Q.return = $, J = Q) : Nh(H) } U = U.sibling } e: for (U = null, H = t; ;) { if (H.tag === 5) { if (U === null) { U = H; try { d = H.stateNode, L ? (m = d.style, typeof m.setProperty == "function" ? m.setProperty("display", "none", "important") : m.display = "none") : (b = H.stateNode, T = H.memoizedProps.style, x = T != null && T.hasOwnProperty("display") ? T.display : null, b.style.display = nf("display", x)) } catch (re) { Be(t, t.return, re) } } } else if (H.tag === 6) { if (U === null) try { H.stateNode.nodeValue = L ? "" : H.memoizedProps } catch (re) { Be(t, t.return, re) } } else if ((H.tag !== 22 && H.tag !== 23 || H.memoizedState === null || H === t) && H.child !== null) { H.child.return = H, H = H.child; continue } if (H === t) break e; for (; H.sibling === null;) { if (H.return === null || H.return === t) break e; U === H && (U = null), H = H.return } U === H && (U = null), H.sibling.return = H.return, H = H.sibling } } break; case 19: Kt(n, t), on(t), l & 4 && Sh(t); break; case 21: break; default: Kt(n, t), on(t) } } function on(t) { var n = t.flags; if (n & 2) { try { e: { for (var o = t.return; o !== null;) { if (vh(o)) { var l = o; break e } o = o.return } throw Error(i(160)) } switch (l.tag) { case 5: var d = l.stateNode; l.flags & 32 && (Ni(d, ""), l.flags &= -33); var m = xh(t); gc(t, m, d); break; case 3: case 4: var x = l.stateNode.containerInfo, b = xh(t); mc(t, b, x); break; default: throw Error(i(161)) } } catch (T) { Be(t, t.return, T) } t.flags &= -3 } n & 4096 && (t.flags &= -4097) } function t1(t, n, o) { J = t, kh(t) } function kh(t, n, o) { for (var l = (t.mode & 1) !== 0; J !== null;) { var d = J, m = d.child; if (d.tag === 22 && l) { var x = d.memoizedState !== null || As; if (!x) { var b = d.alternate, T = b !== null && b.memoizedState !== null || dt; b = As; var L = dt; if (As = x, (dt = T) && !L) for (J = d; J !== null;)x = J, T = x.child, x.tag === 22 && x.memoizedState !== null ? Ph(d) : T !== null ? (T.return = x, J = T) : Ph(d); for (; m !== null;)J = m, kh(m), m = m.sibling; J = d, As = b, dt = L } bh(t) } else (d.subtreeFlags & 8772) !== 0 && m !== null ? (m.return = d, J = m) : bh(t) } } function bh(t) { for (; J !== null;) { var n = J; if ((n.flags & 8772) !== 0) { var o = n.alternate; try { if ((n.flags & 8772) !== 0) switch (n.tag) { case 0: case 11: case 15: dt || Rs(5, n); break; case 1: var l = n.stateNode; if (n.flags & 4 && !dt) if (o === null) l.componentDidMount(); else { var d = n.elementType === n.type ? o.memoizedProps : Ut(n.type, o.memoizedProps); l.componentDidUpdate(d, o.memoizedState, l.__reactInternalSnapshotBeforeUpdate) } var m = n.updateQueue; m !== null && Np(n, m, l); break; case 3: var x = n.updateQueue; if (x !== null) { if (o = null, n.child !== null) switch (n.child.tag) { case 5: o = n.child.stateNode; break; case 1: o = n.child.stateNode }Np(n, x, o) } break; case 5: var b = n.stateNode; if (o === null && n.flags & 4) { o = b; var T = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": T.autoFocus && o.focus(); break; case "img": T.src && (o.src = T.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var L = n.alternate; if (L !== null) { var U = L.memoizedState; if (U !== null) { var H = U.dehydrated; H !== null && Li(H) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(i(163)) }dt || n.flags & 512 && hc(n) } catch ($) { Be(n, n.return, $) } } if (n === t) { J = null; break } if (o = n.sibling, o !== null) { o.return = n.return, J = o; break } J = n.return } } function Nh(t) { for (; J !== null;) { var n = J; if (n === t) { J = null; break } var o = n.sibling; if (o !== null) { o.return = n.return, J = o; break } J = n.return } } function Ph(t) { for (; J !== null;) { var n = J; try { switch (n.tag) { case 0: case 11: case 15: var o = n.return; try { Rs(4, n) } catch (T) { Be(n, o, T) } break; case 1: var l = n.stateNode; if (typeof l.componentDidMount == "function") { var d = n.return; try { l.componentDidMount() } catch (T) { Be(n, d, T) } } var m = n.return; try { hc(n) } catch (T) { Be(n, m, T) } break; case 5: var x = n.return; try { hc(n) } catch (T) { Be(n, x, T) } } } catch (T) { Be(n, n.return, T) } if (n === t) { J = null; break } var b = n.sibling; if (b !== null) { b.return = n.return, J = b; break } J = n.return } } var n1 = Math.ceil, Ms = O.ReactCurrentDispatcher, yc = O.ReactCurrentOwner, Dt = O.ReactCurrentBatchConfig, Ee = 0, tt = null, Ge = null, ot = 0, Pt = 0, Zr = Dn(0), Qe = 0, oo = null, fr = 0, Is = 0, vc = 0, so = null, xt = null, xc = 0, Jr = 1 / 0, wn = null, Ds = !1, wc = null, zn = null, _s = !1, Bn = null, Ls = 0, ao = 0, Sc = null, Os = -1, Vs = 0; function ht() { return (Ee & 6) !== 0 ? Ue() : Os !== -1 ? Os : Os = Ue() } function Wn(t) { return (t.mode & 1) === 0 ? 1 : (Ee & 2) !== 0 && ot !== 0 ? ot & -ot : Fw.transition !== null ? (Vs === 0 && (Vs = xf()), Vs) : (t = Ae, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Tf(t.type)), t) } function Gt(t, n, o, l) { if (50 < ao) throw ao = 0, Sc = null, Error(i(185)); Ri(t, o, l), ((Ee & 2) === 0 || t !== tt) && (t === tt && ((Ee & 2) === 0 && (Is |= o), Qe === 4 && $n(t, ot)), wt(t, l), o === 1 && Ee === 0 && (n.mode & 1) === 0 && (Jr = Ue() + 500, fs && Ln())) } function wt(t, n) { var o = t.callbackNode; Fx(t, n); var l = Go(t, t === tt ? ot : 0); if (l === 0) o !== null && gf(o), t.callbackNode = null, t.callbackPriority = 0; else if (n = l & -l, t.callbackPriority !== n) { if (o != null && gf(o), n === 1) t.tag === 0 ? Vw(Th.bind(null, t)) : pp(Th.bind(null, t)), Dw(function () { (Ee & 6) === 0 && Ln() }), o = null; else { switch (wf(l)) { case 1: o = el; break; case 4: o = yf; break; case 16: o = $o; break; case 536870912: o = vf; break; default: o = $o }o = Lh(o, Eh.bind(null, t)) } t.callbackPriority = n, t.callbackNode = o } } function Eh(t, n) { if (Os = -1, Vs = 0, (Ee & 6) !== 0) throw Error(i(327)); var o = t.callbackNode; if (ei() && t.callbackNode !== o) return null; var l = Go(t, t === tt ? ot : 0); if (l === 0) return null; if ((l & 30) !== 0 || (l & t.expiredLanes) !== 0 || n) n = Fs(t, l); else { n = l; var d = Ee; Ee |= 2; var m = Ah(); (tt !== t || ot !== n) && (wn = null, Jr = Ue() + 500, hr(t, n)); do try { o1(); break } catch (b) { jh(t, b) } while (!0); Fl(), Ms.current = m, Ee = d, Ge !== null ? n = 0 : (tt = null, ot = 0, n = Qe) } if (n !== 0) { if (n === 2 && (d = tl(t), d !== 0 && (l = d, n = Cc(t, d))), n === 1) throw o = oo, hr(t, 0), $n(t, l), wt(t, Ue()), o; if (n === 6) $n(t, l); else { if (d = t.current.alternate, (l & 30) === 0 && !r1(d) && (n = Fs(t, l), n === 2 && (m = tl(t), m !== 0 && (l = m, n = Cc(t, m))), n === 1)) throw o = oo, hr(t, 0), $n(t, l), wt(t, Ue()), o; switch (t.finishedWork = d, t.finishedLanes = l, n) { case 0: case 1: throw Error(i(345)); case 2: mr(t, xt, wn); break; case 3: if ($n(t, l), (l & 130023424) === l && (n = xc + 500 - Ue(), 10 < n)) { if (Go(t, 0) !== 0) break; if (d = t.suspendedLanes, (d & l) !== l) { ht(), t.pingedLanes |= t.suspendedLanes & d; break } t.timeoutHandle = Tl(mr.bind(null, t, xt, wn), n); break } mr(t, xt, wn); break; case 4: if ($n(t, l), (l & 4194240) === l) break; for (n = t.eventTimes, d = -1; 0 < l;) { var x = 31 - Bt(l); m = 1 << x, x = n[x], x > d && (d = x), l &= ~m } if (l = d, l = Ue() - l, l = (120 > l ? 120 : 480 > l ? 480 : 1080 > l ? 1080 : 1920 > l ? 1920 : 3e3 > l ? 3e3 : 4320 > l ? 4320 : 1960 * n1(l / 1960)) - l, 10 < l) { t.timeoutHandle = Tl(mr.bind(null, t, xt, wn), l); break } mr(t, xt, wn); break; case 5: mr(t, xt, wn); break; default: throw Error(i(329)) } } } return wt(t, Ue()), t.callbackNode === o ? Eh.bind(null, t) : null } function Cc(t, n) { var o = so; return t.current.memoizedState.isDehydrated && (hr(t, n).flags |= 256), t = Fs(t, n), t !== 2 && (n = xt, xt = o, n !== null && kc(n)), t } function kc(t) { xt === null ? xt = t : xt.push.apply(xt, t) } function r1(t) { for (var n = t; ;) { if (n.flags & 16384) { var o = n.updateQueue; if (o !== null && (o = o.stores, o !== null)) for (var l = 0; l < o.length; l++) { var d = o[l], m = d.getSnapshot; d = d.value; try { if (!Wt(m(), d)) return !1 } catch { return !1 } } } if (o = n.child, n.subtreeFlags & 16384 && o !== null) o.return = n, n = o; else { if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function $n(t, n) { for (n &= ~vc, n &= ~Is, t.suspendedLanes |= n, t.pingedLanes &= ~n, t = t.expirationTimes; 0 < n;) { var o = 31 - Bt(n), l = 1 << o; t[o] = -1, n &= ~l } } function Th(t) { if ((Ee & 6) !== 0) throw Error(i(327)); ei(); var n = Go(t, 0); if ((n & 1) === 0) return wt(t, Ue()), null; var o = Fs(t, n); if (t.tag !== 0 && o === 2) { var l = tl(t); l !== 0 && (n = l, o = Cc(t, l)) } if (o === 1) throw o = oo, hr(t, 0), $n(t, n), wt(t, Ue()), o; if (o === 6) throw Error(i(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = n, mr(t, xt, wn), wt(t, Ue()), null } function bc(t, n) { var o = Ee; Ee |= 1; try { return t(n) } finally { Ee = o, Ee === 0 && (Jr = Ue() + 500, fs && Ln()) } } function pr(t) { Bn !== null && Bn.tag === 0 && (Ee & 6) === 0 && ei(); var n = Ee; Ee |= 1; var o = Dt.transition, l = Ae; try { if (Dt.transition = null, Ae = 1, t) return t() } finally { Ae = l, Dt.transition = o, Ee = n, (Ee & 6) === 0 && Ln() } } function Nc() { Pt = Zr.current, _e(Zr) } function hr(t, n) { t.finishedWork = null, t.finishedLanes = 0; var o = t.timeoutHandle; if (o !== -1 && (t.timeoutHandle = -1, Iw(o)), Ge !== null) for (o = Ge.return; o !== null;) { var l = o; switch (Dl(l), l.tag) { case 1: l = l.type.childContextTypes, l != null && us(); break; case 3: Xr(), _e(gt), _e(lt), Gl(); break; case 5: Hl(l); break; case 4: Xr(); break; case 13: _e(Ve); break; case 19: _e(Ve); break; case 10: zl(l.type._context); break; case 22: case 23: Nc() }o = o.return } if (tt = t, Ge = t = Un(t.current, null), ot = Pt = n, Qe = 0, oo = null, vc = Is = fr = 0, xt = so = null, cr !== null) { for (n = 0; n < cr.length; n++)if (o = cr[n], l = o.interleaved, l !== null) { o.interleaved = null; var d = l.next, m = o.pending; if (m !== null) { var x = m.next; m.next = d, l.next = x } o.pending = l } cr = null } return t } function jh(t, n) { do { var o = Ge; try { if (Fl(), Cs.current = Ps, ks) { for (var l = Fe.memoizedState; l !== null;) { var d = l.queue; d !== null && (d.pending = null), l = l.next } ks = !1 } if (dr = 0, et = qe = Fe = null, Ji = !1, eo = 0, yc.current = null, o === null || o.return === null) { Qe = 1, oo = n, Ge = null; break } e: { var m = t, x = o.return, b = o, T = n; if (n = ot, b.flags |= 32768, T !== null && typeof T == "object" && typeof T.then == "function") { var L = T, U = b, H = U.tag; if ((U.mode & 1) === 0 && (H === 0 || H === 11 || H === 15)) { var $ = U.alternate; $ ? (U.updateQueue = $.updateQueue, U.memoizedState = $.memoizedState, U.lanes = $.lanes) : (U.updateQueue = null, U.memoizedState = null) } var Q = eh(x); if (Q !== null) { Q.flags &= -257, th(Q, x, b, m, n), Q.mode & 1 && Jp(m, L, n), n = Q, T = L; var ee = n.updateQueue; if (ee === null) { var re = new Set; re.add(T), n.updateQueue = re } else ee.add(T); break e } else { if ((n & 1) === 0) { Jp(m, L, n), Pc(); break e } T = Error(i(426)) } } else if (Le && b.mode & 1) { var He = eh(x); if (He !== null) { (He.flags & 65536) === 0 && (He.flags |= 256), th(He, x, b, m, n), Ol(qr(T, b)); break e } } m = T = qr(T, b), Qe !== 4 && (Qe = 2), so === null ? so = [m] : so.push(m), m = x; do { switch (m.tag) { case 3: m.flags |= 65536, n &= -n, m.lanes |= n; var D = Qp(m, T, n); bp(m, D); break e; case 1: b = T; var A = m.type, _ = m.stateNode; if ((m.flags & 128) === 0 && (typeof A.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (zn === null || !zn.has(_)))) { m.flags |= 65536, n &= -n, m.lanes |= n; var Y = Zp(m, b, n); bp(m, Y); break e } }m = m.return } while (m !== null) } Mh(o) } catch (le) { n = le, Ge === o && o !== null && (Ge = o = o.return); continue } break } while (!0) } function Ah() { var t = Ms.current; return Ms.current = Ps, t === null ? Ps : t } function Pc() { (Qe === 0 || Qe === 3 || Qe === 2) && (Qe = 4), tt === null || (fr & 268435455) === 0 && (Is & 268435455) === 0 || $n(tt, ot) } function Fs(t, n) { var o = Ee; Ee |= 2; var l = Ah(); (tt !== t || ot !== n) && (wn = null, hr(t, n)); do try { i1(); break } catch (d) { jh(t, d) } while (!0); if (Fl(), Ee = o, Ms.current = l, Ge !== null) throw Error(i(261)); return tt = null, ot = 0, Qe } function i1() { for (; Ge !== null;)Rh(Ge) } function o1() { for (; Ge !== null && !Ax();)Rh(Ge) } function Rh(t) { var n = _h(t.alternate, t, Pt); t.memoizedProps = t.pendingProps, n === null ? Mh(t) : Ge = n, yc.current = null } function Mh(t) { var n = t; do { var o = n.alternate; if (t = n.return, (n.flags & 32768) === 0) { if (o = Qw(o, n, Pt), o !== null) { Ge = o; return } } else { if (o = Zw(o, n), o !== null) { o.flags &= 32767, Ge = o; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { Qe = 6, Ge = null; return } } if (n = n.sibling, n !== null) { Ge = n; return } Ge = n = t } while (n !== null); Qe === 0 && (Qe = 5) } function mr(t, n, o) { var l = Ae, d = Dt.transition; try { Dt.transition = null, Ae = 1, s1(t, n, o, l) } finally { Dt.transition = d, Ae = l } return null } function s1(t, n, o, l) { do ei(); while (Bn !== null); if ((Ee & 6) !== 0) throw Error(i(327)); o = t.finishedWork; var d = t.finishedLanes; if (o === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, o === t.current) throw Error(i(177)); t.callbackNode = null, t.callbackPriority = 0; var m = o.lanes | o.childLanes; if (zx(t, m), t === tt && (Ge = tt = null, ot = 0), (o.subtreeFlags & 2064) === 0 && (o.flags & 2064) === 0 || _s || (_s = !0, Lh($o, function () { return ei(), null })), m = (o.flags & 15990) !== 0, (o.subtreeFlags & 15990) !== 0 || m) { m = Dt.transition, Dt.transition = null; var x = Ae; Ae = 1; var b = Ee; Ee |= 4, yc.current = null, e1(t, o), Ch(o, t), Pw(Pl), qo = !!Nl, Pl = Nl = null, t.current = o, t1(o), Rx(), Ee = b, Ae = x, Dt.transition = m } else t.current = o; if (_s && (_s = !1, Bn = t, Ls = d), m = t.pendingLanes, m === 0 && (zn = null), Dx(o.stateNode), wt(t, Ue()), n !== null) for (l = t.onRecoverableError, o = 0; o < n.length; o++)d = n[o], l(d.value, { componentStack: d.stack, digest: d.digest }); if (Ds) throw Ds = !1, t = wc, wc = null, t; return (Ls & 1) !== 0 && t.tag !== 0 && ei(), m = t.pendingLanes, (m & 1) !== 0 ? t === Sc ? ao++ : (ao = 0, Sc = t) : ao = 0, Ln(), null } function ei() { if (Bn !== null) { var t = wf(Ls), n = Dt.transition, o = Ae; try { if (Dt.transition = null, Ae = 16 > t ? 16 : t, Bn === null) var l = !1; else { if (t = Bn, Bn = null, Ls = 0, (Ee & 6) !== 0) throw Error(i(331)); var d = Ee; for (Ee |= 4, J = t.current; J !== null;) { var m = J, x = m.child; if ((J.flags & 16) !== 0) { var b = m.deletions; if (b !== null) { for (var T = 0; T < b.length; T++) { var L = b[T]; for (J = L; J !== null;) { var U = J; switch (U.tag) { case 0: case 11: case 15: io(8, U, m) }var H = U.child; if (H !== null) H.return = U, J = H; else for (; J !== null;) { U = J; var $ = U.sibling, Q = U.return; if (yh(U), U === L) { J = null; break } if ($ !== null) { $.return = Q, J = $; break } J = Q } } } var ee = m.alternate; if (ee !== null) { var re = ee.child; if (re !== null) { ee.child = null; do { var He = re.sibling; re.sibling = null, re = He } while (re !== null) } } J = m } } if ((m.subtreeFlags & 2064) !== 0 && x !== null) x.return = m, J = x; else e: for (; J !== null;) { if (m = J, (m.flags & 2048) !== 0) switch (m.tag) { case 0: case 11: case 15: io(9, m, m.return) }var D = m.sibling; if (D !== null) { D.return = m.return, J = D; break e } J = m.return } } var A = t.current; for (J = A; J !== null;) { x = J; var _ = x.child; if ((x.subtreeFlags & 2064) !== 0 && _ !== null) _.return = x, J = _; else e: for (x = A; J !== null;) { if (b = J, (b.flags & 2048) !== 0) try { switch (b.tag) { case 0: case 11: case 15: Rs(9, b) } } catch (le) { Be(b, b.return, le) } if (b === x) { J = null; break e } var Y = b.sibling; if (Y !== null) { Y.return = b.return, J = Y; break e } J = b.return } } if (Ee = d, Ln(), en && typeof en.onPostCommitFiberRoot == "function") try { en.onPostCommitFiberRoot(Uo, t) } catch { } l = !0 } return l } finally { Ae = o, Dt.transition = n } } return !1 } function Ih(t, n, o) { n = qr(o, n), n = Qp(t, n, 1), t = Vn(t, n, 1), n = ht(), t !== null && (Ri(t, 1, n), wt(t, n)) } function Be(t, n, o) { if (t.tag === 3) Ih(t, t, o); else for (; n !== null;) { if (n.tag === 3) { Ih(n, t, o); break } else if (n.tag === 1) { var l = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof l.componentDidCatch == "function" && (zn === null || !zn.has(l))) { t = qr(o, t), t = Zp(n, t, 1), n = Vn(n, t, 1), t = ht(), n !== null && (Ri(n, 1, t), wt(n, t)); break } } n = n.return } } function a1(t, n, o) { var l = t.pingCache; l !== null && l.delete(n), n = ht(), t.pingedLanes |= t.suspendedLanes & o, tt === t && (ot & o) === o && (Qe === 4 || Qe === 3 && (ot & 130023424) === ot && 500 > Ue() - xc ? hr(t, 0) : vc |= o), wt(t, n) } function Dh(t, n) { n === 0 && ((t.mode & 1) === 0 ? n = 1 : (n = Ko, Ko <<= 1, (Ko & 130023424) === 0 && (Ko = 4194304))); var o = ht(); t = yn(t, n), t !== null && (Ri(t, n, o), wt(t, o)) } function l1(t) { var n = t.memoizedState, o = 0; n !== null && (o = n.retryLane), Dh(t, o) } function c1(t, n) { var o = 0; switch (t.tag) { case 13: var l = t.stateNode, d = t.memoizedState; d !== null && (o = d.retryLane); break; case 19: l = t.stateNode; break; default: throw Error(i(314)) }l !== null && l.delete(n), Dh(t, o) } var _h; _h = function (t, n, o) { if (t !== null) if (t.memoizedProps !== n.pendingProps || gt.current) vt = !0; else { if ((t.lanes & o) === 0 && (n.flags & 128) === 0) return vt = !1, qw(t, n, o); vt = (t.flags & 131072) !== 0 } else vt = !1, Le && (n.flags & 1048576) !== 0 && hp(n, hs, n.index); switch (n.lanes = 0, n.tag) { case 2: var l = n.type; js(t, n), t = n.pendingProps; var d = Wr(n, lt.current); Yr(n, o), d = ql(null, n, l, t, d, o); var m = Ql(); return n.flags |= 1, typeof d == "object" && d !== null && typeof d.render == "function" && d.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, yt(l) ? (m = !0, ds(n)) : m = !1, n.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null, $l(n), d.updater = Es, n.stateNode = d, d._reactInternals = n, rc(n, l, t, o), n = ac(null, n, l, !0, m, o)) : (n.tag = 0, Le && m && Il(n), pt(null, n, d, o), n = n.child), n; case 16: l = n.elementType; e: { switch (js(t, n), t = n.pendingProps, d = l._init, l = d(l._payload), n.type = l, d = n.tag = d1(l), t = Ut(l, t), d) { case 0: n = sc(null, n, l, t, o); break e; case 1: n = ah(null, n, l, t, o); break e; case 11: n = nh(null, n, l, t, o); break e; case 14: n = rh(null, n, l, Ut(l.type, t), o); break e }throw Error(i(306, l, "")) } return n; case 0: return l = n.type, d = n.pendingProps, d = n.elementType === l ? d : Ut(l, d), sc(t, n, l, d, o); case 1: return l = n.type, d = n.pendingProps, d = n.elementType === l ? d : Ut(l, d), ah(t, n, l, d, o); case 3: e: { if (lh(n), t === null) throw Error(i(387)); l = n.pendingProps, m = n.memoizedState, d = m.element, kp(t, n), ws(n, l, null, o); var x = n.memoizedState; if (l = x.element, m.isDehydrated) if (m = { element: l, isDehydrated: !1, cache: x.cache, pendingSuspenseBoundaries: x.pendingSuspenseBoundaries, transitions: x.transitions }, n.updateQueue.baseState = m, n.memoizedState = m, n.flags & 256) { d = qr(Error(i(423)), n), n = ch(t, n, l, o, d); break e } else if (l !== d) { d = qr(Error(i(424)), n), n = ch(t, n, l, o, d); break e } else for (Nt = In(n.stateNode.containerInfo.firstChild), bt = n, Le = !0, $t = null, o = Sp(n, null, l, o), n.child = o; o;)o.flags = o.flags & -3 | 4096, o = o.sibling; else { if (Hr(), l === d) { n = xn(t, n, o); break e } pt(t, n, l, o) } n = n.child } return n; case 5: return Pp(n), t === null && Ll(n), l = n.type, d = n.pendingProps, m = t !== null ? t.memoizedProps : null, x = d.children, El(l, d) ? x = null : m !== null && El(l, m) && (n.flags |= 32), sh(t, n), pt(t, n, x, o), n.child; case 6: return t === null && Ll(n), null; case 13: return uh(t, n, o); case 4: return Ul(n, n.stateNode.containerInfo), l = n.pendingProps, t === null ? n.child = Kr(n, null, l, o) : pt(t, n, l, o), n.child; case 11: return l = n.type, d = n.pendingProps, d = n.elementType === l ? d : Ut(l, d), nh(t, n, l, d, o); case 7: return pt(t, n, n.pendingProps, o), n.child; case 8: return pt(t, n, n.pendingProps.children, o), n.child; case 12: return pt(t, n, n.pendingProps.children, o), n.child; case 10: e: { if (l = n.type._context, d = n.pendingProps, m = n.memoizedProps, x = d.value, Me(ys, l._currentValue), l._currentValue = x, m !== null) if (Wt(m.value, x)) { if (m.children === d.children && !gt.current) { n = xn(t, n, o); break e } } else for (m = n.child, m !== null && (m.return = n); m !== null;) { var b = m.dependencies; if (b !== null) { x = m.child; for (var T = b.firstContext; T !== null;) { if (T.context === l) { if (m.tag === 1) { T = vn(-1, o & -o), T.tag = 2; var L = m.updateQueue; if (L !== null) { L = L.shared; var U = L.pending; U === null ? T.next = T : (T.next = U.next, U.next = T), L.pending = T } } m.lanes |= o, T = m.alternate, T !== null && (T.lanes |= o), Bl(m.return, o, n), b.lanes |= o; break } T = T.next } } else if (m.tag === 10) x = m.type === n.type ? null : m.child; else if (m.tag === 18) { if (x = m.return, x === null) throw Error(i(341)); x.lanes |= o, b = x.alternate, b !== null && (b.lanes |= o), Bl(x, o, n), x = m.sibling } else x = m.child; if (x !== null) x.return = m; else for (x = m; x !== null;) { if (x === n) { x = null; break } if (m = x.sibling, m !== null) { m.return = x.return, x = m; break } x = x.return } m = x } pt(t, n, d.children, o), n = n.child } return n; case 9: return d = n.type, l = n.pendingProps.children, Yr(n, o), d = Mt(d), l = l(d), n.flags |= 1, pt(t, n, l, o), n.child; case 14: return l = n.type, d = Ut(l, n.pendingProps), d = Ut(l.type, d), rh(t, n, l, d, o); case 15: return ih(t, n, n.type, n.pendingProps, o); case 17: return l = n.type, d = n.pendingProps, d = n.elementType === l ? d : Ut(l, d), js(t, n), n.tag = 1, yt(l) ? (t = !0, ds(n)) : t = !1, Yr(n, o), Xp(n, l, d), rc(n, l, d, o), ac(null, n, l, !0, t, o); case 19: return fh(t, n, o); case 22: return oh(t, n, o) }throw Error(i(156, n.tag)) }; function Lh(t, n) { return mf(t, n) } function u1(t, n, o, l) { this.tag = t, this.key = o, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = l, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function _t(t, n, o, l) { return new u1(t, n, o, l) } function Ec(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function d1(t) { if (typeof t == "function") return Ec(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === me) return 11; if (t === xe) return 14 } return 2 } function Un(t, n) { var o = t.alternate; return o === null ? (o = _t(t.tag, n, t.key, t.mode), o.elementType = t.elementType, o.type = t.type, o.stateNode = t.stateNode, o.alternate = t, t.alternate = o) : (o.pendingProps = n, o.type = t.type, o.flags = 0, o.subtreeFlags = 0, o.deletions = null), o.flags = t.flags & 14680064, o.childLanes = t.childLanes, o.lanes = t.lanes, o.child = t.child, o.memoizedProps = t.memoizedProps, o.memoizedState = t.memoizedState, o.updateQueue = t.updateQueue, n = t.dependencies, o.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, o.sibling = t.sibling, o.index = t.index, o.ref = t.ref, o } function zs(t, n, o, l, d, m) { var x = 2; if (l = t, typeof t == "function") Ec(t) && (x = 1); else if (typeof t == "string") x = 5; else e: switch (t) { case z: return gr(o.children, d, m, n); case F: x = 8, d |= 8; break; case Z: return t = _t(12, o, n, d | 2), t.elementType = Z, t.lanes = m, t; case ge: return t = _t(13, o, n, d), t.elementType = ge, t.lanes = m, t; case pe: return t = _t(19, o, n, d), t.elementType = pe, t.lanes = m, t; case q: return Bs(o, d, m, n); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case ie: x = 10; break e; case fe: x = 9; break e; case me: x = 11; break e; case xe: x = 14; break e; case se: x = 16, l = null; break e }throw Error(i(130, t == null ? t : typeof t, "")) }return n = _t(x, o, n, d), n.elementType = t, n.type = l, n.lanes = m, n } function gr(t, n, o, l) { return t = _t(7, t, l, n), t.lanes = o, t } function Bs(t, n, o, l) { return t = _t(22, t, l, n), t.elementType = q, t.lanes = o, t.stateNode = { isHidden: !1 }, t } function Tc(t, n, o) { return t = _t(6, t, null, n), t.lanes = o, t } function jc(t, n, o) { return n = _t(4, t.children !== null ? t.children : [], t.key, n), n.lanes = o, n.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, n } function f1(t, n, o, l, d) { this.tag = n, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = nl(0), this.expirationTimes = nl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = nl(0), this.identifierPrefix = l, this.onRecoverableError = d, this.mutableSourceEagerHydrationData = null } function Ac(t, n, o, l, d, m, x, b, T) { return t = new f1(t, n, o, b, T), n === 1 ? (n = 1, m === !0 && (n |= 8)) : n = 0, m = _t(3, null, null, n), t.current = m, m.stateNode = t, m.memoizedState = { element: l, isDehydrated: o, cache: null, transitions: null, pendingSuspenseBoundaries: null }, $l(m), t } function p1(t, n, o) { var l = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: B, key: l == null ? null : "" + l, children: t, containerInfo: n, implementation: o } } function Oh(t) { if (!t) return _n; t = t._reactInternals; e: { if (ir(t) !== t || t.tag !== 1) throw Error(i(170)); var n = t; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (yt(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(i(171)) } if (t.tag === 1) { var o = t.type; if (yt(o)) return dp(t, o, n) } return n } function Vh(t, n, o, l, d, m, x, b, T) { return t = Ac(o, l, !0, t, d, m, x, b, T), t.context = Oh(null), o = t.current, l = ht(), d = Wn(o), m = vn(l, d), m.callback = n ?? null, Vn(o, m, d), t.current.lanes = d, Ri(t, d, l), wt(t, l), t } function Ws(t, n, o, l) { var d = n.current, m = ht(), x = Wn(d); return o = Oh(o), n.context === null ? n.context = o : n.pendingContext = o, n = vn(m, x), n.payload = { element: t }, l = l === void 0 ? null : l, l !== null && (n.callback = l), t = Vn(d, n, x), t !== null && (Gt(t, d, x, m), xs(t, d, x)), x } function $s(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function Fh(t, n) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var o = t.retryLane; t.retryLane = o !== 0 && o < n ? o : n } } function Rc(t, n) { Fh(t, n), (t = t.alternate) && Fh(t, n) } function h1() { return null } var zh = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Mc(t) { this._internalRoot = t } Us.prototype.render = Mc.prototype.render = function (t) { var n = this._internalRoot; if (n === null) throw Error(i(409)); Ws(t, n, null, null) }, Us.prototype.unmount = Mc.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var n = t.containerInfo; pr(function () { Ws(null, t, null, null) }), n[pn] = null } }; function Us(t) { this._internalRoot = t } Us.prototype.unstable_scheduleHydration = function (t) { if (t) { var n = kf(); t = { blockedOn: null, target: t, priority: n }; for (var o = 0; o < An.length && n !== 0 && n < An[o].priority; o++); An.splice(o, 0, t), o === 0 && Pf(t) } }; function Ic(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Hs(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function Bh() { } function m1(t, n, o, l, d) { if (d) { if (typeof l == "function") { var m = l; l = function () { var L = $s(x); m.call(L) } } var x = Vh(n, l, t, 0, null, !1, !1, "", Bh); return t._reactRootContainer = x, t[pn] = x.current, Hi(t.nodeType === 8 ? t.parentNode : t), pr(), x } for (; d = t.lastChild;)t.removeChild(d); if (typeof l == "function") { var b = l; l = function () { var L = $s(T); b.call(L) } } var T = Ac(t, 0, !1, null, null, !1, !1, "", Bh); return t._reactRootContainer = T, t[pn] = T.current, Hi(t.nodeType === 8 ? t.parentNode : t), pr(function () { Ws(n, T, o, l) }), T } function Ks(t, n, o, l, d) { var m = o._reactRootContainer; if (m) { var x = m; if (typeof d == "function") { var b = d; d = function () { var T = $s(x); b.call(T) } } Ws(n, x, t, d) } else x = m1(o, n, t, d, l); return $s(x) } Sf = function (t) { switch (t.tag) { case 3: var n = t.stateNode; if (n.current.memoizedState.isDehydrated) { var o = Ai(n.pendingLanes); o !== 0 && (rl(n, o | 1), wt(n, Ue()), (Ee & 6) === 0 && (Jr = Ue() + 500, Ln())) } break; case 13: pr(function () { var l = yn(t, 1); if (l !== null) { var d = ht(); Gt(l, t, 1, d) } }), Rc(t, 1) } }, il = function (t) { if (t.tag === 13) { var n = yn(t, 134217728); if (n !== null) { var o = ht(); Gt(n, t, 134217728, o) } Rc(t, 134217728) } }, Cf = function (t) { if (t.tag === 13) { var n = Wn(t), o = yn(t, n); if (o !== null) { var l = ht(); Gt(o, t, n, l) } Rc(t, n) } }, kf = function () { return Ae }, bf = function (t, n) { var o = Ae; try { return Ae = t, n() } finally { Ae = o } }, qa = function (t, n, o) { switch (n) { case "input": if (rr(t, o), n = o.name, o.type === "radio" && n != null) { for (o = t; o.parentNode;)o = o.parentNode; for (o = o.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < o.length; n++) { var l = o[n]; if (l !== t && l.form === t.form) { var d = cs(l); if (!d) throw Error(i(90)); Re(l), rr(l, d) } } } break; case "textarea": Zd(t, o); break; case "select": n = o.value, n != null && Ar(t, !!o.multiple, n, !1) } }, lf = bc, cf = pr; var g1 = { usingClientEntryPoint: !1, Events: [Yi, zr, cs, sf, af, bc] }, lo = { findFiberByHostInstance: or, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, y1 = { bundleType: lo.bundleType, version: lo.version, rendererPackageName: lo.rendererPackageName, rendererConfig: lo.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: O.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = pf(t), t === null ? null : t.stateNode }, findFiberByHostInstance: lo.findFiberByHostInstance || h1, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Gs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Gs.isDisabled && Gs.supportsFiber) try { Uo = Gs.inject(y1), en = Gs } catch { } } return St.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = g1, St.createPortal = function (t, n) { var o = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Ic(n)) throw Error(i(200)); return p1(t, n, null, o) }, St.createRoot = function (t, n) { if (!Ic(t)) throw Error(i(299)); var o = !1, l = "", d = zh; return n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (l = n.identifierPrefix), n.onRecoverableError !== void 0 && (d = n.onRecoverableError)), n = Ac(t, 1, !1, null, null, o, !1, l, d), t[pn] = n.current, Hi(t.nodeType === 8 ? t.parentNode : t), new Mc(n) }, St.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var n = t._reactInternals; if (n === void 0) throw typeof t.render == "function" ? Error(i(188)) : (t = Object.keys(t).join(","), Error(i(268, t))); return t = pf(n), t = t === null ? null : t.stateNode, t }, St.flushSync = function (t) { return pr(t) }, St.hydrate = function (t, n, o) { if (!Hs(n)) throw Error(i(200)); return Ks(null, t, n, !0, o) }, St.hydrateRoot = function (t, n, o) { if (!Ic(t)) throw Error(i(405)); var l = o != null && o.hydratedSources || null, d = !1, m = "", x = zh; if (o != null && (o.unstable_strictMode === !0 && (d = !0), o.identifierPrefix !== void 0 && (m = o.identifierPrefix), o.onRecoverableError !== void 0 && (x = o.onRecoverableError)), n = Vh(n, null, t, 1, o ?? null, d, !1, m, x), t[pn] = n.current, Hi(t), l) for (t = 0; t < l.length; t++)o = l[t], d = o._getVersion, d = d(o._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [o, d] : n.mutableSourceEagerHydrationData.push(o, d); return new Us(n) }, St.render = function (t, n, o) { if (!Hs(n)) throw Error(i(200)); return Ks(null, t, n, !1, o) }, St.unmountComponentAtNode = function (t) { if (!Hs(t)) throw Error(i(40)); return t._reactRootContainer ? (pr(function () { Ks(null, null, t, !1, function () { t._reactRootContainer = null, t[pn] = null }) }), !0) : !1 }, St.unstable_batchedUpdates = bc, St.unstable_renderSubtreeIntoContainer = function (t, n, o, l) { if (!Hs(o)) throw Error(i(200)); if (t == null || t._reactInternals === void 0) throw Error(i(38)); return Ks(t, n, o, !1, l) }, St.version = "18.3.1-next-f1338f8080-20240426", St
} var Xh; function Kg() { if (Xh) return Lc.exports; Xh = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (r) { console.error(r) } } return e(), Lc.exports = N1(), Lc.exports } var qh; function P1() { if (qh) return Ys; qh = 1; var e = Kg(); return Ys.createRoot = e.createRoot, Ys.hydrateRoot = e.hydrateRoot, Ys } var E1 = P1(), w = Zu(); const Ke = Hg(w), Ju = x1({ __proto__: null, default: Ke }, [w]), ed = w.createContext({}); function td(e) { const r = w.useRef(null); return r.current === null && (r.current = e()), r.current } const nd = typeof window < "u", Gg = nd ? w.useLayoutEffect : w.useEffect, Ta = w.createContext(null); function rd(e, r) { e.indexOf(r) === -1 && e.push(r) } function id(e, r) { const i = e.indexOf(r); i > -1 && e.splice(i, 1) } const kn = (e, r, i) => i > r ? r : i < e ? e : i; let od = () => { }; const bn = {}, Yg = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); function Xg(e) { return typeof e == "object" && e !== null } const qg = e => /^0[^.\s]+$/u.test(e); function sd(e) { let r; return () => (r === void 0 && (r = e()), r) } const Vt = e => e, T1 = (e, r) => i => r(e(i)), jo = (...e) => e.reduce(T1), So = (e, r, i) => { const s = r - e; return s === 0 ? 1 : (i - e) / s }; class ad { constructor() { this.subscriptions = [] } add(r) { return rd(this.subscriptions, r), () => id(this.subscriptions, r) } notify(r, i, s) { const a = this.subscriptions.length; if (a) if (a === 1) this.subscriptions[0](r, i, s); else for (let c = 0; c < a; c++) { const u = this.subscriptions[c]; u && u(r, i, s) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const ln = e => e * 1e3, Ot = e => e / 1e3; function Qg(e, r) { return r ? e * (1e3 / r) : 0 } const Zg = (e, r, i) => (((1 - 3 * i + 3 * r) * e + (3 * i - 6 * r)) * e + 3 * r) * e, j1 = 1e-7, A1 = 12; function R1(e, r, i, s, a) { let c, u, f = 0; do u = r + (i - r) / 2, c = Zg(u, s, a) - e, c > 0 ? i = u : r = u; while (Math.abs(c) > j1 && ++f < A1); return u } function Ao(e, r, i, s) { if (e === r && i === s) return Vt; const a = c => R1(c, 0, 1, e, i); return c => c === 0 || c === 1 ? c : Zg(a(c), r, s) } const Jg = e => r => r <= .5 ? e(2 * r) / 2 : (2 - e(2 * (1 - r))) / 2, ey = e => r => 1 - e(1 - r), ty = Ao(.33, 1.53, .69, .99), ld = ey(ty), ny = Jg(ld), ry = e => (e *= 2) < 1 ? .5 * ld(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), cd = e => 1 - Math.sin(Math.acos(e)), iy = ey(cd), oy = Jg(cd), M1 = Ao(.42, 0, 1, 1), I1 = Ao(0, 0, .58, 1), sy = Ao(.42, 0, .58, 1), D1 = e => Array.isArray(e) && typeof e[0] != "number", ay = e => Array.isArray(e) && typeof e[0] == "number", _1 = { linear: Vt, easeIn: M1, easeInOut: sy, easeOut: I1, circIn: cd, circInOut: oy, circOut: iy, backIn: ld, backInOut: ny, backOut: ty, anticipate: ry }, L1 = e => typeof e == "string", Qh = e => { if (ay(e)) { od(e.length === 4); const [r, i, s, a] = e; return Ao(r, i, s, a) } else if (L1(e)) return _1[e]; return e }, Xs = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function O1(e, r) { let i = new Set, s = new Set, a = !1, c = !1; const u = new WeakSet; let f = { delta: 0, timestamp: 0, isProcessing: !1 }; function h(y) { u.has(y) && (g.schedule(y), e()), y(f) } const g = { schedule: (y, v = !1, S = !1) => { const P = S && a ? i : s; return v && u.add(y), P.has(y) || P.add(y), y }, cancel: y => { s.delete(y), u.delete(y) }, process: y => { if (f = y, a) { c = !0; return } a = !0, [i, s] = [s, i], i.forEach(h), i.clear(), a = !1, c && (c = !1, g.process(y)) } }; return g } const V1 = 40; function ly(e, r) { let i = !1, s = !0; const a = { delta: 0, timestamp: 0, isProcessing: !1 }, c = () => i = !0, u = Xs.reduce((R, O) => (R[O] = O1(c), R), {}), { setup: f, read: h, resolveKeyframes: g, preUpdate: y, update: v, preRender: S, render: k, postRender: P } = u, C = () => { const R = bn.useManualTiming ? a.timestamp : performance.now(); i = !1, bn.useManualTiming || (a.delta = s ? 1e3 / 60 : Math.max(Math.min(R - a.timestamp, V1), 1)), a.timestamp = R, a.isProcessing = !0, f.process(a), h.process(a), g.process(a), y.process(a), v.process(a), S.process(a), k.process(a), P.process(a), a.isProcessing = !1, i && r && (s = !1, e(C)) }, N = () => { i = !0, s = !0, a.isProcessing || e(C) }; return { schedule: Xs.reduce((R, O) => { const V = u[O]; return R[O] = (B, z = !1, F = !1) => (i || N(), V.schedule(B, z, F)), R }, {}), cancel: R => { for (let O = 0; O < Xs.length; O++)u[Xs[O]].cancel(R) }, state: a, steps: u } } const { schedule: Oe, cancel: qn, state: st, steps: Fc } = ly(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Vt, !0); let aa; function F1() { aa = void 0 } const Ct = { now: () => (aa === void 0 && Ct.set(st.isProcessing || bn.useManualTiming ? st.timestamp : performance.now()), aa), set: e => { aa = e, queueMicrotask(F1) } }, cy = e => r => typeof r == "string" && r.startsWith(e), uy = cy("--"), z1 = cy("var(--"), ud = e => z1(e) ? B1.test(e.split("/*")[0].trim()) : !1, B1 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, gi = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Co = { ...gi, transform: e => kn(0, 1, e) }, qs = { ...gi, default: 1 }, go = e => Math.round(e * 1e5) / 1e5, dd = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function W1(e) { return e == null } const $1 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, fd = (e, r) => i => !!(typeof i == "string" && $1.test(i) && i.startsWith(e) || r && !W1(i) && Object.prototype.hasOwnProperty.call(i, r)), dy = (e, r, i) => s => { if (typeof s != "string") return s; const [a, c, u, f] = s.match(dd); return { [e]: parseFloat(a), [r]: parseFloat(c), [i]: parseFloat(u), alpha: f !== void 0 ? parseFloat(f) : 1 } }, U1 = e => kn(0, 255, e), zc = { ...gi, transform: e => Math.round(U1(e)) }, wr = { test: fd("rgb", "red"), parse: dy("red", "green", "blue"), transform: ({ red: e, green: r, blue: i, alpha: s = 1 }) => "rgba(" + zc.transform(e) + ", " + zc.transform(r) + ", " + zc.transform(i) + ", " + go(Co.transform(s)) + ")" }; function H1(e) { let r = "", i = "", s = "", a = ""; return e.length > 5 ? (r = e.substring(1, 3), i = e.substring(3, 5), s = e.substring(5, 7), a = e.substring(7, 9)) : (r = e.substring(1, 2), i = e.substring(2, 3), s = e.substring(3, 4), a = e.substring(4, 5), r += r, i += i, s += s, a += a), { red: parseInt(r, 16), green: parseInt(i, 16), blue: parseInt(s, 16), alpha: a ? parseInt(a, 16) / 255 : 1 } } const yu = { test: fd("#"), parse: H1, transform: wr.transform }, Ro = e => ({ test: r => typeof r == "string" && r.endsWith(e) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${e}` }), Gn = Ro("deg"), cn = Ro("%"), he = Ro("px"), K1 = Ro("vh"), G1 = Ro("vw"), Zh = { ...cn, parse: e => cn.parse(e) / 100, transform: e => cn.transform(e * 100) }, oi = { test: fd("hsl", "hue"), parse: dy("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: r, lightness: i, alpha: s = 1 }) => "hsla(" + Math.round(e) + ", " + cn.transform(go(r)) + ", " + cn.transform(go(i)) + ", " + go(Co.transform(s)) + ")" }, Ye = { test: e => wr.test(e) || yu.test(e) || oi.test(e), parse: e => wr.test(e) ? wr.parse(e) : oi.test(e) ? oi.parse(e) : yu.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? wr.transform(e) : oi.transform(e), getAnimatableNone: e => { const r = Ye.parse(e); return r.alpha = 0, Ye.transform(r) } }, Y1 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function X1(e) { return isNaN(e) && typeof e == "string" && (e.match(dd)?.length || 0) + (e.match(Y1)?.length || 0) > 0 } const fy = "number", py = "color", q1 = "var", Q1 = "var(", Jh = "${}", Z1 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function ko(e) { const r = e.toString(), i = [], s = { color: [], number: [], var: [] }, a = []; let c = 0; const f = r.replace(Z1, h => (Ye.test(h) ? (s.color.push(c), a.push(py), i.push(Ye.parse(h))) : h.startsWith(Q1) ? (s.var.push(c), a.push(q1), i.push(h)) : (s.number.push(c), a.push(fy), i.push(parseFloat(h))), ++c, Jh)).split(Jh); return { values: i, split: f, indexes: s, types: a } } function hy(e) { return ko(e).values } function my(e) { const { split: r, types: i } = ko(e), s = r.length; return a => { let c = ""; for (let u = 0; u < s; u++)if (c += r[u], a[u] !== void 0) { const f = i[u]; f === fy ? c += go(a[u]) : f === py ? c += Ye.transform(a[u]) : c += a[u] } return c } } const J1 = e => typeof e == "number" ? 0 : Ye.test(e) ? Ye.getAnimatableNone(e) : e; function eS(e) { const r = hy(e); return my(e)(r.map(J1)) } const Qn = { test: X1, parse: hy, createTransformer: my, getAnimatableNone: eS }; function Bc(e, r, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (r - e) * 6 * i : i < 1 / 2 ? r : i < 2 / 3 ? e + (r - e) * (2 / 3 - i) * 6 : e } function tS({ hue: e, saturation: r, lightness: i, alpha: s }) { e /= 360, r /= 100, i /= 100; let a = 0, c = 0, u = 0; if (!r) a = c = u = i; else { const f = i < .5 ? i * (1 + r) : i + r - i * r, h = 2 * i - f; a = Bc(h, f, e + 1 / 3), c = Bc(h, f, e), u = Bc(h, f, e - 1 / 3) } return { red: Math.round(a * 255), green: Math.round(c * 255), blue: Math.round(u * 255), alpha: s } } function ha(e, r) { return i => i > 0 ? r : e } const ze = (e, r, i) => e + (r - e) * i, Wc = (e, r, i) => { const s = e * e, a = i * (r * r - s) + s; return a < 0 ? 0 : Math.sqrt(a) }, nS = [yu, wr, oi], rS = e => nS.find(r => r.test(e)); function em(e) { const r = rS(e); if (!r) return !1; let i = r.parse(e); return r === oi && (i = tS(i)), i } const tm = (e, r) => { const i = em(e), s = em(r); if (!i || !s) return ha(e, r); const a = { ...i }; return c => (a.red = Wc(i.red, s.red, c), a.green = Wc(i.green, s.green, c), a.blue = Wc(i.blue, s.blue, c), a.alpha = ze(i.alpha, s.alpha, c), wr.transform(a)) }, vu = new Set(["none", "hidden"]); function iS(e, r) { return vu.has(e) ? i => i <= 0 ? e : r : i => i >= 1 ? r : e } function oS(e, r) { return i => ze(e, r, i) } function pd(e) { return typeof e == "number" ? oS : typeof e == "string" ? ud(e) ? ha : Ye.test(e) ? tm : lS : Array.isArray(e) ? gy : typeof e == "object" ? Ye.test(e) ? tm : sS : ha } function gy(e, r) { const i = [...e], s = i.length, a = e.map((c, u) => pd(c)(c, r[u])); return c => { for (let u = 0; u < s; u++)i[u] = a[u](c); return i } } function sS(e, r) { const i = { ...e, ...r }, s = {}; for (const a in i) e[a] !== void 0 && r[a] !== void 0 && (s[a] = pd(e[a])(e[a], r[a])); return a => { for (const c in s) i[c] = s[c](a); return i } } function aS(e, r) { const i = [], s = { color: 0, var: 0, number: 0 }; for (let a = 0; a < r.values.length; a++) { const c = r.types[a], u = e.indexes[c][s[c]], f = e.values[u] ?? 0; i[a] = f, s[c]++ } return i } const lS = (e, r) => { const i = Qn.createTransformer(r), s = ko(e), a = ko(r); return s.indexes.var.length === a.indexes.var.length && s.indexes.color.length === a.indexes.color.length && s.indexes.number.length >= a.indexes.number.length ? vu.has(e) && !a.values.length || vu.has(r) && !s.values.length ? iS(e, r) : jo(gy(aS(s, a), a.values), i) : ha(e, r) }; function yy(e, r, i) { return typeof e == "number" && typeof r == "number" && typeof i == "number" ? ze(e, r, i) : pd(e)(e, r) } const cS = e => { const r = ({ timestamp: i }) => e(i); return { start: (i = !0) => Oe.update(r, i), stop: () => qn(r), now: () => st.isProcessing ? st.timestamp : Ct.now() } }, vy = (e, r, i = 10) => { let s = ""; const a = Math.max(Math.round(r / i), 2); for (let c = 0; c < a; c++)s += Math.round(e(c / (a - 1)) * 1e4) / 1e4 + ", "; return `linear(${s.substring(0, s.length - 2)})` }, ma = 2e4; function hd(e) { let r = 0; const i = 50; let s = e.next(r); for (; !s.done && r < ma;)r += i, s = e.next(r); return r >= ma ? 1 / 0 : r } function uS(e, r = 100, i) { const s = i({ ...e, keyframes: [0, r] }), a = Math.min(hd(s), ma); return { type: "keyframes", ease: c => s.next(a * c).value / r, duration: Ot(a) } } const dS = 5; function xy(e, r, i) { const s = Math.max(r - dS, 0); return Qg(i - e(s), r - s) } const We = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, $c = .001; function fS({ duration: e = We.duration, bounce: r = We.bounce, velocity: i = We.velocity, mass: s = We.mass }) { let a, c, u = 1 - r; u = kn(We.minDamping, We.maxDamping, u), e = kn(We.minDuration, We.maxDuration, Ot(e)), u < 1 ? (a = g => { const y = g * u, v = y * e, S = y - i, k = xu(g, u), P = Math.exp(-v); return $c - S / k * P }, c = g => { const v = g * u * e, S = v * i + i, k = Math.pow(u, 2) * Math.pow(g, 2) * e, P = Math.exp(-v), C = xu(Math.pow(g, 2), u); return (-a(g) + $c > 0 ? -1 : 1) * ((S - k) * P) / C }) : (a = g => { const y = Math.exp(-g * e), v = (g - i) * e + 1; return -$c + y * v }, c = g => { const y = Math.exp(-g * e), v = (i - g) * (e * e); return y * v }); const f = 5 / e, h = hS(a, c, f); if (e = ln(e), isNaN(h)) return { stiffness: We.stiffness, damping: We.damping, duration: e }; { const g = Math.pow(h, 2) * s; return { stiffness: g, damping: u * 2 * Math.sqrt(s * g), duration: e } } } const pS = 12; function hS(e, r, i) { let s = i; for (let a = 1; a < pS; a++)s = s - e(s) / r(s); return s } function xu(e, r) { return e * Math.sqrt(1 - r * r) } const mS = ["duration", "bounce"], gS = ["stiffness", "damping", "mass"]; function nm(e, r) { return r.some(i => e[i] !== void 0) } function yS(e) { let r = { velocity: We.velocity, stiffness: We.stiffness, damping: We.damping, mass: We.mass, isResolvedFromDuration: !1, ...e }; if (!nm(e, gS) && nm(e, mS)) if (e.visualDuration) { const i = e.visualDuration, s = 2 * Math.PI / (i * 1.2), a = s * s, c = 2 * kn(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(a); r = { ...r, mass: We.mass, stiffness: a, damping: c } } else { const i = fS(e); r = { ...r, ...i, mass: We.mass }, r.isResolvedFromDuration = !0 } return r } function ga(e = We.visualDuration, r = We.bounce) { const i = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: r } : e; let { restSpeed: s, restDelta: a } = i; const c = i.keyframes[0], u = i.keyframes[i.keyframes.length - 1], f = { done: !1, value: c }, { stiffness: h, damping: g, mass: y, duration: v, velocity: S, isResolvedFromDuration: k } = yS({ ...i, velocity: -Ot(i.velocity || 0) }), P = S || 0, C = g / (2 * Math.sqrt(h * y)), N = u - c, j = Ot(Math.sqrt(h / y)), E = Math.abs(N) < 5; s || (s = E ? We.restSpeed.granular : We.restSpeed.default), a || (a = E ? We.restDelta.granular : We.restDelta.default); let R; if (C < 1) { const V = xu(j, C); R = B => { const z = Math.exp(-C * j * B); return u - z * ((P + C * j * N) / V * Math.sin(V * B) + N * Math.cos(V * B)) } } else if (C === 1) R = V => u - Math.exp(-j * V) * (N + (P + j * N) * V); else { const V = j * Math.sqrt(C * C - 1); R = B => { const z = Math.exp(-C * j * B), F = Math.min(V * B, 300); return u - z * ((P + C * j * N) * Math.sinh(F) + V * N * Math.cosh(F)) / V } } const O = { calculatedDuration: k && v || null, next: V => { const B = R(V); if (k) f.done = V >= v; else { let z = V === 0 ? P : 0; C < 1 && (z = V === 0 ? ln(P) : xy(R, V, B)); const F = Math.abs(z) <= s, Z = Math.abs(u - B) <= a; f.done = F && Z } return f.value = f.done ? u : B, f }, toString: () => { const V = Math.min(hd(O), ma), B = vy(z => O.next(V * z).value, V, 30); return V + "ms " + B }, toTransition: () => { } }; return O } ga.applyToOptions = e => { const r = uS(e, 100, ga); return e.ease = r.ease, e.duration = ln(r.duration), e.type = "keyframes", e }; function wu({ keyframes: e, velocity: r = 0, power: i = .8, timeConstant: s = 325, bounceDamping: a = 10, bounceStiffness: c = 500, modifyTarget: u, min: f, max: h, restDelta: g = .5, restSpeed: y }) { const v = e[0], S = { done: !1, value: v }, k = F => f !== void 0 && F < f || h !== void 0 && F > h, P = F => f === void 0 ? h : h === void 0 || Math.abs(f - F) < Math.abs(h - F) ? f : h; let C = i * r; const N = v + C, j = u === void 0 ? N : u(N); j !== N && (C = j - v); const E = F => -C * Math.exp(-F / s), R = F => j + E(F), O = F => { const Z = E(F), ie = R(F); S.done = Math.abs(Z) <= g, S.value = S.done ? j : ie }; let V, B; const z = F => { k(S.value) && (V = F, B = ga({ keyframes: [S.value, P(S.value)], velocity: xy(R, F, S.value), damping: a, stiffness: c, restDelta: g, restSpeed: y })) }; return z(0), { calculatedDuration: null, next: F => { let Z = !1; return !B && V === void 0 && (Z = !0, O(F), z(F)), V !== void 0 && F >= V ? B.next(F - V) : (!Z && O(F), S) } } } function vS(e, r, i) { const s = [], a = i || bn.mix || yy, c = e.length - 1; for (let u = 0; u < c; u++) { let f = a(e[u], e[u + 1]); if (r) { const h = Array.isArray(r) ? r[u] || Vt : r; f = jo(h, f) } s.push(f) } return s } function xS(e, r, { clamp: i = !0, ease: s, mixer: a } = {}) { const c = e.length; if (od(c === r.length), c === 1) return () => r[0]; if (c === 2 && r[0] === r[1]) return () => r[1]; const u = e[0] === e[1]; e[0] > e[c - 1] && (e = [...e].reverse(), r = [...r].reverse()); const f = vS(r, s, a), h = f.length, g = y => { if (u && y < e[0]) return r[0]; let v = 0; if (h > 1) for (; v < e.length - 2 && !(y < e[v + 1]); v++); const S = So(e[v], e[v + 1], y); return f[v](S) }; return i ? y => g(kn(e[0], e[c - 1], y)) : g } function wS(e, r) { const i = e[e.length - 1]; for (let s = 1; s <= r; s++) { const a = So(0, r, s); e.push(ze(i, 1, a)) } } function SS(e) { const r = [0]; return wS(r, e.length - 1), r } function CS(e, r) { return e.map(i => i * r) } function kS(e, r) { return e.map(() => r || sy).splice(0, e.length - 1) } function yo({ duration: e = 300, keyframes: r, times: i, ease: s = "easeInOut" }) { const a = D1(s) ? s.map(Qh) : Qh(s), c = { done: !1, value: r[0] }, u = CS(i && i.length === r.length ? i : SS(r), e), f = xS(u, r, { ease: Array.isArray(a) ? a : kS(r, a) }); return { calculatedDuration: e, next: h => (c.value = f(h), c.done = h >= e, c) } } const bS = e => e !== null; function md(e, { repeat: r, repeatType: i = "loop" }, s, a = 1) { const c = e.filter(bS), f = a < 0 || r && i !== "loop" && r % 2 === 1 ? 0 : c.length - 1; return !f || s === void 0 ? c[f] : s } const NS = { decay: wu, inertia: wu, tween: yo, keyframes: yo, spring: ga }; function wy(e) { typeof e.type == "string" && (e.type = NS[e.type]) } class gd { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(r => { this.resolve = r }) } notifyFinished() { this.resolve() } then(r, i) { return this.finished.then(r, i) } } const PS = e => e / 100; class yd extends gd { constructor(r) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: i } = this.options; i && i.updatedAt !== Ct.now() && this.tick(Ct.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = r, this.initAnimation(), this.play(), r.autoplay === !1 && this.pause() } initAnimation() { const { options: r } = this; wy(r); const { type: i = yo, repeat: s = 0, repeatDelay: a = 0, repeatType: c, velocity: u = 0 } = r; let { keyframes: f } = r; const h = i || yo; h !== yo && typeof f[0] != "number" && (this.mixKeyframes = jo(PS, yy(f[0], f[1])), f = [0, 100]); const g = h({ ...r, keyframes: f }); c === "mirror" && (this.mirroredGenerator = h({ ...r, keyframes: [...f].reverse(), velocity: -u })), g.calculatedDuration === null && (g.calculatedDuration = hd(g)); const { calculatedDuration: y } = g; this.calculatedDuration = y, this.resolvedDuration = y + a, this.totalDuration = this.resolvedDuration * (s + 1) - a, this.generator = g } updateTime(r) { const i = Math.round(r - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = i } tick(r, i = !1) { const { generator: s, totalDuration: a, mixKeyframes: c, mirroredGenerator: u, resolvedDuration: f, calculatedDuration: h } = this; if (this.startTime === null) return s.next(0); const { delay: g = 0, keyframes: y, repeat: v, repeatType: S, repeatDelay: k, type: P, onUpdate: C, finalKeyframe: N } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - a / this.speed, this.startTime)), i ? this.currentTime = r : this.updateTime(r); const j = this.currentTime - g * (this.playbackSpeed >= 0 ? 1 : -1), E = this.playbackSpeed >= 0 ? j < 0 : j > a; this.currentTime = Math.max(j, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = a); let R = this.currentTime, O = s; if (v) { const F = Math.min(this.currentTime, a) / f; let Z = Math.floor(F), ie = F % 1; !ie && F >= 1 && (ie = 1), ie === 1 && Z--, Z = Math.min(Z, v + 1), !!(Z % 2) && (S === "reverse" ? (ie = 1 - ie, k && (ie -= k / f)) : S === "mirror" && (O = u)), R = kn(0, 1, ie) * f } const V = E ? { done: !1, value: y[0] } : O.next(R); c && (V.value = c(V.value)); let { done: B } = V; !E && h !== null && (B = this.playbackSpeed >= 0 ? this.currentTime >= a : this.currentTime <= 0); const z = this.holdTime === null && (this.state === "finished" || this.state === "running" && B); return z && P !== wu && (V.value = md(y, this.options, N, this.speed)), C && C(V.value), z && this.finish(), V } then(r, i) { return this.finished.then(r, i) } get duration() { return Ot(this.calculatedDuration) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Ot(r) } get time() { return Ot(this.currentTime) } set time(r) { r = ln(r), this.currentTime = r, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(r) { this.updateTime(Ct.now()); const i = this.playbackSpeed !== r; this.playbackSpeed = r, i && (this.time = Ot(this.currentTime)) } play() { if (this.isStopped) return; const { driver: r = cS, startTime: i } = this.options; this.driver || (this.driver = r(a => this.tick(a))), this.options.onPlay?.(); const s = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = i ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(Ct.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } attachTimeline(r) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), r.observe(this) } } function ES(e) { for (let r = 1; r < e.length; r++)e[r] ?? (e[r] = e[r - 1]) } const Sr = e => e * 180 / Math.PI, Su = e => { const r = Sr(Math.atan2(e[1], e[0])); return Cu(r) }, TS = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2, rotate: Su, rotateZ: Su, skewX: e => Sr(Math.atan(e[1])), skewY: e => Sr(Math.atan(e[2])), skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2 }, Cu = e => (e = e % 360, e < 0 && (e += 360), e), rm = Su, im = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]), om = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]), jS = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: im, scaleY: om, scale: e => (im(e) + om(e)) / 2, rotateX: e => Cu(Sr(Math.atan2(e[6], e[5]))), rotateY: e => Cu(Sr(Math.atan2(-e[2], e[0]))), rotateZ: rm, rotate: rm, skewX: e => Sr(Math.atan(e[4])), skewY: e => Sr(Math.atan(e[1])), skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2 }; function ku(e) { return e.includes("scale") ? 1 : 0 } function bu(e, r) { if (!e || e === "none") return ku(r); const i = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let s, a; if (i) s = jS, a = i; else { const f = e.match(/^matrix\(([-\d.e\s,]+)\)$/u); s = TS, a = f } if (!a) return ku(r); const c = s[r], u = a[1].split(",").map(RS); return typeof c == "function" ? c(u) : u[c] } const AS = (e, r) => { const { transform: i = "none" } = getComputedStyle(e); return bu(i, r) }; function RS(e) { return parseFloat(e.trim()) } const yi = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], vi = new Set(yi), sm = e => e === gi || e === he, MS = new Set(["x", "y", "z"]), IS = yi.filter(e => !MS.has(e)); function DS(e) { const r = []; return IS.forEach(i => { const s = e.getValue(i); s !== void 0 && (r.push([i, s.get()]), s.set(i.startsWith("scale") ? 1 : 0)) }), r } const Cr = { width: ({ x: e }, { paddingLeft: r = "0", paddingRight: i = "0" }) => e.max - e.min - parseFloat(r) - parseFloat(i), height: ({ y: e }, { paddingTop: r = "0", paddingBottom: i = "0" }) => e.max - e.min - parseFloat(r) - parseFloat(i), top: (e, { top: r }) => parseFloat(r), left: (e, { left: r }) => parseFloat(r), bottom: ({ y: e }, { top: r }) => parseFloat(r) + (e.max - e.min), right: ({ x: e }, { left: r }) => parseFloat(r) + (e.max - e.min), x: (e, { transform: r }) => bu(r, "x"), y: (e, { transform: r }) => bu(r, "y") }; Cr.translateX = Cr.x; Cr.translateY = Cr.y; const kr = new Set; let Nu = !1, Pu = !1, Eu = !1; function Sy() { if (Pu) { const e = Array.from(kr).filter(s => s.needsMeasurement), r = new Set(e.map(s => s.element)), i = new Map; r.forEach(s => { const a = DS(s); a.length && (i.set(s, a), s.render()) }), e.forEach(s => s.measureInitialState()), r.forEach(s => { s.render(); const a = i.get(s); a && a.forEach(([c, u]) => { s.getValue(c)?.set(u) }) }), e.forEach(s => s.measureEndState()), e.forEach(s => { s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY) }) } Pu = !1, Nu = !1, kr.forEach(e => e.complete(Eu)), kr.clear() } function Cy() { kr.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Pu = !0) }) } function _S() { Eu = !0, Cy(), Sy(), Eu = !1 } class vd { constructor(r, i, s, a, c, u = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...r], this.onComplete = i, this.name = s, this.motionValue = a, this.element = c, this.isAsync = u } scheduleResolve() { this.state = "scheduled", this.isAsync ? (kr.add(this), Nu || (Nu = !0, Oe.read(Cy), Oe.resolveKeyframes(Sy))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: i, element: s, motionValue: a } = this; if (r[0] === null) { const c = a?.get(), u = r[r.length - 1]; if (c !== void 0) r[0] = c; else if (s && i) { const f = s.readValue(i, u); f != null && (r[0] = f) } r[0] === void 0 && (r[0] = u), a && c === void 0 && a.set(r[0]) } ES(r) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(r = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, r), kr.delete(this) } cancel() { this.state === "scheduled" && (kr.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const LS = e => e.startsWith("--"); function OS(e, r, i) { LS(r) ? e.style.setProperty(r, i) : e.style[r] = i } const VS = sd(() => window.ScrollTimeline !== void 0), FS = {}; function zS(e, r) { const i = sd(e); return () => FS[r] ?? i() } const ky = zS(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), ho = ([e, r, i, s]) => `cubic-bezier(${e}, ${r}, ${i}, ${s})`, am = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ho([0, .65, .55, 1]), circOut: ho([.55, 0, 1, .45]), backIn: ho([.31, .01, .66, -.59]), backOut: ho([.33, 1.53, .69, .99]) }; function by(e, r) { if (e) return typeof e == "function" ? ky() ? vy(e, r) : "ease-out" : ay(e) ? ho(e) : Array.isArray(e) ? e.map(i => by(i, r) || am.easeOut) : am[e] } function BS(e, r, i, { delay: s = 0, duration: a = 300, repeat: c = 0, repeatType: u = "loop", ease: f = "easeOut", times: h } = {}, g = void 0) { const y = { [r]: i }; h && (y.offset = h); const v = by(f, a); Array.isArray(v) && (y.easing = v); const S = { delay: s, duration: a, easing: Array.isArray(v) ? "linear" : v, fill: "both", iterations: c + 1, direction: u === "reverse" ? "alternate" : "normal" }; return g && (S.pseudoElement = g), e.animate(y, S) } function Ny(e) { return typeof e == "function" && "applyToOptions" in e } function WS({ type: e, ...r }) { return Ny(e) && ky() ? e.applyToOptions(r) : (r.duration ?? (r.duration = 300), r.ease ?? (r.ease = "easeOut"), r) } class $S extends gd { constructor(r) { if (super(), this.finishedTime = null, this.isStopped = !1, !r) return; const { element: i, name: s, keyframes: a, pseudoElement: c, allowFlatten: u = !1, finalKeyframe: f, onComplete: h } = r; this.isPseudoElement = !!c, this.allowFlatten = u, this.options = r, od(typeof r.type != "string"); const g = WS(r); this.animation = BS(i, s, a, g, c), g.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !c) { const y = md(a, this.options, f, this.speed); this.updateMotionValue ? this.updateMotionValue(y) : OS(i, s, y), this.animation.cancel() } h?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: r } = this; r === "idle" || r === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const r = this.animation.effect?.getComputedTiming?.().duration || 0; return Ot(Number(r)) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Ot(r) } get time() { return Ot(Number(this.animation.currentTime) || 0) } set time(r) { this.finishedTime = null, this.animation.currentTime = ln(r) } get speed() { return this.animation.playbackRate } set speed(r) { r < 0 && (this.finishedTime = null), this.animation.playbackRate = r } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(r) { this.animation.startTime = r } attachTimeline({ timeline: r, observe: i }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, r && VS() ? (this.animation.timeline = r, Vt) : i(this) } } const Py = { anticipate: ry, backInOut: ny, circInOut: oy }; function US(e) { return e in Py } function HS(e) { typeof e.ease == "string" && US(e.ease) && (e.ease = Py[e.ease]) } const lm = 10; class KS extends $S { constructor(r) { HS(r), wy(r), super(r), r.startTime && (this.startTime = r.startTime), this.options = r } updateMotionValue(r) { const { motionValue: i, onUpdate: s, onComplete: a, element: c, ...u } = this.options; if (!i) return; if (r !== void 0) { i.set(r); return } const f = new yd({ ...u, autoplay: !1 }), h = ln(this.finishedTime ?? this.time); i.setWithVelocity(f.sample(h - lm).value, f.sample(h).value, lm), f.stop() } } const cm = (e, r) => r === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Qn.test(e) || e === "0") && !e.startsWith("url(")); function GS(e) { const r = e[0]; if (e.length === 1) return !0; for (let i = 0; i < e.length; i++)if (e[i] !== r) return !0 } function YS(e, r, i, s) { const a = e[0]; if (a === null) return !1; if (r === "display" || r === "visibility") return !0; const c = e[e.length - 1], u = cm(a, r), f = cm(c, r); return !u || !f ? !1 : GS(e) || (i === "spring" || Ny(i)) && s } function Tu(e) { e.duration = 0, e.type = "keyframes" } const XS = new Set(["opacity", "clipPath", "filter", "transform"]), qS = sd(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function QS(e) { const { motionValue: r, name: i, repeatDelay: s, repeatType: a, damping: c, type: u } = e; if (!(r?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: h, transformTemplate: g } = r.owner.getProps(); return qS() && i && XS.has(i) && (i !== "transform" || !g) && !h && !s && a !== "mirror" && c !== 0 && u !== "inertia" } const ZS = 40; class JS extends gd { constructor({ autoplay: r = !0, delay: i = 0, type: s = "keyframes", repeat: a = 0, repeatDelay: c = 0, repeatType: u = "loop", keyframes: f, name: h, motionValue: g, element: y, ...v }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = Ct.now(); const S = { autoplay: r, delay: i, type: s, repeat: a, repeatDelay: c, repeatType: u, name: h, motionValue: g, element: y, ...v }, k = y?.KeyframeResolver || vd; this.keyframeResolver = new k(f, (P, C, N) => this.onKeyframesResolved(P, C, S, !N), h, g, y), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(r, i, s, a) { this.keyframeResolver = void 0; const { name: c, type: u, velocity: f, delay: h, isHandoff: g, onUpdate: y } = s; this.resolvedAt = Ct.now(), YS(r, c, u, f) || ((bn.instantAnimations || !h) && y?.(md(r, s, i)), r[0] = r[r.length - 1], Tu(s), s.repeat = 0); const S = { startTime: a ? this.resolvedAt ? this.resolvedAt - this.createdAt > ZS ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: i, ...s, keyframes: r }, k = !g && QS(S) ? new KS({ ...S, element: S.motionValue.owner.current }) : new yd(S); k.finished.then(() => this.notifyFinished()).catch(Vt), this.pendingTimeline && (this.stopTimeline = k.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = k } get finished() { return this._animation ? this.animation.finished : this._finished } then(r, i) { return this.finished.finally(r).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), _S()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(r) { this.animation.time = r } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(r) { this.animation.speed = r } get startTime() { return this.animation.startTime } attachTimeline(r) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(r) : this.pendingTimeline = r, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const eC = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function tC(e) { const r = eC.exec(e); if (!r) return [,]; const [, i, s, a] = r; return [`--${i ?? s}`, a] } function Ey(e, r, i = 1) { const [s, a] = tC(e); if (!s) return; const c = window.getComputedStyle(r).getPropertyValue(s); if (c) { const u = c.trim(); return Yg(u) ? parseFloat(u) : u } return ud(a) ? Ey(a, r, i + 1) : a } function xd(e, r) { return e?.[r] ?? e?.default ?? e } const Ty = new Set(["width", "height", "top", "left", "right", "bottom", ...yi]), nC = { test: e => e === "auto", parse: e => e }, jy = e => r => r.test(e), Ay = [gi, he, cn, Gn, G1, K1, nC], um = e => Ay.find(jy(e)); function rC(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || qg(e) : !0 } const iC = new Set(["brightness", "contrast", "saturate", "opacity"]); function oC(e) { const [r, i] = e.slice(0, -1).split("("); if (r === "drop-shadow") return e; const [s] = i.match(dd) || []; if (!s) return e; const a = i.replace(s, ""); let c = iC.has(r) ? 1 : 0; return s !== i && (c *= 100), r + "(" + c + a + ")" } const sC = /\b([a-z-]*)\(.*?\)/gu, ju = { ...Qn, getAnimatableNone: e => { const r = e.match(sC); return r ? r.map(oC).join(" ") : e } }, dm = { ...gi, transform: Math.round }, aC = { rotate: Gn, rotateX: Gn, rotateY: Gn, rotateZ: Gn, scale: qs, scaleX: qs, scaleY: qs, scaleZ: qs, skew: Gn, skewX: Gn, skewY: Gn, distance: he, translateX: he, translateY: he, translateZ: he, x: he, y: he, z: he, perspective: he, transformPerspective: he, opacity: Co, originX: Zh, originY: Zh, originZ: he }, wd = { borderWidth: he, borderTopWidth: he, borderRightWidth: he, borderBottomWidth: he, borderLeftWidth: he, borderRadius: he, radius: he, borderTopLeftRadius: he, borderTopRightRadius: he, borderBottomRightRadius: he, borderBottomLeftRadius: he, width: he, maxWidth: he, height: he, maxHeight: he, top: he, right: he, bottom: he, left: he, padding: he, paddingTop: he, paddingRight: he, paddingBottom: he, paddingLeft: he, margin: he, marginTop: he, marginRight: he, marginBottom: he, marginLeft: he, backgroundPositionX: he, backgroundPositionY: he, ...aC, zIndex: dm, fillOpacity: Co, strokeOpacity: Co, numOctaves: dm }, lC = { ...wd, color: Ye, backgroundColor: Ye, outlineColor: Ye, fill: Ye, stroke: Ye, borderColor: Ye, borderTopColor: Ye, borderRightColor: Ye, borderBottomColor: Ye, borderLeftColor: Ye, filter: ju, WebkitFilter: ju }, Ry = e => lC[e]; function My(e, r) { let i = Ry(e); return i !== ju && (i = Qn), i.getAnimatableNone ? i.getAnimatableNone(r) : void 0 } const cC = new Set(["auto", "none", "0"]); function uC(e, r, i) { let s = 0, a; for (; s < e.length && !a;) { const c = e[s]; typeof c == "string" && !cC.has(c) && ko(c).values.length && (a = e[s]), s++ } if (a && i) for (const c of r) e[c] = My(i, a) } class dC extends vd { constructor(r, i, s, a, c) { super(r, i, s, a, c, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: i, name: s } = this; if (!i || !i.current) return; super.readKeyframes(); for (let h = 0; h < r.length; h++) { let g = r[h]; if (typeof g == "string" && (g = g.trim(), ud(g))) { const y = Ey(g, i.current); y !== void 0 && (r[h] = y), h === r.length - 1 && (this.finalKeyframe = g) } } if (this.resolveNoneKeyframes(), !Ty.has(s) || r.length !== 2) return; const [a, c] = r, u = um(a), f = um(c); if (u !== f) if (sm(u) && sm(f)) for (let h = 0; h < r.length; h++) { const g = r[h]; typeof g == "string" && (r[h] = parseFloat(g)) } else Cr[s] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: i } = this, s = []; for (let a = 0; a < r.length; a++)(r[a] === null || rC(r[a])) && s.push(a); s.length && uC(r, s, i) } measureInitialState() { const { element: r, unresolvedKeyframes: i, name: s } = this; if (!r || !r.current) return; s === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Cr[s](r.measureViewportBox(), window.getComputedStyle(r.current)), i[0] = this.measuredOrigin; const a = i[i.length - 1]; a !== void 0 && r.getValue(s, a).jump(a, !1) } measureEndState() { const { element: r, name: i, unresolvedKeyframes: s } = this; if (!r || !r.current) return; const a = r.getValue(i); a && a.jump(this.measuredOrigin, !1); const c = s.length - 1, u = s[c]; s[c] = Cr[i](r.measureViewportBox(), window.getComputedStyle(r.current)), u !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = u), this.removedTransforms?.length && this.removedTransforms.forEach(([f, h]) => { r.getValue(f).set(h) }), this.resolveNoneKeyframes() } } function Iy(e, r, i) { if (e instanceof EventTarget) return [e]; if (typeof e == "string") { const a = document.querySelectorAll(e); return a ? Array.from(a) : [] } return Array.from(e) } const Dy = (e, r) => r && typeof e == "number" ? r.transform(e) : e; function _y(e) { return Xg(e) && "offsetHeight" in e } const fm = 30, fC = e => !isNaN(parseFloat(e)); class pC { constructor(r, i = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = s => { const a = Ct.now(); if (this.updatedAt !== a && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const c of this.dependents) c.dirty() }, this.hasAnimated = !1, this.setCurrent(r), this.owner = i.owner } setCurrent(r) { this.current = r, this.updatedAt = Ct.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = fC(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, i) { this.events[r] || (this.events[r] = new ad); const s = this.events[r].add(i); return r === "change" ? () => { s(), Oe.read(() => { this.events.change.getSize() || this.stop() }) } : s } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, i) { this.passiveEffect = r, this.stopPassiveEffect = i } set(r) { this.passiveEffect ? this.passiveEffect(r, this.updateAndNotify) : this.updateAndNotify(r) } setWithVelocity(r, i, s) { this.set(i), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - s } jump(r, i = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(r) { this.dependents || (this.dependents = new Set), this.dependents.add(r) } removeDependent(r) { this.dependents && this.dependents.delete(r) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = Ct.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > fm) return 0; const i = Math.min(this.updatedAt - this.prevUpdatedAt, fm); return Qg(parseFloat(this.current) - parseFloat(this.prevFrameValue), i) } start(r) { return this.stop(), new Promise(i => { this.hasAnimated = !0, this.animation = r(i), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function pi(e, r) { return new pC(e, r) } const { schedule: Sd } = ly(queueMicrotask, !1), Xt = { x: !1, y: !1 }; function Ly() { return Xt.x || Xt.y } function hC(e) { return e === "x" || e === "y" ? Xt[e] ? null : (Xt[e] = !0, () => { Xt[e] = !1 }) : Xt.x || Xt.y ? null : (Xt.x = Xt.y = !0, () => { Xt.x = Xt.y = !1 }) } function Oy(e, r) { const i = Iy(e), s = new AbortController, a = { passive: !0, ...r, signal: s.signal }; return [i, a, () => s.abort()] } function pm(e) { return !(e.pointerType === "touch" || Ly()) } function mC(e, r, i = {}) { const [s, a, c] = Oy(e, i), u = f => { if (!pm(f)) return; const { target: h } = f, g = r(h, f); if (typeof g != "function" || !h) return; const y = v => { pm(v) && (g(v), h.removeEventListener("pointerleave", y)) }; h.addEventListener("pointerleave", y, a) }; return s.forEach(f => { f.addEventListener("pointerenter", u, a) }), c } const Vy = (e, r) => r ? e === r ? !0 : Vy(e, r.parentElement) : !1, Cd = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, gC = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function yC(e) { return gC.has(e.tagName) || e.tabIndex !== -1 } const la = new WeakSet; function hm(e) { return r => { r.key === "Enter" && e(r) } } function Uc(e, r) { e.dispatchEvent(new PointerEvent("pointer" + r, { isPrimary: !0, bubbles: !0 })) } const vC = (e, r) => { const i = e.currentTarget; if (!i) return; const s = hm(() => { if (la.has(i)) return; Uc(i, "down"); const a = hm(() => { Uc(i, "up") }), c = () => Uc(i, "cancel"); i.addEventListener("keyup", a, r), i.addEventListener("blur", c, r) }); i.addEventListener("keydown", s, r), i.addEventListener("blur", () => i.removeEventListener("keydown", s), r) }; function mm(e) { return Cd(e) && !Ly() } function xC(e, r, i = {}) { const [s, a, c] = Oy(e, i), u = f => { const h = f.currentTarget; if (!mm(f)) return; la.add(h); const g = r(h, f), y = (k, P) => { window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", S), la.has(h) && la.delete(h), mm(k) && typeof g == "function" && g(k, { success: P }) }, v = k => { y(k, h === window || h === document || i.useGlobalTarget || Vy(h, k.target)) }, S = k => { y(k, !1) }; window.addEventListener("pointerup", v, a), window.addEventListener("pointercancel", S, a) }; return s.forEach(f => { (i.useGlobalTarget ? window : f).addEventListener("pointerdown", u, a), _y(f) && (f.addEventListener("focus", g => vC(g, a)), !yC(f) && !f.hasAttribute("tabindex") && (f.tabIndex = 0)) }), c } function Fy(e) { return Xg(e) && "ownerSVGElement" in e } function wC(e) { return Fy(e) && e.tagName === "svg" } const ft = e => !!(e && e.getVelocity), SC = [...Ay, Ye, Qn], CC = e => SC.find(jy(e)), kd = w.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); function gm(e, r) { if (typeof e == "function") return e(r); e != null && (e.current = r) } function kC(...e) { return r => { let i = !1; const s = e.map(a => { const c = gm(a, r); return !i && typeof c == "function" && (i = !0), c }); if (i) return () => { for (let a = 0; a < s.length; a++) { const c = s[a]; typeof c == "function" ? c() : gm(e[a], null) } } } } function bC(...e) { return w.useCallback(kC(...e), e) } class NC extends w.Component { getSnapshotBeforeUpdate(r) { const i = this.props.childRef.current; if (i && r.isPresent && !this.props.isPresent) { const s = i.offsetParent, a = _y(s) && s.offsetWidth || 0, c = this.props.sizeRef.current; c.height = i.offsetHeight || 0, c.width = i.offsetWidth || 0, c.top = i.offsetTop, c.left = i.offsetLeft, c.right = a - c.width - c.left } return null } componentDidUpdate() { } render() { return this.props.children } } function PC({ children: e, isPresent: r, anchorX: i, root: s }) {
  const a = w.useId(), c = w.useRef(null), u = w.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: f } = w.useContext(kd), h = bC(c, e?.ref); return w.useInsertionEffect(() => {
    const { width: g, height: y, top: v, left: S, right: k } = u.current; if (r || !c.current || !g || !y) return; const P = i === "left" ? `left: ${S}` : `right: ${k}`; c.current.dataset.motionPopId = a; const C = document.createElement("style"); f && (C.nonce = f); const N = s ?? document.head; return N.appendChild(C), C.sheet && C.sheet.insertRule(`
          [data-motion-pop-id="${a}"] {
            position: absolute !important;
            width: ${g}px !important;
            height: ${y}px !important;
            ${P}px !important;
            top: ${v}px !important;
          }
        `), () => { N.contains(C) && N.removeChild(C) }
  }, [r]), p.jsx(NC, { isPresent: r, childRef: c, sizeRef: u, children: w.cloneElement(e, { ref: h }) })
} const EC = ({ children: e, initial: r, isPresent: i, onExitComplete: s, custom: a, presenceAffectsLayout: c, mode: u, anchorX: f, root: h }) => { const g = td(TC), y = w.useId(); let v = !0, S = w.useMemo(() => (v = !1, { id: y, initial: r, isPresent: i, custom: a, onExitComplete: k => { g.set(k, !0); for (const P of g.values()) if (!P) return; s && s() }, register: k => (g.set(k, !1), () => g.delete(k)) }), [i, g, s]); return c && v && (S = { ...S }), w.useMemo(() => { g.forEach((k, P) => g.set(P, !1)) }, [i]), w.useEffect(() => { !i && !g.size && s && s() }, [i]), u === "popLayout" && (e = p.jsx(PC, { isPresent: i, anchorX: f, root: h, children: e })), p.jsx(Ta.Provider, { value: S, children: e }) }; function TC() { return new Map } function zy(e = !0) { const r = w.useContext(Ta); if (r === null) return [!0, null]; const { isPresent: i, onExitComplete: s, register: a } = r, c = w.useId(); w.useEffect(() => { if (e) return a(c) }, [e]); const u = w.useCallback(() => e && s && s(c), [c, s, e]); return !i && s ? [!1, u] : [!0] } const Qs = e => e.key || ""; function ym(e) { const r = []; return w.Children.forEach(e, i => { w.isValidElement(i) && r.push(i) }), r } const jC = ({ children: e, custom: r, initial: i = !0, onExitComplete: s, presenceAffectsLayout: a = !0, mode: c = "sync", propagate: u = !1, anchorX: f = "left", root: h }) => { const [g, y] = zy(u), v = w.useMemo(() => ym(e), [e]), S = u && !g ? [] : v.map(Qs), k = w.useRef(!0), P = w.useRef(v), C = td(() => new Map), [N, j] = w.useState(v), [E, R] = w.useState(v); Gg(() => { k.current = !1, P.current = v; for (let B = 0; B < E.length; B++) { const z = Qs(E[B]); S.includes(z) ? C.delete(z) : C.get(z) !== !0 && C.set(z, !1) } }, [E, S.length, S.join("-")]); const O = []; if (v !== N) { let B = [...v]; for (let z = 0; z < E.length; z++) { const F = E[z], Z = Qs(F); S.includes(Z) || (B.splice(z, 0, F), O.push(F)) } return c === "wait" && O.length && (B = O), R(ym(B)), j(v), null } const { forceRender: V } = w.useContext(ed); return p.jsx(p.Fragment, { children: E.map(B => { const z = Qs(B), F = u && !g ? !1 : v === E || S.includes(z), Z = () => { if (C.has(z)) C.set(z, !0); else return; let ie = !0; C.forEach(fe => { fe || (ie = !1) }), ie && (V?.(), R(P.current), u && y?.(), s && s()) }; return p.jsx(EC, { isPresent: F, initial: !k.current || i ? void 0 : !1, custom: r, presenceAffectsLayout: a, mode: c, root: h, onExitComplete: F ? void 0 : Z, anchorX: f, children: B }, z) }) }) }, By = w.createContext({ strict: !1 }), vm = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, hi = {}; for (const e in vm) hi[e] = { isEnabled: r => vm[e].some(i => !!r[i]) }; function AC(e) { for (const r in e) hi[r] = { ...hi[r], ...e[r] } } const RC = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function ya(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || RC.has(e) } let Wy = e => !ya(e); function MC(e) { typeof e == "function" && (Wy = r => r.startsWith("on") ? !ya(r) : e(r)) } try { MC(require("@emotion/is-prop-valid").default) } catch { } function IC(e, r, i) { const s = {}; for (const a in e) a === "values" && typeof e.values == "object" || (Wy(a) || i === !0 && ya(a) || !r && !ya(a) || e.draggable && a.startsWith("onDrag")) && (s[a] = e[a]); return s } const ja = w.createContext({}); function Aa(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function bo(e) { return typeof e == "string" || Array.isArray(e) } const bd = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Nd = ["initial", ...bd]; function Ra(e) { return Aa(e.animate) || Nd.some(r => bo(e[r])) } function $y(e) { return !!(Ra(e) || e.variants) } function DC(e, r) { if (Ra(e)) { const { initial: i, animate: s } = e; return { initial: i === !1 || bo(i) ? i : void 0, animate: bo(s) ? s : void 0 } } return e.inherit !== !1 ? r : {} } function _C(e) { const { initial: r, animate: i } = DC(e, w.useContext(ja)); return w.useMemo(() => ({ initial: r, animate: i }), [xm(r), xm(i)]) } function xm(e) { return Array.isArray(e) ? e.join(" ") : e } function wm(e, r) { return r.max === r.min ? 0 : e / (r.max - r.min) * 100 } const uo = { correct: (e, r) => { if (!r.target) return e; if (typeof e == "string") if (he.test(e)) e = parseFloat(e); else return e; const i = wm(e, r.target.x), s = wm(e, r.target.y); return `${i}% ${s}%` } }, LC = { correct: (e, { treeScale: r, projectionDelta: i }) => { const s = e, a = Qn.parse(e); if (a.length > 5) return s; const c = Qn.createTransformer(e), u = typeof a[0] != "number" ? 1 : 0, f = i.x.scale * r.x, h = i.y.scale * r.y; a[0 + u] /= f, a[1 + u] /= h; const g = ze(f, h, .5); return typeof a[2 + u] == "number" && (a[2 + u] /= g), typeof a[3 + u] == "number" && (a[3 + u] /= g), c(a) } }, Au = { borderRadius: { ...uo, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: uo, borderTopRightRadius: uo, borderBottomLeftRadius: uo, borderBottomRightRadius: uo, boxShadow: LC }; function Uy(e, { layout: r, layoutId: i }) { return vi.has(e) || e.startsWith("origin") || (r || i !== void 0) && (!!Au[e] || e === "opacity") } const OC = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, VC = yi.length; function FC(e, r, i) { let s = "", a = !0; for (let c = 0; c < VC; c++) { const u = yi[c], f = e[u]; if (f === void 0) continue; let h = !0; if (typeof f == "number" ? h = f === (u.startsWith("scale") ? 1 : 0) : h = parseFloat(f) === 0, !h || i) { const g = Dy(f, wd[u]); if (!h) { a = !1; const y = OC[u] || u; s += `${y}(${g}) ` } i && (r[u] = g) } } return s = s.trim(), i ? s = i(r, a ? "" : s) : a && (s = "none"), s } function Pd(e, r, i) { const { style: s, vars: a, transformOrigin: c } = e; let u = !1, f = !1; for (const h in r) { const g = r[h]; if (vi.has(h)) { u = !0; continue } else if (uy(h)) { a[h] = g; continue } else { const y = Dy(g, wd[h]); h.startsWith("origin") ? (f = !0, c[h] = y) : s[h] = y } } if (r.transform || (u || i ? s.transform = FC(r, e.transform, i) : s.transform && (s.transform = "none")), f) { const { originX: h = "50%", originY: g = "50%", originZ: y = 0 } = c; s.transformOrigin = `${h} ${g} ${y}` } } const Ed = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Hy(e, r, i) { for (const s in r) !ft(r[s]) && !Uy(s, i) && (e[s] = r[s]) } function zC({ transformTemplate: e }, r) { return w.useMemo(() => { const i = Ed(); return Pd(i, r, e), Object.assign({}, i.vars, i.style) }, [r]) } function BC(e, r) { const i = e.style || {}, s = {}; return Hy(s, i, e), Object.assign(s, zC(e, r)), s } function WC(e, r) { const i = {}, s = BC(e, r); return e.drag && e.dragListener !== !1 && (i.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0), i.style = s, i } const $C = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, UC = { offset: "strokeDashoffset", array: "strokeDasharray" }; function HC(e, r, i = 1, s = 0, a = !0) { e.pathLength = 1; const c = a ? $C : UC; e[c.offset] = he.transform(-s); const u = he.transform(r), f = he.transform(i); e[c.array] = `${u} ${f}` } function Ky(e, { attrX: r, attrY: i, attrScale: s, pathLength: a, pathSpacing: c = 1, pathOffset: u = 0, ...f }, h, g, y) { if (Pd(e, f, g), h) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: v, style: S } = e; v.transform && (S.transform = v.transform, delete v.transform), (S.transform || v.transformOrigin) && (S.transformOrigin = v.transformOrigin ?? "50% 50%", delete v.transformOrigin), S.transform && (S.transformBox = y?.transformBox ?? "fill-box", delete v.transformBox), r !== void 0 && (v.x = r), i !== void 0 && (v.y = i), s !== void 0 && (v.scale = s), a !== void 0 && HC(v, a, c, u, !1) } const Gy = () => ({ ...Ed(), attrs: {} }), Yy = e => typeof e == "string" && e.toLowerCase() === "svg"; function KC(e, r, i, s) { const a = w.useMemo(() => { const c = Gy(); return Ky(c, r, Yy(s), e.transformTemplate, e.style), { ...c.attrs, style: { ...c.style } } }, [r]); if (e.style) { const c = {}; Hy(c, e.style, e), a.style = { ...c, ...a.style } } return a } const GC = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Td(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(GC.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function YC(e, r, i, { latestValues: s }, a, c = !1) { const f = (Td(e) ? KC : WC)(r, s, a, e), h = IC(r, typeof e == "string", c), g = e !== w.Fragment ? { ...h, ...f, ref: i } : {}, { children: y } = r, v = w.useMemo(() => ft(y) ? y.get() : y, [y]); return w.createElement(e, { ...g, children: v }) } function Sm(e) { const r = [{}, {}]; return e?.values.forEach((i, s) => { r[0][s] = i.get(), r[1][s] = i.getVelocity() }), r } function jd(e, r, i, s) { if (typeof r == "function") { const [a, c] = Sm(s); r = r(i !== void 0 ? i : e.custom, a, c) } if (typeof r == "string" && (r = e.variants && e.variants[r]), typeof r == "function") { const [a, c] = Sm(s); r = r(i !== void 0 ? i : e.custom, a, c) } return r } function ca(e) { return ft(e) ? e.get() : e } function XC({ scrapeMotionValuesFromProps: e, createRenderState: r }, i, s, a) { return { latestValues: qC(i, s, a, e), renderState: r() } } function qC(e, r, i, s) { const a = {}, c = s(e, {}); for (const S in c) a[S] = ca(c[S]); let { initial: u, animate: f } = e; const h = Ra(e), g = $y(e); r && g && !h && e.inherit !== !1 && (u === void 0 && (u = r.initial), f === void 0 && (f = r.animate)); let y = i ? i.initial === !1 : !1; y = y || u === !1; const v = y ? f : u; if (v && typeof v != "boolean" && !Aa(v)) { const S = Array.isArray(v) ? v : [v]; for (let k = 0; k < S.length; k++) { const P = jd(e, S[k]); if (P) { const { transitionEnd: C, transition: N, ...j } = P; for (const E in j) { let R = j[E]; if (Array.isArray(R)) { const O = y ? R.length - 1 : 0; R = R[O] } R !== null && (a[E] = R) } for (const E in C) a[E] = C[E] } } } return a } const Xy = e => (r, i) => { const s = w.useContext(ja), a = w.useContext(Ta), c = () => XC(e, r, s, a); return i ? c() : td(c) }; function Ad(e, r, i) { const { style: s } = e, a = {}; for (const c in s) (ft(s[c]) || r.style && ft(r.style[c]) || Uy(c, e) || i?.getValue(c)?.liveStyle !== void 0) && (a[c] = s[c]); return a } const QC = Xy({ scrapeMotionValuesFromProps: Ad, createRenderState: Ed }); function qy(e, r, i) { const s = Ad(e, r, i); for (const a in e) if (ft(e[a]) || ft(r[a])) { const c = yi.indexOf(a) !== -1 ? "attr" + a.charAt(0).toUpperCase() + a.substring(1) : a; s[c] = e[a] } return s } const ZC = Xy({ scrapeMotionValuesFromProps: qy, createRenderState: Gy }), JC = Symbol.for("motionComponentSymbol"); function si(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function ek(e, r, i) { return w.useCallback(s => { s && e.onMount && e.onMount(s), r && (s ? r.mount(s) : r.unmount()), i && (typeof i == "function" ? i(s) : si(i) && (i.current = s)) }, [r]) } const Rd = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), tk = "framerAppearId", Qy = "data-" + Rd(tk), Zy = w.createContext({}); function nk(e, r, i, s, a) { const { visualElement: c } = w.useContext(ja), u = w.useContext(By), f = w.useContext(Ta), h = w.useContext(kd).reducedMotion, g = w.useRef(null); s = s || u.renderer, !g.current && s && (g.current = s(e, { visualState: r, parent: c, props: i, presenceContext: f, blockInitialAnimation: f ? f.initial === !1 : !1, reducedMotionConfig: h })); const y = g.current, v = w.useContext(Zy); y && !y.projection && a && (y.type === "html" || y.type === "svg") && rk(g.current, i, a, v); const S = w.useRef(!1); w.useInsertionEffect(() => { y && S.current && y.update(i, f) }); const k = i[Qy], P = w.useRef(!!k && !window.MotionHandoffIsComplete?.(k) && window.MotionHasOptimisedAnimation?.(k)); return Gg(() => { y && (S.current = !0, window.MotionIsMounted = !0, y.updateFeatures(), y.scheduleRenderMicrotask(), P.current && y.animationState && y.animationState.animateChanges()) }), w.useEffect(() => { y && (!P.current && y.animationState && y.animationState.animateChanges(), P.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(k) }), P.current = !1), y.enteringChildren = void 0) }), y } function rk(e, r, i, s) { const { layoutId: a, layout: c, drag: u, dragConstraints: f, layoutScroll: h, layoutRoot: g, layoutCrossfade: y } = r; e.projection = new i(e.latestValues, r["data-framer-portal-id"] ? void 0 : Jy(e.parent)), e.projection.setOptions({ layoutId: a, layout: c, alwaysMeasureLayout: !!u || f && si(f), visualElement: e, animationType: typeof c == "string" ? c : "both", initialPromotionConfig: s, crossfade: y, layoutScroll: h, layoutRoot: g }) } function Jy(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : Jy(e.parent) } function Hc(e, { forwardMotionProps: r = !1 } = {}, i, s) { i && AC(i); const a = Td(e) ? ZC : QC; function c(f, h) { let g; const y = { ...w.useContext(kd), ...f, layoutId: ik(f) }, { isStatic: v } = y, S = _C(f), k = a(f, v); if (!v && nd) { ok(); const P = sk(y); g = P.MeasureLayout, S.visualElement = nk(e, k, y, s, P.ProjectionNode) } return p.jsxs(ja.Provider, { value: S, children: [g && S.visualElement ? p.jsx(g, { visualElement: S.visualElement, ...y }) : null, YC(e, f, ek(k, S.visualElement, h), k, v, r)] }) } c.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`; const u = w.forwardRef(c); return u[JC] = e, u } function ik({ layoutId: e }) { const r = w.useContext(ed).id; return r && e !== void 0 ? r + "-" + e : e } function ok(e, r) { w.useContext(By).strict } function sk(e) { const { drag: r, layout: i } = hi; if (!r && !i) return {}; const s = { ...r, ...i }; return { MeasureLayout: r?.isEnabled(e) || i?.isEnabled(e) ? s.MeasureLayout : void 0, ProjectionNode: s.ProjectionNode } } function ak(e, r) { if (typeof Proxy > "u") return Hc; const i = new Map, s = (c, u) => Hc(c, u, e, r), a = (c, u) => s(c, u); return new Proxy(a, { get: (c, u) => u === "create" ? s : (i.has(u) || i.set(u, Hc(u, void 0, e, r)), i.get(u)) }) } function ev({ top: e, left: r, right: i, bottom: s }) { return { x: { min: r, max: i }, y: { min: e, max: s } } } function lk({ x: e, y: r }) { return { top: r.min, right: e.max, bottom: r.max, left: e.min } } function ck(e, r) { if (!r) return e; const i = r({ x: e.left, y: e.top }), s = r({ x: e.right, y: e.bottom }); return { top: i.y, left: i.x, bottom: s.y, right: s.x } } function Kc(e) { return e === void 0 || e === 1 } function Ru({ scale: e, scaleX: r, scaleY: i }) { return !Kc(e) || !Kc(r) || !Kc(i) } function xr(e) { return Ru(e) || tv(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function tv(e) { return Cm(e.x) || Cm(e.y) } function Cm(e) { return e && e !== "0%" } function va(e, r, i) { const s = e - i, a = r * s; return i + a } function km(e, r, i, s, a) { return a !== void 0 && (e = va(e, a, s)), va(e, i, s) + r } function Mu(e, r = 0, i = 1, s, a) { e.min = km(e.min, r, i, s, a), e.max = km(e.max, r, i, s, a) } function nv(e, { x: r, y: i }) { Mu(e.x, r.translate, r.scale, r.originPoint), Mu(e.y, i.translate, i.scale, i.originPoint) } const bm = .999999999999, Nm = 1.0000000000001; function uk(e, r, i, s = !1) { const a = i.length; if (!a) return; r.x = r.y = 1; let c, u; for (let f = 0; f < a; f++) { c = i[f], u = c.projectionDelta; const { visualElement: h } = c.options; h && h.props.style && h.props.style.display === "contents" || (s && c.options.layoutScroll && c.scroll && c !== c.root && li(e, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), u && (r.x *= u.x.scale, r.y *= u.y.scale, nv(e, u)), s && xr(c.latestValues) && li(e, c.latestValues)) } r.x < Nm && r.x > bm && (r.x = 1), r.y < Nm && r.y > bm && (r.y = 1) } function ai(e, r) { e.min = e.min + r, e.max = e.max + r } function Pm(e, r, i, s, a = .5) { const c = ze(e.min, e.max, a); Mu(e, r, i, c, s) } function li(e, r) { Pm(e.x, r.x, r.scaleX, r.scale, r.originX), Pm(e.y, r.y, r.scaleY, r.scale, r.originY) } function rv(e, r) { return ev(ck(e.getBoundingClientRect(), r)) } function dk(e, r, i) { const s = rv(e, i), { scroll: a } = r; return a && (ai(s.x, a.offset.x), ai(s.y, a.offset.y)), s } const Em = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), ci = () => ({ x: Em(), y: Em() }), Tm = () => ({ min: 0, max: 0 }), Je = () => ({ x: Tm(), y: Tm() }), Iu = { current: null }, iv = { current: !1 }; function fk() { if (iv.current = !0, !!nd) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), r = () => Iu.current = e.matches; e.addEventListener("change", r), r() } else Iu.current = !1 } const pk = new WeakMap; function hk(e, r, i) { for (const s in r) { const a = r[s], c = i[s]; if (ft(a)) e.addValue(s, a); else if (ft(c)) e.addValue(s, pi(a, { owner: e })); else if (c !== a) if (e.hasValue(s)) { const u = e.getValue(s); u.liveStyle === !0 ? u.jump(a) : u.hasAnimated || u.set(a) } else { const u = e.getStaticValue(s); e.addValue(s, pi(u !== void 0 ? u : a, { owner: e })) } } for (const s in i) r[s] === void 0 && e.removeValue(s); return r } const jm = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class mk { scrapeMotionValuesFromProps(r, i, s) { return {} } constructor({ parent: r, props: i, presenceContext: s, reducedMotionConfig: a, blockInitialAnimation: c, visualState: u }, f = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = vd, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const S = Ct.now(); this.renderScheduledAt < S && (this.renderScheduledAt = S, Oe.render(this.render, !1, !0)) }; const { latestValues: h, renderState: g } = u; this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = i.initial ? { ...h } : {}, this.renderState = g, this.parent = r, this.props = i, this.presenceContext = s, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = a, this.options = f, this.blockInitialAnimation = !!c, this.isControllingVariants = Ra(i), this.isVariantNode = $y(i), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: y, ...v } = this.scrapeMotionValuesFromProps(i, {}, this); for (const S in v) { const k = v[S]; h[S] !== void 0 && ft(k) && k.set(h[S]) } } mount(r) { this.current = r, pk.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, s) => this.bindToMotionValue(s, i)), iv.current || fk(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Iu.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), qn(this.notifyUpdate), qn(this.render), this.valueSubscriptions.forEach(r => r()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const i = this.features[r]; i && (i.unmount(), i.isMounted = !1) } this.current = null } addChild(r) { this.children.add(r), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(r) } removeChild(r) { this.children.delete(r), this.enteringChildren && this.enteringChildren.delete(r) } bindToMotionValue(r, i) { this.valueSubscriptions.has(r) && this.valueSubscriptions.get(r)(); const s = vi.has(r); s && this.onBindTransform && this.onBindTransform(); const a = i.on("change", u => { this.latestValues[r] = u, this.props.onUpdate && Oe.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let c; window.MotionCheckAppearSync && (c = window.MotionCheckAppearSync(this, r, i)), this.valueSubscriptions.set(r, () => { a(), c && c(), i.owner && i.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in hi) { const i = hi[r]; if (!i) continue; const { isEnabled: s, Feature: a } = i; if (!this.features[r] && a && s(this.props) && (this.features[r] = new a(this)), this.features[r]) { const c = this.features[r]; c.isMounted ? c.update() : (c.mount(), c.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Je() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, i) { this.latestValues[r] = i } update(r, i) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = i; for (let s = 0; s < jm.length; s++) { const a = jm[s]; this.propEventSubscriptions[a] && (this.propEventSubscriptions[a](), delete this.propEventSubscriptions[a]); const c = "on" + a, u = r[c]; u && (this.propEventSubscriptions[a] = this.on(a, u)) } this.prevMotionValues = hk(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(r) { const i = this.getClosestVariantNode(); if (i) return i.variantChildren && i.variantChildren.add(r), () => i.variantChildren.delete(r) } addValue(r, i) { const s = this.values.get(r); i !== s && (s && this.removeValue(r), this.bindToMotionValue(r, i), this.values.set(r, i), this.latestValues[r] = i.get()) } removeValue(r) { this.values.delete(r); const i = this.valueSubscriptions.get(r); i && (i(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, i) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let s = this.values.get(r); return s === void 0 && i !== void 0 && (s = pi(i === null ? void 0 : i, { owner: this }), this.addValue(r, s)), s } readValue(r, i) { let s = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : this.getBaseTargetFromProps(this.props, r) ?? this.readValueFromInstance(this.current, r, this.options); return s != null && (typeof s == "string" && (Yg(s) || qg(s)) ? s = parseFloat(s) : !CC(s) && Qn.test(i) && (s = My(r, i)), this.setBaseTarget(r, ft(s) ? s.get() : s)), ft(s) ? s.get() : s } setBaseTarget(r, i) { this.baseTarget[r] = i } getBaseTarget(r) { const { initial: i } = this.props; let s; if (typeof i == "string" || typeof i == "object") { const c = jd(this.props, i, this.presenceContext?.custom); c && (s = c[r]) } if (i && s !== void 0) return s; const a = this.getBaseTargetFromProps(this.props, r); return a !== void 0 && !ft(a) ? a : this.initialValues[r] !== void 0 && s === void 0 ? void 0 : this.baseTarget[r] } on(r, i) { return this.events[r] || (this.events[r] = new ad), this.events[r].add(i) } notify(r, ...i) { this.events[r] && this.events[r].notify(...i) } scheduleRenderMicrotask() { Sd.render(this.render) } } class ov extends mk { constructor() { super(...arguments), this.KeyframeResolver = dC } sortInstanceNodePosition(r, i) { return r.compareDocumentPosition(i) & 2 ? 1 : -1 } getBaseTargetFromProps(r, i) { return r.style ? r.style[i] : void 0 } removeValueFromRenderState(r, { vars: i, style: s }) { delete i[r], delete s[r] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; ft(r) && (this.childSubscription = r.on("change", i => { this.current && (this.current.textContent = `${i}`) })) } } function sv(e, { style: r, vars: i }, s, a) { const c = e.style; let u; for (u in r) c[u] = r[u]; a?.applyProjectionStyles(c, s); for (u in i) c.setProperty(u, i[u]) } function gk(e) { return window.getComputedStyle(e) } class yk extends ov { constructor() { super(...arguments), this.type = "html", this.renderInstance = sv } readValueFromInstance(r, i) { if (vi.has(i)) return this.projection?.isProjecting ? ku(i) : AS(r, i); { const s = gk(r), a = (uy(i) ? s.getPropertyValue(i) : s[i]) || 0; return typeof a == "string" ? a.trim() : a } } measureInstanceViewportBox(r, { transformPagePoint: i }) { return rv(r, i) } build(r, i, s) { Pd(r, i, s.transformTemplate) } scrapeMotionValuesFromProps(r, i, s) { return Ad(r, i, s) } } const av = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function vk(e, r, i, s) { sv(e, r, void 0, s); for (const a in r.attrs) e.setAttribute(av.has(a) ? a : Rd(a), r.attrs[a]) } class xk extends ov { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Je } getBaseTargetFromProps(r, i) { return r[i] } readValueFromInstance(r, i) { if (vi.has(i)) { const s = Ry(i); return s && s.default || 0 } return i = av.has(i) ? i : Rd(i), r.getAttribute(i) } scrapeMotionValuesFromProps(r, i, s) { return qy(r, i, s) } build(r, i, s) { Ky(r, i, this.isSVGTag, s.transformTemplate, s.style) } renderInstance(r, i, s, a) { vk(r, i, s, a) } mount(r) { this.isSVGTag = Yy(r.tagName), super.mount(r) } } const wk = (e, r) => Td(e) ? new xk(r) : new yk(r, { allowProjection: e !== w.Fragment }); function ui(e, r, i) { const s = e.getProps(); return jd(s, r, i !== void 0 ? i : s.custom, e) } const Du = e => Array.isArray(e); function Sk(e, r, i) { e.hasValue(r) ? e.getValue(r).set(i) : e.addValue(r, pi(i)) } function Ck(e) { return Du(e) ? e[e.length - 1] || 0 : e } function kk(e, r) { const i = ui(e, r); let { transitionEnd: s = {}, transition: a = {}, ...c } = i || {}; c = { ...c, ...s }; for (const u in c) { const f = Ck(c[u]); Sk(e, u, f) } } function bk(e) { return !!(ft(e) && e.add) } function _u(e, r) { const i = e.getValue("willChange"); if (bk(i)) return i.add(r); if (!i && bn.WillChange) { const s = new bn.WillChange("auto"); e.addValue("willChange", s), s.add(r) } } function lv(e) { return e.props[Qy] } const Nk = e => e !== null; function Pk(e, { repeat: r, repeatType: i = "loop" }, s) { const a = e.filter(Nk), c = r && i !== "loop" && r % 2 === 1 ? 0 : a.length - 1; return a[c] } const Ek = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, Tk = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), jk = { type: "keyframes", duration: .8 }, Ak = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, Rk = (e, { keyframes: r }) => r.length > 2 ? jk : vi.has(e) ? e.startsWith("scale") ? Tk(r[1]) : Ek : Ak; function Mk({ when: e, delay: r, delayChildren: i, staggerChildren: s, staggerDirection: a, repeat: c, repeatType: u, repeatDelay: f, from: h, elapsed: g, ...y }) { return !!Object.keys(y).length } const Md = (e, r, i, s = {}, a, c) => u => { const f = xd(s, e) || {}, h = f.delay || s.delay || 0; let { elapsed: g = 0 } = s; g = g - ln(h); const y = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: r.getVelocity(), ...f, delay: -g, onUpdate: S => { r.set(S), f.onUpdate && f.onUpdate(S) }, onComplete: () => { u(), f.onComplete && f.onComplete() }, name: e, motionValue: r, element: c ? void 0 : a }; Mk(f) || Object.assign(y, Rk(e, y)), y.duration && (y.duration = ln(y.duration)), y.repeatDelay && (y.repeatDelay = ln(y.repeatDelay)), y.from !== void 0 && (y.keyframes[0] = y.from); let v = !1; if ((y.type === !1 || y.duration === 0 && !y.repeatDelay) && (Tu(y), y.delay === 0 && (v = !0)), (bn.instantAnimations || bn.skipAnimations) && (v = !0, Tu(y), y.delay = 0), y.allowFlatten = !f.type && !f.ease, v && !c && r.get() !== void 0) { const S = Pk(y.keyframes, f); if (S !== void 0) { Oe.update(() => { y.onUpdate(S), y.onComplete() }); return } } return f.isSync ? new yd(y) : new JS(y) }; function Ik({ protectedKeys: e, needsAnimating: r }, i) { const s = e.hasOwnProperty(i) && r[i] !== !0; return r[i] = !1, s } function cv(e, r, { delay: i = 0, transitionOverride: s, type: a } = {}) { let { transition: c = e.getDefaultTransition(), transitionEnd: u, ...f } = r; s && (c = s); const h = [], g = a && e.animationState && e.animationState.getState()[a]; for (const y in f) { const v = e.getValue(y, e.latestValues[y] ?? null), S = f[y]; if (S === void 0 || g && Ik(g, y)) continue; const k = { delay: i, ...xd(c || {}, y) }, P = v.get(); if (P !== void 0 && !v.isAnimating && !Array.isArray(S) && S === P && !k.velocity) continue; let C = !1; if (window.MotionHandoffAnimation) { const j = lv(e); if (j) { const E = window.MotionHandoffAnimation(j, y, Oe); E !== null && (k.startTime = E, C = !0) } } _u(e, y), v.start(Md(y, v, S, e.shouldReduceMotion && Ty.has(y) ? { type: !1 } : k, e, C)); const N = v.animation; N && h.push(N) } return u && Promise.all(h).then(() => { Oe.update(() => { u && kk(e, u) }) }), h } function uv(e, r, i, s = 0, a = 1) { const c = Array.from(e).sort((g, y) => g.sortNodePosition(y)).indexOf(r), u = e.size, f = (u - 1) * s; return typeof i == "function" ? i(c, u) : a === 1 ? c * s : f - c * s } function Lu(e, r, i = {}) { const s = ui(e, r, i.type === "exit" ? e.presenceContext?.custom : void 0); let { transition: a = e.getDefaultTransition() || {} } = s || {}; i.transitionOverride && (a = i.transitionOverride); const c = s ? () => Promise.all(cv(e, s, i)) : () => Promise.resolve(), u = e.variantChildren && e.variantChildren.size ? (h = 0) => { const { delayChildren: g = 0, staggerChildren: y, staggerDirection: v } = a; return Dk(e, r, h, g, y, v, i) } : () => Promise.resolve(), { when: f } = a; if (f) { const [h, g] = f === "beforeChildren" ? [c, u] : [u, c]; return h().then(() => g()) } else return Promise.all([c(), u(i.delay)]) } function Dk(e, r, i = 0, s = 0, a = 0, c = 1, u) { const f = []; for (const h of e.variantChildren) h.notify("AnimationStart", r), f.push(Lu(h, r, { ...u, delay: i + (typeof s == "function" ? 0 : s) + uv(e.variantChildren, h, s, a, c) }).then(() => h.notify("AnimationComplete", r))); return Promise.all(f) } function _k(e, r, i = {}) { e.notify("AnimationStart", r); let s; if (Array.isArray(r)) { const a = r.map(c => Lu(e, c, i)); s = Promise.all(a) } else if (typeof r == "string") s = Lu(e, r, i); else { const a = typeof r == "function" ? ui(e, r, i.custom) : r; s = Promise.all(cv(e, a, i)) } return s.then(() => { e.notify("AnimationComplete", r) }) } function dv(e, r) { if (!Array.isArray(r)) return !1; const i = r.length; if (i !== e.length) return !1; for (let s = 0; s < i; s++)if (r[s] !== e[s]) return !1; return !0 } const Lk = Nd.length; function fv(e) { if (!e) return; if (!e.isControllingVariants) { const i = e.parent ? fv(e.parent) || {} : {}; return e.props.initial !== void 0 && (i.initial = e.props.initial), i } const r = {}; for (let i = 0; i < Lk; i++) { const s = Nd[i], a = e.props[s]; (bo(a) || a === !1) && (r[s] = a) } return r } const Ok = [...bd].reverse(), Vk = bd.length; function Fk(e) { return r => Promise.all(r.map(({ animation: i, options: s }) => _k(e, i, s))) } function zk(e) { let r = Fk(e), i = Am(), s = !0; const a = h => (g, y) => { const v = ui(e, y, h === "exit" ? e.presenceContext?.custom : void 0); if (v) { const { transition: S, transitionEnd: k, ...P } = v; g = { ...g, ...P, ...k } } return g }; function c(h) { r = h(e) } function u(h) { const { props: g } = e, y = fv(e.parent) || {}, v = [], S = new Set; let k = {}, P = 1 / 0; for (let N = 0; N < Vk; N++) { const j = Ok[N], E = i[j], R = g[j] !== void 0 ? g[j] : y[j], O = bo(R), V = j === h ? E.isActive : null; V === !1 && (P = N); let B = R === y[j] && R !== g[j] && O; if (B && s && e.manuallyAnimateOnMount && (B = !1), E.protectedKeys = { ...k }, !E.isActive && V === null || !R && !E.prevProp || Aa(R) || typeof R == "boolean") continue; const z = Bk(E.prevProp, R); let F = z || j === h && E.isActive && !B && O || N > P && O, Z = !1; const ie = Array.isArray(R) ? R : [R]; let fe = ie.reduce(a(j), {}); V === !1 && (fe = {}); const { prevResolvedValues: me = {} } = E, ge = { ...me, ...fe }, pe = q => { F = !0, S.has(q) && (Z = !0, S.delete(q)), E.needsAnimating[q] = !0; const I = e.getValue(q); I && (I.liveStyle = !1) }; for (const q in ge) { const I = fe[q], X = me[q]; if (k.hasOwnProperty(q)) continue; let G = !1; Du(I) && Du(X) ? G = !dv(I, X) : G = I !== X, G ? I != null ? pe(q) : S.add(q) : I !== void 0 && S.has(q) ? pe(q) : E.protectedKeys[q] = !0 } E.prevProp = R, E.prevResolvedValues = fe, E.isActive && (k = { ...k, ...fe }), s && e.blockInitialAnimation && (F = !1); const xe = B && z; F && (!xe || Z) && v.push(...ie.map(q => { const I = { type: j }; if (typeof q == "string" && s && !xe && e.manuallyAnimateOnMount && e.parent) { const { parent: X } = e, G = ui(X, q); if (X.enteringChildren && G) { const { delayChildren: M } = G.transition || {}; I.delay = uv(X.enteringChildren, e, M) } } return { animation: q, options: I } })) } if (S.size) { const N = {}; if (typeof g.initial != "boolean") { const j = ui(e, Array.isArray(g.initial) ? g.initial[0] : g.initial); j && j.transition && (N.transition = j.transition) } S.forEach(j => { const E = e.getBaseTarget(j), R = e.getValue(j); R && (R.liveStyle = !0), N[j] = E ?? null }), v.push({ animation: N }) } let C = !!v.length; return s && (g.initial === !1 || g.initial === g.animate) && !e.manuallyAnimateOnMount && (C = !1), s = !1, C ? r(v) : Promise.resolve() } function f(h, g) { if (i[h].isActive === g) return Promise.resolve(); e.variantChildren?.forEach(v => v.animationState?.setActive(h, g)), i[h].isActive = g; const y = u(h); for (const v in i) i[v].protectedKeys = {}; return y } return { animateChanges: u, setActive: f, setAnimateFunction: c, getState: () => i, reset: () => { i = Am() } } } function Bk(e, r) { return typeof r == "string" ? r !== e : Array.isArray(r) ? !dv(r, e) : !1 } function yr(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Am() { return { animate: yr(!0), whileInView: yr(), whileHover: yr(), whileTap: yr(), whileDrag: yr(), whileFocus: yr(), exit: yr() } } class er { constructor(r) { this.isMounted = !1, this.node = r } update() { } } class Wk extends er { constructor(r) { super(r), r.animationState || (r.animationState = zk(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); Aa(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: i } = this.node.prevProps || {}; r !== i && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let $k = 0; class Uk extends er { constructor() { super(...arguments), this.id = $k++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: i } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === s) return; const a = this.node.animationState.setActive("exit", !r); i && !r && a.then(() => { i(this.id) }) } mount() { const { register: r, onExitComplete: i } = this.node.presenceContext || {}; i && i(this.id), r && (this.unmount = r(this.id)) } unmount() { } } const Hk = { animation: { Feature: Wk }, exit: { Feature: Uk } }; function No(e, r, i, s = { passive: !0 }) { return e.addEventListener(r, i, s), () => e.removeEventListener(r, i) } function Mo(e) { return { point: { x: e.pageX, y: e.pageY } } } const Kk = e => r => Cd(r) && e(r, Mo(r)); function vo(e, r, i, s) { return No(e, r, Kk(i), s) } const pv = 1e-4, Gk = 1 - pv, Yk = 1 + pv, hv = .01, Xk = 0 - hv, qk = 0 + hv; function mt(e) { return e.max - e.min } function Qk(e, r, i) { return Math.abs(e - r) <= i } function Rm(e, r, i, s = .5) { e.origin = s, e.originPoint = ze(r.min, r.max, e.origin), e.scale = mt(i) / mt(r), e.translate = ze(i.min, i.max, e.origin) - e.originPoint, (e.scale >= Gk && e.scale <= Yk || isNaN(e.scale)) && (e.scale = 1), (e.translate >= Xk && e.translate <= qk || isNaN(e.translate)) && (e.translate = 0) } function xo(e, r, i, s) { Rm(e.x, r.x, i.x, s ? s.originX : void 0), Rm(e.y, r.y, i.y, s ? s.originY : void 0) } function Mm(e, r, i) { e.min = i.min + r.min, e.max = e.min + mt(r) } function Zk(e, r, i) { Mm(e.x, r.x, i.x), Mm(e.y, r.y, i.y) } function Im(e, r, i) { e.min = r.min - i.min, e.max = e.min + mt(r) } function xa(e, r, i) { Im(e.x, r.x, i.x), Im(e.y, r.y, i.y) } function Lt(e) { return [e("x"), e("y")] } const mv = ({ current: e }) => e ? e.ownerDocument.defaultView : null, Dm = (e, r) => Math.abs(e - r); function Jk(e, r) { const i = Dm(e.x, r.x), s = Dm(e.y, r.y); return Math.sqrt(i ** 2 + s ** 2) } class gv { constructor(r, i, { transformPagePoint: s, contextWindow: a = window, dragSnapToOrigin: c = !1, distanceThreshold: u = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const S = Yc(this.lastMoveEventInfo, this.history), k = this.startEvent !== null, P = Jk(S.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!k && !P) return; const { point: C } = S, { timestamp: N } = st; this.history.push({ ...C, timestamp: N }); const { onStart: j, onMove: E } = this.handlers; k || (j && j(this.lastMoveEvent, S), this.startEvent = this.lastMoveEvent), E && E(this.lastMoveEvent, S) }, this.handlePointerMove = (S, k) => { this.lastMoveEvent = S, this.lastMoveEventInfo = Gc(k, this.transformPagePoint), Oe.update(this.updatePoint, !0) }, this.handlePointerUp = (S, k) => { this.end(); const { onEnd: P, onSessionEnd: C, resumeAnimation: N } = this.handlers; if (this.dragSnapToOrigin && N && N(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const j = Yc(S.type === "pointercancel" ? this.lastMoveEventInfo : Gc(k, this.transformPagePoint), this.history); this.startEvent && P && P(S, j), C && C(S, j) }, !Cd(r)) return; this.dragSnapToOrigin = c, this.handlers = i, this.transformPagePoint = s, this.distanceThreshold = u, this.contextWindow = a || window; const f = Mo(r), h = Gc(f, this.transformPagePoint), { point: g } = h, { timestamp: y } = st; this.history = [{ ...g, timestamp: y }]; const { onSessionStart: v } = i; v && v(r, Yc(h, this.history)), this.removeListeners = jo(vo(this.contextWindow, "pointermove", this.handlePointerMove), vo(this.contextWindow, "pointerup", this.handlePointerUp), vo(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), qn(this.updatePoint) } } function Gc(e, r) { return r ? { point: r(e.point) } : e } function _m(e, r) { return { x: e.x - r.x, y: e.y - r.y } } function Yc({ point: e }, r) { return { point: e, delta: _m(e, yv(r)), offset: _m(e, eb(r)), velocity: tb(r, .1) } } function eb(e) { return e[0] } function yv(e) { return e[e.length - 1] } function tb(e, r) { if (e.length < 2) return { x: 0, y: 0 }; let i = e.length - 1, s = null; const a = yv(e); for (; i >= 0 && (s = e[i], !(a.timestamp - s.timestamp > ln(r)));)i--; if (!s) return { x: 0, y: 0 }; const c = Ot(a.timestamp - s.timestamp); if (c === 0) return { x: 0, y: 0 }; const u = { x: (a.x - s.x) / c, y: (a.y - s.y) / c }; return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u } function nb(e, { min: r, max: i }, s) { return r !== void 0 && e < r ? e = s ? ze(r, e, s.min) : Math.max(e, r) : i !== void 0 && e > i && (e = s ? ze(i, e, s.max) : Math.min(e, i)), e } function Lm(e, r, i) { return { min: r !== void 0 ? e.min + r : void 0, max: i !== void 0 ? e.max + i - (e.max - e.min) : void 0 } } function rb(e, { top: r, left: i, bottom: s, right: a }) { return { x: Lm(e.x, i, a), y: Lm(e.y, r, s) } } function Om(e, r) { let i = r.min - e.min, s = r.max - e.max; return r.max - r.min < e.max - e.min && ([i, s] = [s, i]), { min: i, max: s } } function ib(e, r) { return { x: Om(e.x, r.x), y: Om(e.y, r.y) } } function ob(e, r) { let i = .5; const s = mt(e), a = mt(r); return a > s ? i = So(r.min, r.max - s, e.min) : s > a && (i = So(e.min, e.max - a, r.min)), kn(0, 1, i) } function sb(e, r) { const i = {}; return r.min !== void 0 && (i.min = r.min - e.min), r.max !== void 0 && (i.max = r.max - e.min), i } const Ou = .35; function ab(e = Ou) { return e === !1 ? e = 0 : e === !0 && (e = Ou), { x: Vm(e, "left", "right"), y: Vm(e, "top", "bottom") } } function Vm(e, r, i) { return { min: Fm(e, r), max: Fm(e, i) } } function Fm(e, r) { return typeof e == "number" ? e : e[r] || 0 } const lb = new WeakMap; class cb { constructor(r) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Je(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = r } start(r, { snapToCursor: i = !1, distanceThreshold: s } = {}) { const { presenceContext: a } = this.visualElement; if (a && a.isPresent === !1) return; const c = v => { const { dragSnapToOrigin: S } = this.getProps(); S ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(Mo(v).point) }, u = (v, S) => { const { drag: k, dragPropagation: P, onDragStart: C } = this.getProps(); if (k && !P && (this.openDragLock && this.openDragLock(), this.openDragLock = hC(k), !this.openDragLock)) return; this.latestPointerEvent = v, this.latestPanInfo = S, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Lt(j => { let E = this.getAxisMotionValue(j).get() || 0; if (cn.test(E)) { const { projection: R } = this.visualElement; if (R && R.layout) { const O = R.layout.layoutBox[j]; O && (E = mt(O) * (parseFloat(E) / 100)) } } this.originPoint[j] = E }), C && Oe.postRender(() => C(v, S)), _u(this.visualElement, "transform"); const { animationState: N } = this.visualElement; N && N.setActive("whileDrag", !0) }, f = (v, S) => { this.latestPointerEvent = v, this.latestPanInfo = S; const { dragPropagation: k, dragDirectionLock: P, onDirectionLock: C, onDrag: N } = this.getProps(); if (!k && !this.openDragLock) return; const { offset: j } = S; if (P && this.currentDirection === null) { this.currentDirection = ub(j), this.currentDirection !== null && C && C(this.currentDirection); return } this.updateAxis("x", S.point, j), this.updateAxis("y", S.point, j), this.visualElement.render(), N && N(v, S) }, h = (v, S) => { this.latestPointerEvent = v, this.latestPanInfo = S, this.stop(v, S), this.latestPointerEvent = null, this.latestPanInfo = null }, g = () => Lt(v => this.getAnimationState(v) === "paused" && this.getAxisMotionValue(v).animation?.play()), { dragSnapToOrigin: y } = this.getProps(); this.panSession = new gv(r, { onSessionStart: c, onStart: u, onMove: f, onSessionEnd: h, resumeAnimation: g }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: y, distanceThreshold: s, contextWindow: mv(this.visualElement) }) } stop(r, i) { const s = r || this.latestPointerEvent, a = i || this.latestPanInfo, c = this.isDragging; if (this.cancel(), !c || !a || !s) return; const { velocity: u } = a; this.startAnimation(u); const { onDragEnd: f } = this.getProps(); f && Oe.postRender(() => f(s, a)) } cancel() { this.isDragging = !1; const { projection: r, animationState: i } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: s } = this.getProps(); !s && this.openDragLock && (this.openDragLock(), this.openDragLock = null), i && i.setActive("whileDrag", !1) } updateAxis(r, i, s) { const { drag: a } = this.getProps(); if (!s || !Zs(r, a, this.currentDirection)) return; const c = this.getAxisMotionValue(r); let u = this.originPoint[r] + s[r]; this.constraints && this.constraints[r] && (u = nb(u, this.constraints[r], this.elastic[r])), c.set(u) } resolveConstraints() { const { dragConstraints: r, dragElastic: i } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, a = this.constraints; r && si(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && s ? this.constraints = rb(s.layoutBox, r) : this.constraints = !1, this.elastic = ab(i), a !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && Lt(c => { this.constraints !== !1 && this.getAxisMotionValue(c) && (this.constraints[c] = sb(s.layoutBox[c], this.constraints[c])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: i } = this.getProps(); if (!r || !si(r)) return !1; const s = r.current, { projection: a } = this.visualElement; if (!a || !a.layout) return !1; const c = dk(s, a.root, this.visualElement.getTransformPagePoint()); let u = ib(a.layout.layoutBox, c); if (i) { const f = i(lk(u)); this.hasMutatedConstraints = !!f, f && (u = ev(f)) } return u } startAnimation(r) { const { drag: i, dragMomentum: s, dragElastic: a, dragTransition: c, dragSnapToOrigin: u, onDragTransitionEnd: f } = this.getProps(), h = this.constraints || {}, g = Lt(y => { if (!Zs(y, i, this.currentDirection)) return; let v = h && h[y] || {}; u && (v = { min: 0, max: 0 }); const S = a ? 200 : 1e6, k = a ? 40 : 1e7, P = { type: "inertia", velocity: s ? r[y] : 0, bounceStiffness: S, bounceDamping: k, timeConstant: 750, restDelta: 1, restSpeed: 10, ...c, ...v }; return this.startAxisValueAnimation(y, P) }); return Promise.all(g).then(f) } startAxisValueAnimation(r, i) { const s = this.getAxisMotionValue(r); return _u(this.visualElement, r), s.start(Md(r, s, 0, i, this.visualElement, !1)) } stopAnimation() { Lt(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { Lt(r => this.getAxisMotionValue(r).animation?.pause()) } getAnimationState(r) { return this.getAxisMotionValue(r).animation?.state } getAxisMotionValue(r) { const i = `_drag${r.toUpperCase()}`, s = this.visualElement.getProps(), a = s[i]; return a || this.visualElement.getValue(r, (s.initial ? s.initial[r] : void 0) || 0) } snapToCursor(r) { Lt(i => { const { drag: s } = this.getProps(); if (!Zs(i, s, this.currentDirection)) return; const { projection: a } = this.visualElement, c = this.getAxisMotionValue(i); if (a && a.layout) { const { min: u, max: f } = a.layout.layoutBox[i]; c.set(r[i] - ze(u, f, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: i } = this.getProps(), { projection: s } = this.visualElement; if (!si(i) || !s || !this.constraints) return; this.stopAnimation(); const a = { x: 0, y: 0 }; Lt(u => { const f = this.getAxisMotionValue(u); if (f && this.constraints !== !1) { const h = f.get(); a[u] = ob({ min: h, max: h }, this.constraints[u]) } }); const { transformTemplate: c } = this.visualElement.getProps(); this.visualElement.current.style.transform = c ? c({}, "") : "none", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), Lt(u => { if (!Zs(u, r, null)) return; const f = this.getAxisMotionValue(u), { min: h, max: g } = this.constraints[u]; f.set(ze(h, g, a[u])) }) } addListeners() { if (!this.visualElement.current) return; lb.set(this.visualElement, this); const r = this.visualElement.current, i = vo(r, "pointerdown", h => { const { drag: g, dragListener: y = !0 } = this.getProps(); g && y && this.start(h) }), s = () => { const { dragConstraints: h } = this.getProps(); si(h) && h.current && (this.constraints = this.resolveRefConstraints()) }, { projection: a } = this.visualElement, c = a.addEventListener("measure", s); a && !a.layout && (a.root && a.root.updateScroll(), a.updateLayout()), Oe.read(s); const u = No(window, "resize", () => this.scalePositionWithinConstraints()), f = a.addEventListener("didUpdate", (({ delta: h, hasLayoutChanged: g }) => { this.isDragging && g && (Lt(y => { const v = this.getAxisMotionValue(y); v && (this.originPoint[y] += h[y].translate, v.set(v.get() + h[y].translate)) }), this.visualElement.render()) })); return () => { u(), i(), c(), f && f() } } getProps() { const r = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: s = !1, dragPropagation: a = !1, dragConstraints: c = !1, dragElastic: u = Ou, dragMomentum: f = !0 } = r; return { ...r, drag: i, dragDirectionLock: s, dragPropagation: a, dragConstraints: c, dragElastic: u, dragMomentum: f } } } function Zs(e, r, i) { return (r === !0 || r === e) && (i === null || i === e) } function ub(e, r = 10) { let i = null; return Math.abs(e.y) > r ? i = "y" : Math.abs(e.x) > r && (i = "x"), i } class db extends er { constructor(r) { super(r), this.removeGroupControls = Vt, this.removeListeners = Vt, this.controls = new cb(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Vt } unmount() { this.removeGroupControls(), this.removeListeners() } } const zm = e => (r, i) => { e && Oe.postRender(() => e(r, i)) }; class fb extends er { constructor() { super(...arguments), this.removePointerDownListener = Vt } onPointerDown(r) { this.session = new gv(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: mv(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: i, onPan: s, onPanEnd: a } = this.node.getProps(); return { onSessionStart: zm(r), onStart: zm(i), onMove: s, onEnd: (c, u) => { delete this.session, a && Oe.postRender(() => a(c, u)) } } } mount() { this.removePointerDownListener = vo(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const ua = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let Xc = !1; class pb extends w.Component { componentDidMount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s, layoutId: a } = this.props, { projection: c } = r; c && (i.group && i.group.add(c), s && s.register && a && s.register(c), Xc && c.root.didUpdate(), c.addEventListener("animationComplete", () => { this.safeToRemove() }), c.setOptions({ ...c.options, onExitComplete: () => this.safeToRemove() })), ua.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: i, visualElement: s, drag: a, isPresent: c } = this.props, { projection: u } = s; return u && (u.isPresent = c, Xc = !0, a || r.layoutDependency !== i || i === void 0 || r.isPresent !== c ? u.willUpdate() : this.safeToRemove(), r.isPresent !== c && (c ? u.promote() : u.relegate() || Oe.postRender(() => { const f = u.getStack(); (!f || !f.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), Sd.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: i, switchLayoutGroup: s } = this.props, { projection: a } = r; Xc = !0, a && (a.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(a), s && s.deregister && s.deregister(a)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function vv(e) { const [r, i] = zy(), s = w.useContext(ed); return p.jsx(pb, { ...e, layoutGroup: s, switchLayoutGroup: w.useContext(Zy), isPresent: r, safeToRemove: i }) } function hb(e, r, i) { const s = ft(e) ? e : pi(e); return s.start(Md("", s, r, i)), s.animation } const mb = (e, r) => e.depth - r.depth; class gb { constructor() { this.children = [], this.isDirty = !1 } add(r) { rd(this.children, r), this.isDirty = !0 } remove(r) { id(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(mb), this.isDirty = !1, this.children.forEach(r) } } function yb(e, r) { const i = Ct.now(), s = ({ timestamp: a }) => { const c = a - i; c >= r && (qn(s), e(c - r)) }; return Oe.setup(s, !0), () => qn(s) } const xv = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], vb = xv.length, Bm = e => typeof e == "string" ? parseFloat(e) : e, Wm = e => typeof e == "number" || he.test(e); function xb(e, r, i, s, a, c) { a ? (e.opacity = ze(0, i.opacity ?? 1, wb(s)), e.opacityExit = ze(r.opacity ?? 1, 0, Sb(s))) : c && (e.opacity = ze(r.opacity ?? 1, i.opacity ?? 1, s)); for (let u = 0; u < vb; u++) { const f = `border${xv[u]}Radius`; let h = $m(r, f), g = $m(i, f); if (h === void 0 && g === void 0) continue; h || (h = 0), g || (g = 0), h === 0 || g === 0 || Wm(h) === Wm(g) ? (e[f] = Math.max(ze(Bm(h), Bm(g), s), 0), (cn.test(g) || cn.test(h)) && (e[f] += "%")) : e[f] = g } (r.rotate || i.rotate) && (e.rotate = ze(r.rotate || 0, i.rotate || 0, s)) } function $m(e, r) { return e[r] !== void 0 ? e[r] : e.borderRadius } const wb = wv(0, .5, iy), Sb = wv(.5, .95, Vt); function wv(e, r, i) { return s => s < e ? 0 : s > r ? 1 : i(So(e, r, s)) } function Um(e, r) { e.min = r.min, e.max = r.max } function Yt(e, r) { Um(e.x, r.x), Um(e.y, r.y) } function Hm(e, r) { e.translate = r.translate, e.scale = r.scale, e.originPoint = r.originPoint, e.origin = r.origin } function Km(e, r, i, s, a) { return e -= r, e = va(e, 1 / i, s), a !== void 0 && (e = va(e, 1 / a, s)), e } function Cb(e, r = 0, i = 1, s = .5, a, c = e, u = e) { if (cn.test(r) && (r = parseFloat(r), r = ze(u.min, u.max, r / 100) - u.min), typeof r != "number") return; let f = ze(c.min, c.max, s); e === c && (f -= r), e.min = Km(e.min, r, i, f, a), e.max = Km(e.max, r, i, f, a) } function Gm(e, r, [i, s, a], c, u) { Cb(e, r[i], r[s], r[a], r.scale, c, u) } const kb = ["x", "scaleX", "originX"], bb = ["y", "scaleY", "originY"]; function Ym(e, r, i, s) { Gm(e.x, r, kb, i ? i.x : void 0, s ? s.x : void 0), Gm(e.y, r, bb, i ? i.y : void 0, s ? s.y : void 0) } function Xm(e) { return e.translate === 0 && e.scale === 1 } function Sv(e) { return Xm(e.x) && Xm(e.y) } function qm(e, r) { return e.min === r.min && e.max === r.max } function Nb(e, r) { return qm(e.x, r.x) && qm(e.y, r.y) } function Qm(e, r) { return Math.round(e.min) === Math.round(r.min) && Math.round(e.max) === Math.round(r.max) } function Cv(e, r) { return Qm(e.x, r.x) && Qm(e.y, r.y) } function Zm(e) { return mt(e.x) / mt(e.y) } function Jm(e, r) { return e.translate === r.translate && e.scale === r.scale && e.originPoint === r.originPoint } class Pb { constructor() { this.members = [] } add(r) { rd(this.members, r), r.scheduleRender() } remove(r) { if (id(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const i = this.members[this.members.length - 1]; i && this.promote(i) } } relegate(r) { const i = this.members.findIndex(a => r === a); if (i === 0) return !1; let s; for (let a = i; a >= 0; a--) { const c = this.members[a]; if (c.isPresent !== !1) { s = c; break } } return s ? (this.promote(s), !0) : !1 } promote(r, i) { const s = this.lead; if (r !== s && (this.prevLead = s, this.lead = r, r.show(), s)) { s.instance && s.scheduleRender(), r.scheduleRender(), r.resumeFrom = s, i && (r.resumeFrom.preserveOpacity = !0), s.snapshot && (r.snapshot = s.snapshot, r.snapshot.latestValues = s.animationValues || s.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: a } = r.options; a === !1 && s.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: i, resumingFrom: s } = r; i.onExitComplete && i.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function Eb(e, r, i) { let s = ""; const a = e.x.translate / r.x, c = e.y.translate / r.y, u = i?.z || 0; if ((a || c || u) && (s = `translate3d(${a}px, ${c}px, ${u}px) `), (r.x !== 1 || r.y !== 1) && (s += `scale(${1 / r.x}, ${1 / r.y}) `), i) { const { transformPerspective: g, rotate: y, rotateX: v, rotateY: S, skewX: k, skewY: P } = i; g && (s = `perspective(${g}px) ${s}`), y && (s += `rotate(${y}deg) `), v && (s += `rotateX(${v}deg) `), S && (s += `rotateY(${S}deg) `), k && (s += `skewX(${k}deg) `), P && (s += `skewY(${P}deg) `) } const f = e.x.scale * r.x, h = e.y.scale * r.y; return (f !== 1 || h !== 1) && (s += `scale(${f}, ${h})`), s || "none" } const qc = ["", "X", "Y", "Z"], Tb = 1e3; let jb = 0; function Qc(e, r, i, s) { const { latestValues: a } = r; a[e] && (i[e] = a[e], r.setStaticValue(e, 0), s && (s[e] = 0)) } function kv(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: r } = e.options; if (!r) return; const i = lv(r); if (window.MotionHasOptimisedAnimation(i, "transform")) { const { layout: a, layoutId: c } = e.options; window.MotionCancelOptimisedAnimation(i, "transform", Oe, !(a || c)) } const { parent: s } = e; s && !s.hasCheckedOptimisedAppear && kv(s) } function bv({ attachResizeListener: e, defaultParent: r, measureScroll: i, checkIsScrollRoot: s, resetTransform: a }) { return class { constructor(u = {}, f = r?.()) { this.id = jb++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(Mb), this.nodes.forEach(Lb), this.nodes.forEach(Ob), this.nodes.forEach(Ib) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = u, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0; for (let h = 0; h < this.path.length; h++)this.path[h].shouldResetTransform = !0; this.root === this && (this.nodes = new gb) } addEventListener(u, f) { return this.eventHandlers.has(u) || this.eventHandlers.set(u, new ad), this.eventHandlers.get(u).add(f) } notifyListeners(u, ...f) { const h = this.eventHandlers.get(u); h && h.notify(...f) } hasListeners(u) { return this.eventHandlers.has(u) } mount(u) { if (this.instance) return; this.isSVG = Fy(u) && !wC(u), this.instance = u; const { layoutId: f, layout: h, visualElement: g } = this.options; if (g && !g.current && g.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (h || f) && (this.isLayoutDirty = !0), e) { let y, v = 0; const S = () => this.root.updateBlockedByResize = !1; Oe.read(() => { v = window.innerWidth }), e(u, () => { const k = window.innerWidth; k !== v && (v = k, this.root.updateBlockedByResize = !0, y && y(), y = yb(S, 250), ua.hasAnimatedSinceResize && (ua.hasAnimatedSinceResize = !1, this.nodes.forEach(ng))) }) } f && this.root.registerSharedNode(f, this), this.options.animate !== !1 && g && (f || h) && this.addEventListener("didUpdate", ({ delta: y, hasLayoutChanged: v, hasRelativeLayoutChanged: S, layout: k }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const P = this.options.transition || g.getDefaultTransition() || Wb, { onLayoutAnimationStart: C, onLayoutAnimationComplete: N } = g.getProps(), j = !this.targetLayout || !Cv(this.targetLayout, k), E = !v && S; if (this.options.layoutRoot || this.resumeFrom || E || v && (j || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const R = { ...xd(P, "layout"), onPlay: C, onComplete: N }; (g.shouldReduceMotion || this.options.layoutRoot) && (R.delay = 0, R.type = !1), this.startAnimation(R), this.setAnimationOrigin(y, E) } else v || ng(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = k }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const u = this.getStack(); u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), qn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Vb), this.animationId++) } getTransformTemplate() { const { visualElement: u } = this.options; return u && u.getProps().transformTemplate } willUpdate(u = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && kv(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let y = 0; y < this.path.length; y++) { const v = this.path[y]; v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1) } const { layoutId: f, layout: h } = this.options; if (f === void 0 && !h) return; const g = this.getTransformTemplate(); this.prevTransformTemplateValue = g ? g(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(eg); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(tg); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(_b), this.nodes.forEach(Ab), this.nodes.forEach(Rb)) : this.nodes.forEach(tg), this.clearAllSnapshots(); const f = Ct.now(); st.delta = kn(0, 1e3 / 60, f - st.timestamp), st.timestamp = f, st.isProcessing = !0, Fc.update.process(st), Fc.preRender.process(st), Fc.render.process(st), st.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Sd.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(Db), this.sharedNodes.forEach(Fb) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Oe.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Oe.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !mt(this.snapshot.measuredBox.x) && !mt(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let h = 0; h < this.path.length; h++)this.path[h].updateScroll(); const u = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Je(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: f } = this.options; f && f.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0) } updateScroll(u = "measure") { let f = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (f = !1), f && this.instance) { const h = s(this.instance); this.scroll = { animationId: this.root.animationId, phase: u, isRoot: h, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : h } } } resetTransform() { if (!a) return; const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, f = this.projectionDelta && !Sv(this.projectionDelta), h = this.getTransformTemplate(), g = h ? h(this.latestValues, "") : void 0, y = g !== this.prevTransformTemplateValue; u && this.instance && (f || xr(this.latestValues) || y) && (a(this.instance, g), this.shouldResetTransform = !1, this.scheduleRender()) } measure(u = !0) { const f = this.measurePageBox(); let h = this.removeElementScroll(f); return u && (h = this.removeTransform(h)), $b(h), { animationId: this.root.animationId, measuredBox: f, layoutBox: h, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: u } = this.options; if (!u) return Je(); const f = u.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(Ub))) { const { scroll: g } = this.root; g && (ai(f.x, g.offset.x), ai(f.y, g.offset.y)) } return f } removeElementScroll(u) { const f = Je(); if (Yt(f, u), this.scroll?.wasRoot) return f; for (let h = 0; h < this.path.length; h++) { const g = this.path[h], { scroll: y, options: v } = g; g !== this.root && y && v.layoutScroll && (y.wasRoot && Yt(f, u), ai(f.x, y.offset.x), ai(f.y, y.offset.y)) } return f } applyTransform(u, f = !1) { const h = Je(); Yt(h, u); for (let g = 0; g < this.path.length; g++) { const y = this.path[g]; !f && y.options.layoutScroll && y.scroll && y !== y.root && li(h, { x: -y.scroll.offset.x, y: -y.scroll.offset.y }), xr(y.latestValues) && li(h, y.latestValues) } return xr(this.latestValues) && li(h, this.latestValues), h } removeTransform(u) { const f = Je(); Yt(f, u); for (let h = 0; h < this.path.length; h++) { const g = this.path[h]; if (!g.instance || !xr(g.latestValues)) continue; Ru(g.latestValues) && g.updateSnapshot(); const y = Je(), v = g.measurePageBox(); Yt(y, v), Ym(f, g.latestValues, g.snapshot ? g.snapshot.layoutBox : void 0, y) } return xr(this.latestValues) && Ym(f, this.latestValues), f } setTargetDelta(u) { this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(u) { this.options = { ...this.options, ...u, crossfade: u.crossfade !== void 0 ? u.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== st.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(u = !1) { const f = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty); const h = !!this.resumingFrom || this !== f; if (!(u || h && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: y, layoutId: v } = this.options; if (!this.layout || !(y || v)) return; this.resolvedRelativeTargetAt = st.timestamp; const S = this.getClosestProjectingParent(); S && this.linkedParentVersion !== S.layoutVersion && !S.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (S && S.layout ? this.createRelativeTarget(S, this.layout.layoutBox, S.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Je(), this.targetWithTransforms = Je()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Zk(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Yt(this.target, this.layout.layoutBox), nv(this.target, this.targetDelta)) : Yt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, S && !!S.resumingFrom == !!this.resumingFrom && !S.options.layoutScroll && S.target && this.animationProgress !== 1 ? this.createRelativeTarget(S, this.target, S.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || Ru(this.parent.latestValues) || tv(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(u, f, h) { this.relativeParent = u, this.linkedParentVersion = u.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Je(), this.relativeTargetOrigin = Je(), xa(this.relativeTargetOrigin, f, h), Yt(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { const u = this.getLead(), f = !!this.resumingFrom || this !== u; let h = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (h = !1), f && (this.isSharedProjectionDirty || this.isTransformDirty) && (h = !1), this.resolvedRelativeTargetAt === st.timestamp && (h = !1), h) return; const { layout: g, layoutId: y } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(g || y)) return; Yt(this.layoutCorrected, this.layout.layoutBox); const v = this.treeScale.x, S = this.treeScale.y; uk(this.layoutCorrected, this.treeScale, this.path, f), u.layout && !u.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (u.target = u.layout.layoutBox, u.targetWithTransforms = Je()); const { target: k } = u; if (!k) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Hm(this.prevProjectionDelta.x, this.projectionDelta.x), Hm(this.prevProjectionDelta.y, this.projectionDelta.y)), xo(this.projectionDelta, this.layoutCorrected, k, this.latestValues), (this.treeScale.x !== v || this.treeScale.y !== S || !Jm(this.projectionDelta.x, this.prevProjectionDelta.x) || !Jm(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", k)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(u = !0) { if (this.options.visualElement?.scheduleRender(), u) { const f = this.getStack(); f && f.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = ci(), this.projectionDelta = ci(), this.projectionDeltaWithTransform = ci() } setAnimationOrigin(u, f = !1) { const h = this.snapshot, g = h ? h.latestValues : {}, y = { ...this.latestValues }, v = ci(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f; const S = Je(), k = h ? h.source : void 0, P = this.layout ? this.layout.source : void 0, C = k !== P, N = this.getStack(), j = !N || N.members.length <= 1, E = !!(C && !j && this.options.crossfade === !0 && !this.path.some(Bb)); this.animationProgress = 0; let R; this.mixTargetDelta = O => { const V = O / 1e3; rg(v.x, u.x, V), rg(v.y, u.y, V), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (xa(S, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zb(this.relativeTarget, this.relativeTargetOrigin, S, V), R && Nb(this.relativeTarget, R) && (this.isProjectionDirty = !1), R || (R = Je()), Yt(R, this.relativeTarget)), C && (this.animationValues = y, xb(y, g, this.latestValues, V, E, j)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(u) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (qn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Oe.update(() => { ua.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = pi(0)), this.currentAnimation = hb(this.motionValue, [0, 1e3], { ...u, velocity: 0, isSync: !0, onUpdate: f => { this.mixTargetDelta(f), u.onUpdate && u.onUpdate(f) }, onStop: () => { }, onComplete: () => { u.onComplete && u.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const u = this.getStack(); u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Tb), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const u = this.getLead(); let { targetWithTransforms: f, target: h, layout: g, latestValues: y } = u; if (!(!f || !h || !g)) { if (this !== u && this.layout && g && Nv(this.options.animationType, this.layout.layoutBox, g.layoutBox)) { h = this.target || Je(); const v = mt(this.layout.layoutBox.x); h.x.min = u.target.x.min, h.x.max = h.x.min + v; const S = mt(this.layout.layoutBox.y); h.y.min = u.target.y.min, h.y.max = h.y.min + S } Yt(f, h), li(f, y), xo(this.projectionDeltaWithTransform, this.layoutCorrected, f, y) } } registerSharedNode(u, f) { this.sharedNodes.has(u) || this.sharedNodes.set(u, new Pb), this.sharedNodes.get(u).add(f); const g = f.options.initialPromotionConfig; f.promote({ transition: g ? g.transition : void 0, preserveFollowOpacity: g && g.shouldPreserveFollowOpacity ? g.shouldPreserveFollowOpacity(f) : void 0 }) } isLead() { const u = this.getStack(); return u ? u.lead === this : !0 } getLead() { const { layoutId: u } = this.options; return u ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: u } = this.options; return u ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: u } = this.options; if (u) return this.root.sharedNodes.get(u) } promote({ needsReset: u, transition: f, preserveFollowOpacity: h } = {}) { const g = this.getStack(); g && g.promote(this, h), u && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f }) } relegate() { const u = this.getStack(); return u ? u.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: u } = this.options; if (!u) return; let f = !1; const { latestValues: h } = u; if ((h.z || h.rotate || h.rotateX || h.rotateY || h.rotateZ || h.skewX || h.skewY) && (f = !0), !f) return; const g = {}; h.z && Qc("z", u, g, this.animationValues); for (let y = 0; y < qc.length; y++)Qc(`rotate${qc[y]}`, u, g, this.animationValues), Qc(`skew${qc[y]}`, u, g, this.animationValues); u.render(); for (const y in g) u.setStaticValue(y, g[y]), this.animationValues && (this.animationValues[y] = g[y]); u.scheduleRender() } applyProjectionStyles(u, f) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { u.visibility = "hidden"; return } const h = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, u.visibility = "", u.opacity = "", u.pointerEvents = ca(f?.pointerEvents) || "", u.transform = h ? h(this.latestValues, "") : "none"; return } const g = this.getLead(); if (!this.projectionDelta || !this.layout || !g.target) { this.options.layoutId && (u.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, u.pointerEvents = ca(f?.pointerEvents) || ""), this.hasProjected && !xr(this.latestValues) && (u.transform = h ? h({}, "") : "none", this.hasProjected = !1); return } u.visibility = ""; const y = g.animationValues || g.latestValues; this.applyTransformsToTarget(); let v = Eb(this.projectionDeltaWithTransform, this.treeScale, y); h && (v = h(y, v)), u.transform = v; const { x: S, y: k } = this.projectionDelta; u.transformOrigin = `${S.origin * 100}% ${k.origin * 100}% 0`, g.animationValues ? u.opacity = g === this ? y.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : y.opacityExit : u.opacity = g === this ? y.opacity !== void 0 ? y.opacity : "" : y.opacityExit !== void 0 ? y.opacityExit : 0; for (const P in Au) { if (y[P] === void 0) continue; const { correct: C, applyTo: N, isCSSVariable: j } = Au[P], E = v === "none" ? y[P] : C(y[P], g); if (N) { const R = N.length; for (let O = 0; O < R; O++)u[N[O]] = E } else j ? this.options.visualElement.renderState.vars[P] = E : u[P] = E } this.options.layoutId && (u.pointerEvents = g === this ? ca(f?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(u => u.currentAnimation?.stop()), this.root.nodes.forEach(eg), this.root.sharedNodes.clear() } } } function Ab(e) { e.updateLayout() } function Rb(e) { const r = e.resumeFrom?.snapshot || e.snapshot; if (e.isLead() && e.layout && r && e.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: s } = e.layout, { animationType: a } = e.options, c = r.source !== e.layout.source; a === "size" ? Lt(y => { const v = c ? r.measuredBox[y] : r.layoutBox[y], S = mt(v); v.min = i[y].min, v.max = v.min + S }) : Nv(a, r.layoutBox, i) && Lt(y => { const v = c ? r.measuredBox[y] : r.layoutBox[y], S = mt(i[y]); v.max = v.min + S, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[y].max = e.relativeTarget[y].min + S) }); const u = ci(); xo(u, i, r.layoutBox); const f = ci(); c ? xo(f, e.applyTransform(s, !0), r.measuredBox) : xo(f, i, r.layoutBox); const h = !Sv(u); let g = !1; if (!e.resumeFrom) { const y = e.getClosestProjectingParent(); if (y && !y.resumeFrom) { const { snapshot: v, layout: S } = y; if (v && S) { const k = Je(); xa(k, r.layoutBox, v.layoutBox); const P = Je(); xa(P, i, S.layoutBox), Cv(k, P) || (g = !0), y.options.layoutRoot && (e.relativeTarget = P, e.relativeTargetOrigin = k, e.relativeParent = y) } } } e.notifyListeners("didUpdate", { layout: i, snapshot: r, delta: f, layoutDelta: u, hasLayoutChanged: h, hasRelativeLayoutChanged: g }) } else if (e.isLead()) { const { onExitComplete: i } = e.options; i && i() } e.options.transition = void 0 } function Mb(e) { e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function Ib(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function Db(e) { e.clearSnapshot() } function eg(e) { e.clearMeasurements() } function tg(e) { e.isLayoutDirty = !1 } function _b(e) { const { visualElement: r } = e.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), e.resetTransform() } function ng(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function Lb(e) { e.resolveTargetDelta() } function Ob(e) { e.calcProjection() } function Vb(e) { e.resetSkewAndRotation() } function Fb(e) { e.removeLeadSnapshot() } function rg(e, r, i) { e.translate = ze(r.translate, 0, i), e.scale = ze(r.scale, 1, i), e.origin = r.origin, e.originPoint = r.originPoint } function ig(e, r, i, s) { e.min = ze(r.min, i.min, s), e.max = ze(r.max, i.max, s) } function zb(e, r, i, s) { ig(e.x, r.x, i.x, s), ig(e.y, r.y, i.y, s) } function Bb(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const Wb = { duration: .45, ease: [.4, 0, .1, 1] }, og = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), sg = og("applewebkit/") && !og("chrome/") ? Math.round : Vt; function ag(e) { e.min = sg(e.min), e.max = sg(e.max) } function $b(e) { ag(e.x), ag(e.y) } function Nv(e, r, i) { return e === "position" || e === "preserve-aspect" && !Qk(Zm(r), Zm(i), .2) } function Ub(e) { return e !== e.root && e.scroll?.wasRoot } const Hb = bv({ attachResizeListener: (e, r) => No(e, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Zc = { current: void 0 }, Pv = bv({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Zc.current) { const e = new Hb({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Zc.current = e } return Zc.current }, resetTransform: (e, r) => { e.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), Kb = { pan: { Feature: fb }, drag: { Feature: db, ProjectionNode: Pv, MeasureLayout: vv } }; function lg(e, r, i) { const { props: s } = e; e.animationState && s.whileHover && e.animationState.setActive("whileHover", i === "Start"); const a = "onHover" + i, c = s[a]; c && Oe.postRender(() => c(r, Mo(r))) } class Gb extends er { mount() { const { current: r } = this.node; r && (this.unmount = mC(r, (i, s) => (lg(this.node, s, "Start"), a => lg(this.node, a, "End")))) } unmount() { } } class Yb extends er { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = jo(No(this.node.current, "focus", () => this.onFocus()), No(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function cg(e, r, i) { const { props: s } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && s.whileTap && e.animationState.setActive("whileTap", i === "Start"); const a = "onTap" + (i === "End" ? "" : i), c = s[a]; c && Oe.postRender(() => c(r, Mo(r))) } class Xb extends er { mount() { const { current: r } = this.node; r && (this.unmount = xC(r, (i, s) => (cg(this.node, s, "Start"), (a, { success: c }) => cg(this.node, a, c ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const Vu = new WeakMap, Jc = new WeakMap, qb = e => { const r = Vu.get(e.target); r && r(e) }, Qb = e => { e.forEach(qb) }; function Zb({ root: e, ...r }) { const i = e || document; Jc.has(i) || Jc.set(i, {}); const s = Jc.get(i), a = JSON.stringify(r); return s[a] || (s[a] = new IntersectionObserver(Qb, { root: e, ...r })), s[a] } function Jb(e, r, i) { const s = Zb(r); return Vu.set(e, i), s.observe(e), () => { Vu.delete(e), s.unobserve(e) } } const e2 = { some: 0, all: 1 }; class t2 extends er { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: i, margin: s, amount: a = "some", once: c } = r, u = { root: i ? i.current : void 0, rootMargin: s, threshold: typeof a == "number" ? a : e2[a] }, f = h => { const { isIntersecting: g } = h; if (this.isInView === g || (this.isInView = g, c && !g && this.hasEnteredView)) return; g && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", g); const { onViewportEnter: y, onViewportLeave: v } = this.node.getProps(), S = g ? y : v; S && S(h) }; return Jb(this.node.current, u, f) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: i } = this.node;["amount", "margin", "root"].some(n2(r, i)) && this.startObserver() } unmount() { } } function n2({ viewport: e = {} }, { viewport: r = {} } = {}) { return i => e[i] !== r[i] } const r2 = { inView: { Feature: t2 }, tap: { Feature: Xb }, focus: { Feature: Yb }, hover: { Feature: Gb } }, i2 = { layout: { ProjectionNode: Pv, MeasureLayout: vv } }, o2 = { ...Hk, ...r2, ...Kb, ...i2 }, Ne = ak(o2, wk), s2 = { some: 0, all: 1 }; function a2(e, r, { root: i, margin: s, amount: a = "some" } = {}) { const c = Iy(e), u = new WeakMap, f = g => { g.forEach(y => { const v = u.get(y.target); if (y.isIntersecting !== !!v) if (y.isIntersecting) { const S = r(y.target, y); typeof S == "function" ? u.set(y.target, S) : h.unobserve(y.target) } else typeof v == "function" && (v(y), u.delete(y.target)) }) }, h = new IntersectionObserver(f, { root: i, rootMargin: s, threshold: typeof a == "number" ? a : s2[a] }); return c.forEach(g => h.observe(g)), () => h.disconnect() } function l2(e, { root: r, margin: i, amount: s, once: a = !1, initial: c = !1 } = {}) { const [u, f] = w.useState(c); return w.useEffect(() => { if (!e.current || a && u) return; const h = () => (f(!0), a ? void 0 : () => f(!1)), g = { root: r && r.current || void 0, margin: i, amount: s }; return a2(e.current, h, g) }, [r, e, i, a, s]), u }/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const c2 = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), u2 = e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (r, i, s) => s ? s.toUpperCase() : i.toLowerCase()), ug = e => { const r = u2(e); return r.charAt(0).toUpperCase() + r.slice(1) }, Ev = (...e) => e.filter((r, i, s) => !!r && r.trim() !== "" && s.indexOf(r) === i).join(" ").trim();/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var d2 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const f2 = w.forwardRef(({ color: e = "currentColor", size: r = 24, strokeWidth: i = 2, absoluteStrokeWidth: s, className: a = "", children: c, iconNode: u, ...f }, h) => w.createElement("svg", { ref: h, ...d2, width: r, height: r, stroke: e, strokeWidth: s ? Number(i) * 24 / Number(r) : i, className: Ev("lucide", a), ...f }, [...u.map(([g, y]) => w.createElement(g, y)), ...Array.isArray(c) ? c : [c]]));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const je = (e, r) => { const i = w.forwardRef(({ className: s, ...a }, c) => w.createElement(f2, { ref: c, iconNode: r, className: Ev(`lucide-${c2(ug(e))}`, `lucide-${e}`, s), ...a })); return i.displayName = ug(e), i };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const p2 = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]], Xn = je("arrow-right", p2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const h2 = [["path", { d: "m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526", key: "1yiouv" }], ["circle", { cx: "12", cy: "8", r: "6", key: "1vp47v" }]], m2 = je("award", h2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const g2 = [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]], Tv = je("calendar", g2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const y2 = [["path", { d: "M3 3v16a2 2 0 0 0 2 2h16", key: "c24i48" }], ["path", { d: "M18 17V9", key: "2bz60n" }], ["path", { d: "M13 17V5", key: "1frdt8" }], ["path", { d: "M8 17v-3", key: "17ska0" }]], Fu = je("chart-column", y2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v2 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], jv = je("check", v2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const x2 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Id = je("chevron-down", x2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const w2 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], S2 = je("chevron-up", w2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const C2 = [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]], wo = je("circle-check-big", C2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const k2 = [["rect", { x: "2", y: "6", width: "20", height: "8", rx: "1", key: "1estib" }], ["path", { d: "M17 14v7", key: "7m2elx" }], ["path", { d: "M7 14v7", key: "1cm7wv" }], ["path", { d: "M17 3v3", key: "1v4jwn" }], ["path", { d: "M7 3v3", key: "7o6guu" }], ["path", { d: "M10 14 2.3 6.3", key: "1023jk" }], ["path", { d: "m14 6 7.7 7.7", key: "1s8pl2" }], ["path", { d: "m8 6 8 8", key: "hl96qh" }]], b2 = je("construction", k2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const N2 = [["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }], ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]], P2 = je("dollar-sign", N2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const E2 = [["path", { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }]], T2 = je("facebook", E2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const j2 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }], ["path", { d: "M2 12h20", key: "9i4pu4" }]], A2 = je("globe", j2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R2 = [["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }], ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }], ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]], M2 = je("instagram", R2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const I2 = [["path", { d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z", key: "c2jq9f" }], ["rect", { width: "4", height: "12", x: "2", y: "9", key: "mk3on5" }], ["circle", { cx: "4", cy: "4", r: "2", key: "bt5ra8" }]], D2 = je("linkedin", I2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _2 = [["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }], ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]], L2 = je("lock", _2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const O2 = [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]], V2 = je("mail", O2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const F2 = [["path", { d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0", key: "1r0f0z" }], ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }]], z2 = je("map-pin", F2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const B2 = [["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }], ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }], ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]], W2 = je("menu", B2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $2 = [["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]], Av = je("message-square", $2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const U2 = [["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1", key: "4q2zg0" }], ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1", key: "8cvhb9" }], ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1", key: "1egb70" }], ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3", key: "1jsf9p" }], ["path", { d: "M12 12V8", key: "2874zd" }]], H2 = je("network", U2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const K2 = [["path", { d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z", key: "foiqr5" }]], G2 = je("phone", K2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Y2 = [["path", { d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z", key: "1ffxy3" }], ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]], X2 = je("send", Y2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const q2 = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }]], eu = je("shield", q2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Q2 = [["path", { d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z", key: "r04s7s" }]], dg = je("star", Q2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Z2 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["circle", { cx: "12", cy: "12", r: "6", key: "1vlfrh" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }]], J2 = je("target", Z2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const eN = [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]], tN = je("trash-2", eN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nN = [["polyline", { points: "22 17 13.5 8.5 8.5 13.5 2 7", key: "1r2t7k" }], ["polyline", { points: "16 17 22 17 22 11", key: "11uiuu" }]], rN = je("trending-down", nN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const iN = [["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }], ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]], Rv = je("trending-up", iN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oN = [["path", { d: "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z", key: "pff0z6" }]], sN = je("twitter", oN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aN = [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }], ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]], fg = je("users", aN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lN = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], Mv = je("x", lN);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cN = [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]], uN = je("zap", cN); function Io() { const [e, r] = w.useState(!1), [i, s] = w.useState(!1); w.useEffect(() => { const u = () => { r(window.scrollY > 10) }; return window.addEventListener("scroll", u), () => window.removeEventListener("scroll", u) }, []); const a = u => { u.preventDefault(), window.location.hash = "", window.scrollTo({ top: 0, behavior: "smooth" }) }, c = [{ name: "Features", href: "#features" }, { name: "Pricing", href: "#pricing" }, { name: "Case Studies", href: "#case-studies" }, { name: "Blog", href: "#blog" }]; return p.jsxs("nav", { className: `fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${e ? "bg-white shadow-md" : "bg-white/95 backdrop-blur-sm"}`, children: [p.jsx("div", { className: "container-custom", children: p.jsxs("div", { className: "flex items-center justify-between h-16 md:h-20", children: [p.jsxs("a", { href: "#", className: "flex items-center space-x-2", onClick: a, children: [p.jsx("div", { className: "w-10 h-10 bg-primary-600 rounded-full flex items-center justify-center", children: p.jsx("div", { className: "w-5 h-5 border-3 border-white rounded-full" }) }), p.jsx("span", { className: "text-xl font-bold text-neutral-900", children: "Mizan" })] }), p.jsx("div", { className: "hidden md:flex items-center space-x-8", children: c.map(u => p.jsx("a", { href: u.href, className: "text-neutral-600 hover:text-primary-600 transition-colors", children: u.name }, u.href)) }), p.jsxs("div", { className: "hidden md:flex items-center space-x-4", children: [p.jsx("a", { href: "#contact", className: "text-neutral-600 hover:text-primary-600 transition-colors", children: "Book Demo" }), p.jsx("a", { href: "#contact", className: "bg-primary-600 text-white px-6 py-2.5 rounded-lg hover:bg-primary-700 transition-colors", children: "Start Free Trial" })] }), p.jsx("button", { onClick: () => s(!i), className: "md:hidden text-neutral-900", "aria-label": "Toggle menu", children: i ? p.jsx(Mv, { size: 24 }) : p.jsx(W2, { size: 24 }) })] }) }), p.jsx(jC, { children: i && p.jsx(Ne.div, { initial: { opacity: 0, height: 0 }, animate: { opacity: 1, height: "auto" }, exit: { opacity: 0, height: 0 }, className: "md:hidden bg-white border-t border-neutral-200", children: p.jsxs("div", { className: "container-custom py-4 space-y-4", children: [c.map(u => p.jsx("a", { href: u.href, className: "block text-neutral-600 hover:text-primary-600 transition-colors py-2", onClick: () => s(!1), children: u.name }, u.href)), p.jsxs("div", { className: "pt-4 space-y-3 border-t border-neutral-200", children: [p.jsx("a", { href: "#contact", className: "block text-center text-neutral-600 hover:text-primary-600 transition-colors py-2", onClick: () => s(!1), children: "Book Demo" }), p.jsx("a", { href: "#contact", className: "block text-center bg-primary-600 text-white px-6 py-2.5 rounded-lg hover:bg-primary-700 transition-colors", onClick: () => s(!1), children: "Start Free Trial" })] })] }) }) })] }) } function Do() { const e = { product: [{ name: "Features", href: "#features" }, { name: "Pricing", href: "#pricing" }, { name: "Case Studies", href: "#case-studies" }, { name: "Integration", href: "#features" }], company: [{ name: "About", href: "#about" }, { name: "Blog", href: "#blog" }, { name: "Careers", href: "#careers" }, { name: "Contact", href: "#contact" }], resources: [{ name: "Help Center", href: "#help" }, { name: "Documentation", href: "#docs" }, { name: "API Reference", href: "#api" }, { name: "System Status", href: "#status" }], legal: [{ name: "Privacy Policy", href: "#privacy" }, { name: "Terms of Service", href: "#terms" }, { name: "Cookie Policy", href: "#cookies" }, { name: "GDPR", href: "#gdpr" }] }; return p.jsx("footer", { className: "bg-neutral-900 text-neutral-300", children: p.jsxs("div", { className: "container-custom py-12 md:py-16", children: [p.jsxs("div", { className: "grid grid-cols-2 md:grid-cols-6 gap-8 mb-8", children: [p.jsxs("div", { className: "col-span-2", children: [p.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [p.jsx("div", { className: "w-10 h-10 bg-primary-600 rounded-full flex items-center justify-center", children: p.jsx("div", { className: "w-5 h-5 border-3 border-white rounded-full" }) }), p.jsx("span", { className: "text-xl font-bold text-white", children: "Mizan" })] }), p.jsx("p", { className: "text-neutral-400 mb-6 max-w-sm", children: "The intelligent restaurant management platform. Streamline operations, empower your team, and boost profitability." }), p.jsxs("div", { className: "flex space-x-4", children: [p.jsx("a", { href: "#", className: "text-neutral-400 hover:text-white transition-colors", children: p.jsx(T2, { size: 20 }) }), p.jsx("a", { href: "#", className: "text-neutral-400 hover:text-white transition-colors", children: p.jsx(sN, { size: 20 }) }), p.jsx("a", { href: "#", className: "text-neutral-400 hover:text-white transition-colors", children: p.jsx(D2, { size: 20 }) }), p.jsx("a", { href: "#", className: "text-neutral-400 hover:text-white transition-colors", children: p.jsx(M2, { size: 20 }) })] })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-white mb-4", children: "Product" }), p.jsx("ul", { className: "space-y-2", children: e.product.map(r => p.jsx("li", { children: p.jsx("a", { href: r.href, className: "text-neutral-400 hover:text-white transition-colors", children: r.name }) }, r.href)) })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-white mb-4", children: "Company" }), p.jsx("ul", { className: "space-y-2", children: e.company.map(r => p.jsx("li", { children: p.jsx("a", { href: r.href, className: "text-neutral-400 hover:text-white transition-colors", children: r.name }) }, r.href)) })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-white mb-4", children: "Resources" }), p.jsx("ul", { className: "space-y-2", children: e.resources.map(r => p.jsx("li", { children: p.jsx("a", { href: r.href, className: "text-neutral-400 hover:text-white transition-colors", children: r.name }) }, r.href)) })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-white mb-4", children: "Legal" }), p.jsx("ul", { className: "space-y-2", children: e.legal.map(r => p.jsx("li", { children: p.jsx("a", { href: r.href, className: "text-neutral-400 hover:text-white transition-colors", children: r.name }) }, r.href)) })] })] }), p.jsx("div", { className: "pt-8 border-t border-neutral-800", children: p.jsxs("div", { className: "flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0", children: [p.jsx("p", { className: "text-neutral-400", children: " 2025 Mizan AI. All rights reserved." }), p.jsx("p", { className: "text-neutral-400", children: "Built for restaurant operators, by restaurant technology experts." })] }) })] }) }) } function dN({ end: e, duration: r = 2, suffix: i = "", prefix: s = "" }) { const [a, c] = w.useState(0), u = w.useRef(null), f = l2(u, { once: !0 }); return w.useEffect(() => { if (!f) return; let h = null; const g = y => { h || (h = y); const v = Math.min((y - h) / (r * 1e3), 1); c(Math.floor(v * e)), v < 1 && requestAnimationFrame(g) }; requestAnimationFrame(g) }, [f, e, r]), p.jsxs(Ne.span, { ref: u, initial: { opacity: 0 }, animate: f ? { opacity: 1 } : {}, transition: { duration: .5 }, children: [s, a, i] }) } const fN = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBvcGFjaXR5PSIuMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIzLjciPjxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjU2IiBoZWlnaHQ9IjU2IiByeD0iNiIvPjxwYXRoIGQ9Im0xNiA1OCAxNi0xOCAzMiAzMiIvPjxjaXJjbGUgY3g9IjUzIiBjeT0iMzUiIHI9IjciLz48L3N2Zz4KCg=="; function tu(e) { const [r, i] = w.useState(!1), s = () => { i(!0) }, { src: a, alt: c, style: u, className: f, ...h } = e; return r ? p.jsx("div", { className: `inline-block bg-gray-100 text-center align-middle ${f ?? ""}`, style: u, children: p.jsx("div", { className: "flex items-center justify-center w-full h-full", children: p.jsx("img", { src: fN, alt: "Error loading image", ...h, "data-original-url": a }) }) }) : p.jsx("img", { src: a, alt: c, className: f, style: u, ...h, onError: s }) } function pN() { const e = [{ icon: Tv, title: "Smart Scheduling", description: "AI-powered scheduling that considers availability, skills, and labor costs. Cut scheduling time by 70%." }, { icon: Av, title: "WhatsApp Integration", description: "Communicate with your team where they already are. Send schedules, updates, and reminders instantly." }, { icon: Fu, title: "Performance Analytics", description: "Track KPIs, sales per labor hour, and team performance. Make data-driven decisions that boost profitability." }], r = [{ value: 500, suffix: "+", label: "Restaurants using Mizan" }, { value: 70, suffix: "%", label: "Reduction in scheduling time" }, { value: 35, suffix: "%", label: "Decrease in staff turnover" }, { value: 99, suffix: "%", label: "WhatsApp message delivery rate" }], i = [{ quote: "Mizan completely transformed how we manage our three locations. What used to take hours now takes minutes.", author: "Hamza Hadni", role: "Owner, Baromete, Marrakesh", image: "" }, { quote: "Our staff turnover dropped by 40% since implementing Mizan. The team loves the WhatsApp integration.", author: "Mohammed Al-Habib", role: "General Manager, Coastal Kitchen", image: "" }, { quote: "The performance insights helped us identify and fix issues we didn't even know existed. ROI in the first month.", author: "Ali Haidar", role: "General Manager, Ima Restaurant, Benguerir", image: "" }], s = ["Reduce scheduling conflicts", "Improve team communication", "Track labor costs in real-time", "Reduce no-shows by 60%", "Automated shift reminders", "Performance-based insights"]; return p.jsxs("div", { className: "min-h-screen bg-white", children: [p.jsx(Io, {}), p.jsx("section", { className: "pt-32 pb-20 md:pt-40 md:pb-28 bg-gradient-to-br from-neutral-50 to-primary-50/30 overflow-hidden", children: p.jsx("div", { className: "container-custom", children: p.jsxs("div", { className: "grid md:grid-cols-2 gap-12 items-center", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, children: [p.jsxs("div", { className: "inline-flex items-center space-x-2 bg-secondary-50 text-secondary-700 px-4 py-2 rounded-full mb-6", children: [p.jsx(dg, { size: 16, fill: "currentColor" }), p.jsx("span", { className: "text-sm", children: "Trusted by 500+ restaurants" })] }), p.jsx("h1", { className: "text-neutral-900 mb-6", children: "The operating system your restaurant actually needs" }), p.jsx("p", { className: "text-xl text-neutral-600 mb-8", children: "Mizan streamlines scheduling, reduces no-shows, and boosts team performance through intelligent automation and WhatsApp integration" }), p.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 mb-8", children: [p.jsxs("a", { href: "#contact", className: "bg-primary-600 text-white px-8 py-4 rounded-lg hover:bg-primary-700 transition-colors text-center inline-flex items-center justify-center space-x-2", children: [p.jsx("span", { children: "Start Free Trial" }), p.jsx(Xn, { size: 20 })] }), p.jsx("a", { href: "#contact", className: "border-2 border-neutral-300 text-neutral-900 px-8 py-4 rounded-lg hover:border-primary-600 hover:text-primary-600 transition-colors text-center", children: "Book a Demo" })] }), p.jsxs("div", { className: "flex items-center space-x-6 text-sm text-neutral-600", children: [p.jsxs("div", { className: "flex items-center space-x-2", children: [p.jsx(wo, { size: 16, className: "text-secondary-600" }), p.jsx("span", { children: "14-day free trial" })] }), p.jsxs("div", { className: "flex items-center space-x-2", children: [p.jsx(wo, { size: 16, className: "text-secondary-600" }), p.jsx("span", { children: "No credit card required" })] })] })] }), p.jsx(Ne.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { duration: .6, delay: .2 }, className: "relative", children: p.jsxs("div", { className: "relative rounded-2xl overflow-hidden shadow-2xl", children: [p.jsx(tu, { src: "https://images.unsplash.com/photo-1414235077428-338989a2e8c0?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", alt: "Restaurant manager using Mizan on tablet", className: "w-full h-auto" }), p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .8 }, className: "absolute bottom-4 left-4 right-4 bg-white rounded-xl shadow-xl p-4", children: [p.jsxs("div", { className: "flex items-center justify-between mb-2", children: [p.jsx("span", { className: "text-sm text-neutral-600", children: "Today's Overview" }), p.jsxs("div", { className: "flex items-center space-x-1 text-primary-600", children: [p.jsx(Rv, { size: 16 }), p.jsx("span", { className: "text-sm", children: "+12%" })] })] }), p.jsxs("div", { className: "grid grid-cols-3 gap-2", children: [p.jsxs("div", { className: "bg-neutral-50 rounded-lg p-2", children: [p.jsx("div", { className: "text-xs text-neutral-500", children: "Staff" }), p.jsx("div", { className: "font-bold text-neutral-900", children: "24" })] }), p.jsxs("div", { className: "bg-neutral-50 rounded-lg p-2", children: [p.jsx("div", { className: "text-xs text-neutral-500", children: "Hours" }), p.jsx("div", { className: "font-bold text-neutral-900", children: "186" })] }), p.jsxs("div", { className: "bg-neutral-50 rounded-lg p-2", children: [p.jsx("div", { className: "text-xs text-neutral-500", children: "Labor %" }), p.jsx("div", { className: "font-bold text-neutral-900", children: "28.4" })] })] })] })] }) })] }) }) }), p.jsx("section", { className: "section-padding-sm bg-primary-600 text-white", children: p.jsx("div", { className: "container-custom", children: p.jsx("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-8", children: r.map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6, delay: c * .1 }, className: "text-center", children: [p.jsx("div", { className: "text-4xl md:text-5xl font-bold mb-2", children: p.jsx(dN, { end: a.value, suffix: a.suffix }) }), p.jsx("div", { className: "text-primary-100", children: a.label })] }, c)) }) }) }), p.jsx("section", { className: "section-padding", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsx("h2", { className: "text-neutral-900 mb-4", children: "Everything you need to run a better restaurant" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto", children: "Powerful features designed specifically for the unique challenges of restaurant operations" })] }), p.jsx("div", { className: "grid md:grid-cols-3 gap-8", children: e.map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { duration: .6, delay: c * .1 }, className: "bg-white border border-neutral-200 rounded-2xl p-8 hover:shadow-xl hover:border-primary-200 transition-all duration-300", children: [p.jsx("div", { className: "w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center mb-6", children: p.jsx(a.icon, { className: "text-primary-600", size: 24 }) }), p.jsx("h3", { className: "text-neutral-900 mb-4", children: a.title }), p.jsx("p", { className: "text-neutral-600", children: a.description })] }, c)) })] }) }), p.jsx("section", { className: "section-padding bg-neutral-50", children: p.jsx("div", { className: "container-custom", children: p.jsxs("div", { className: "grid md:grid-cols-2 gap-12 items-center", children: [p.jsxs(Ne.div, { initial: { opacity: 0, x: -20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, children: [p.jsx("h2", { className: "text-neutral-900 mb-6", children: "Built for the way restaurants actually work" }), p.jsx("p", { className: "text-lg text-neutral-600 mb-8", children: "We understand the complexity of restaurant operations. Mizan adapts to your workflow, not the other way around." }), p.jsx("div", { className: "grid grid-cols-1 gap-4", children: s.map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, x: -20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, transition: { delay: c * .05 }, className: "flex items-center space-x-3", children: [p.jsx(wo, { className: "text-secondary-600 flex-shrink-0", size: 20 }), p.jsx("span", { className: "text-neutral-700", children: a })] }, c)) }), p.jsxs("a", { href: "#features", className: "inline-flex items-center space-x-2 text-primary-600 hover:text-primary-700 mt-8", children: [p.jsx("span", { children: "Explore all features" }), p.jsx(Xn, { size: 20 })] })] }), p.jsx(Ne.div, { initial: { opacity: 0, x: 20 }, whileInView: { opacity: 1, x: 0 }, viewport: { once: !0 }, className: "relative", children: p.jsx(tu, { src: "https://plus.unsplash.com/premium_photo-1661883237884-263e8de8869b?q=80&w=2089&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", alt: "Restaurant staff team working together", className: "rounded-2xl shadow-2xl w-full" }) })] }) }) }), p.jsx("section", { className: "section-padding", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsx("h2", { className: "text-neutral-900 mb-4", children: "Loved by restaurant operators worldwide" }), p.jsx("p", { className: "text-xl text-neutral-600", children: "Join hundreds of restaurants already saving time and money with Mizan" })] }), p.jsx("div", { className: "grid md:grid-cols-3 gap-8", children: i.map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: c * .1 }, className: "bg-white border border-neutral-200 rounded-2xl p-8", children: [p.jsx("div", { className: "flex mb-4", children: [...Array(5)].map((u, f) => p.jsx(dg, { size: 16, className: "text-secondary-500 fill-secondary-500" }, f)) }), p.jsx("p", { className: "text-neutral-700 mb-6", children: a.quote }), p.jsxs("div", { className: "flex items-center space-x-3", children: [p.jsx(tu, { src: a.image, alt: a.author, className: "w-12 h-12 rounded-full object-cover" }), p.jsxs("div", { children: [p.jsx("div", { className: "text-neutral-900", children: a.author }), p.jsx("div", { className: "text-sm text-neutral-500", children: a.role })] })] })] }, c)) })] }) }), p.jsx("section", { className: "section-padding bg-gradient-to-br from-primary-600 to-primary-800 text-white", children: p.jsx("div", { className: "container-custom text-center", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, children: [p.jsx("h2", { className: "text-white mb-6", children: "Ready to transform your restaurant operations?" }), p.jsx("p", { className: "text-xl text-primary-100 mb-8 max-w-2xl mx-auto", children: "Join 500+ restaurants already saving time and boosting profits with Mizan" }), p.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [p.jsxs("a", { href: "#contact", className: "bg-white text-primary-600 px-8 py-4 rounded-lg hover:bg-neutral-100 transition-colors inline-flex items-center justify-center space-x-2", children: [p.jsx("span", { children: "Start Free Trial" }), p.jsx(Xn, { size: 20 })] }), p.jsx("a", { href: "#pricing", className: "border-2 border-white text-white px-8 py-4 rounded-lg hover:bg-white/10 transition-colors", children: "View Pricing" })] }), p.jsx("p", { className: "text-primary-100 mt-6", children: "14-day free trial  No credit card required  Cancel anytime" })] }) }) }), p.jsx(Do, {})] }) } function hN() { const e = [{ category: "AI-Powered Business Intelligence", icon: Fu, color: "primary", features: [{ name: "Profitability Dashboard", description: "Real-time view of food cost, labor cost, prime cost." }, { name: "Menu Engineering", description: "Identifies top & bottom performers by profit and popularity." }, { name: "Waste Tracking & Prediction", description: "AI forecasts demand to reduce spoilage and over-ordering." }], benefit: "Make data-driven decisions to directly increase margins and reduce loss." }, { category: "Labor & Cost Optimization", icon: P2, color: "secondary", features: [{ name: "AI Staff Scheduling", description: "Auto-creates optimized schedules considering sales forecasts, staff rules, and labor budgets." }, { name: "Automated Time & Attendance", description: "Geolocation clock-in/out integrated directly with payroll." }, { name: "Overtime & Compliance Alerts", description: "Get warnings before labor law violations or budget overruns." }], benefit: "Control your largest controllable cost. Save management time and avoid costly penalties." }, { category: "Operational Command Center", icon: J2, color: "primary", features: [{ name: "Unified Inbox", description: "See all staff communication, incident reports, and supplier updates in one place." }, { name: "Automated Task & Checklist System", description: "Ensure consistent opening, closing, and safety procedures." }, { name: "Centralized Document Hub", description: "Store manuals, training videos, and compliance docs." }], benefit: "Replace chaos with clarity. Have a single source of truth for your entire operation." }], r = [{ category: "WhatsApp-First Staff Hub", icon: Av, color: "primary", features: [{ name: "Clock In/Out via WhatsApp", description: "Simple location-based verification in the app they already use." }, { name: "Shift Tasks & Checklists", description: "Receive and complete daily tasks directly in chat with photo proof." }, { name: "Voice-to-Ticket Reporting", description: "Report any issue via a voice note; AI logs it and alerts the right manager." }], benefit: "Zero training. Use the tool they already have (WhatsApp) to save time and reduce friction." }, { category: "Intelligent Scheduling & Communication", icon: Tv, color: "secondary", features: [{ name: "Personalized Shift Alerts", description: "Get reminders with traffic and prep notes." }, { name: "In-App Team Chat", description: "Role-based channels (Kitchen, Front-of-House) without sharing personal numbers." }, { name: "Smart Shift Handover", description: "Digital pass-down of notes and tasks between shifts." }], benefit: "Empowers staff with clarity, improves team coordination, and reduces miscommunication." }, { category: "Performance & Engagement", icon: m2, color: "primary", features: [{ name: "Personal Performance Stats", description: "View own sales, tips, and task completion rates." }, { name: "Gamification & Recognition", description: "Badges and leaderboards for top performers." }, { name: "Micro-Training", description: "Receive daily 2-minute skill tips directly in WhatsApp." }], benefit: "Increases staff satisfaction, motivation, and retention by providing visibility and growth." }], i = [{ icon: H2, title: "POS Agnostic", description: "Works with your existing system (Toast, Square, Clover, etc.)." }, { icon: eu, title: "No Payment Processing", description: "We never touch your payments or compete with your processor." }, { icon: uN, title: "Open API", description: "Connect to accounting, delivery apps, and other tools." }, { icon: A2, title: "Multi-Location Management", description: "Control all venues from a single dashboard." }, { icon: L2, title: "Role-Based Permissions", description: "Granular control over what each user can see and do." }, { icon: eu, title: "Enterprise-Grade Security", description: "SOC 2, GDPR, and data encryption." }], s = [{ icon: rN, text: "Cut labor costs with AI scheduling" }, { icon: tN, text: "Reduce waste by 15%+ with predictive ordering" }, { icon: fg, text: "Achieve 100% staff adoption with WhatsApp-first interface" }, { icon: Fu, text: "Make decisions with a unified dashboard, not guesswork" }]; return p.jsxs("div", { className: "min-h-screen bg-white", children: [p.jsx(Io, {}), p.jsx("section", { className: "pt-32 pb-20 md:pt-40 md:pb-28 bg-gradient-to-br from-neutral-50 to-primary-50/30", children: p.jsx("div", { className: "container-custom", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, className: "max-w-5xl mx-auto text-center", children: [p.jsx("h1", { className: "text-neutral-900 mb-6", children: "Mizan AI: The Intelligent Operating System for Your Restaurant" }), p.jsx("p", { className: "text-2xl text-neutral-600 mb-8", children: "Centralize operations, empower your team, and boost profits with an AI assistant manager that works through WhatsApp." }), p.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-4 mb-10", children: s.map((a, c) => p.jsx(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { delay: c * .1 }, className: "bg-white rounded-xl p-4 border border-neutral-200 shadow-sm", children: p.jsxs("div", { className: "flex items-start space-x-3", children: [p.jsx("div", { className: "w-10 h-10 bg-primary-100 rounded-lg flex items-center justify-center flex-shrink-0", children: p.jsx(a.icon, { className: "text-primary-600", size: 20 }) }), p.jsx("p", { className: "text-sm text-neutral-700 text-left", children: a.text })] }) }, c)) }), p.jsxs("a", { href: "#contact", className: "inline-flex items-center space-x-2 bg-primary-600 text-white px-8 py-4 rounded-lg hover:bg-primary-700 transition-colors", children: [p.jsx("span", { children: "Start Free Trial" }), p.jsx(Xn, { size: 20 })] })] }) }) }), p.jsx("section", { className: "section-padding", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsxs("div", { className: "inline-flex items-center space-x-2 bg-primary-100 text-primary-700 px-4 py-2 rounded-full mb-4", children: [p.jsx(Rv, { size: 16 }), p.jsx("span", { className: "text-sm", children: "For Decision Makers" })] }), p.jsx("h2", { className: "text-neutral-900 mb-4", children: "For Restaurant Owners & General Managers" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto", children: "Features focused on profitability, control, and growth" })] }), p.jsx("div", { className: "space-y-12", children: e.map((a, c) => p.jsx(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: c * .1 }, className: "bg-gradient-to-br from-white to-neutral-50 rounded-3xl border border-neutral-200 overflow-hidden shadow-lg", children: p.jsxs("div", { className: "p-8 md:p-10", children: [p.jsxs("div", { className: "flex items-start space-x-4 mb-6", children: [p.jsx("div", { className: `w-14 h-14 bg-${a.color}-100 rounded-xl flex items-center justify-center flex-shrink-0`, children: p.jsx(a.icon, { className: `text-${a.color}-600`, size: 28 }) }), p.jsxs("div", { className: "flex-1", children: [p.jsx("h3", { className: "text-neutral-900 mb-2", children: a.category }), p.jsx("p", { className: "text-lg text-neutral-600", children: a.benefit })] })] }), p.jsx("div", { className: "grid md:grid-cols-3 gap-6", children: a.features.map((u, f) => p.jsxs("div", { className: "bg-white rounded-xl p-6 border border-neutral-200", children: [p.jsxs("div", { className: "flex items-start space-x-3 mb-3", children: [p.jsx(wo, { className: "text-primary-600 flex-shrink-0 mt-1", size: 20 }), p.jsx("h4", { className: "text-neutral-900", children: u.name })] }), p.jsx("p", { className: "text-neutral-600 text-sm ml-8", children: u.description })] }, f)) })] }) }, c)) })] }) }), p.jsx("section", { className: "section-padding bg-neutral-50", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsxs("div", { className: "inline-flex items-center space-x-2 bg-secondary-100 text-secondary-700 px-4 py-2 rounded-full mb-4", children: [p.jsx(fg, { size: 16 }), p.jsx("span", { className: "text-sm", children: "For Daily Users" })] }), p.jsx("h2", { className: "text-neutral-900 mb-4", children: "For Frontline Staff & Managers" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto", children: "Features focused on simplicity, communication, and empowerment" })] }), p.jsx("div", { className: "space-y-12", children: r.map((a, c) => p.jsx(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: c * .1 }, className: "bg-gradient-to-br from-white to-neutral-50 rounded-3xl border border-neutral-200 overflow-hidden shadow-lg", children: p.jsxs("div", { className: "p-8 md:p-10", children: [p.jsxs("div", { className: "flex items-start space-x-4 mb-6", children: [p.jsx("div", { className: `w-14 h-14 bg-${a.color}-100 rounded-xl flex items-center justify-center flex-shrink-0`, children: p.jsx(a.icon, { className: `text-${a.color}-600`, size: 28 }) }), p.jsxs("div", { className: "flex-1", children: [p.jsx("h3", { className: "text-neutral-900 mb-2", children: a.category }), p.jsx("p", { className: "text-lg text-neutral-600", children: a.benefit })] })] }), p.jsx("div", { className: "grid md:grid-cols-3 gap-6", children: a.features.map((u, f) => p.jsxs("div", { className: "bg-white rounded-xl p-6 border border-neutral-200", children: [p.jsxs("div", { className: "flex items-start space-x-3 mb-3", children: [p.jsx(wo, { className: "text-primary-600 flex-shrink-0 mt-1", size: 20 }), p.jsx("h4", { className: "text-neutral-900", children: u.name })] }), p.jsx("p", { className: "text-neutral-600 text-sm ml-8", children: u.description })] }, f)) })] }) }, c)) })] }) }), p.jsx("section", { className: "section-padding", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsxs("div", { className: "inline-flex items-center space-x-2 bg-neutral-100 text-neutral-700 px-4 py-2 rounded-full mb-4", children: [p.jsx(eu, { size: 16 }), p.jsx("span", { className: "text-sm", children: "Enterprise-Grade Platform" })] }), p.jsx("h2", { className: "text-neutral-900 mb-4", children: "Technical Foundation & Integration" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto", children: "Built on a secure, scalable infrastructure that integrates seamlessly with your existing tools" })] }), p.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-8", children: i.map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: c * .05 }, className: "bg-white rounded-2xl p-8 border border-neutral-200 hover:shadow-xl hover:border-primary-200 transition-all", children: [p.jsx("div", { className: "w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center mb-5", children: p.jsx(a.icon, { className: "text-primary-600", size: 24 }) }), p.jsx("h4", { className: "text-neutral-900 mb-3", children: a.title }), p.jsx("p", { className: "text-neutral-600", children: a.description })] }, c)) }), p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "mt-12 bg-gradient-to-br from-primary-50 to-secondary-50 rounded-2xl p-8 md:p-10 text-center", children: [p.jsx("h3", { className: "text-neutral-900 mb-4", children: "Seamless Integration" }), p.jsx("p", { className: "text-lg text-neutral-600 max-w-3xl mx-auto mb-6", children: "Mizan works with your existing POS systems (Toast, Square, Clover), accounting software, and delivery platforms. We never touch your payments or compete with your processor." }), p.jsxs("a", { href: "#contact", className: "inline-flex items-center space-x-2 text-primary-600 hover:text-primary-700", children: [p.jsx("span", { children: "Request integration details" }), p.jsx(Xn, { size: 20 })] })] })] }) }), p.jsx("section", { className: "section-padding bg-gradient-to-br from-neutral-900 to-neutral-800 text-white", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsx("h2", { className: "text-white mb-4", children: "How It Works" }), p.jsx("p", { className: "text-xl text-neutral-300 max-w-3xl mx-auto", children: "Get started with Mizan in three simple steps" })] }), p.jsx("div", { className: "grid md:grid-cols-3 gap-8 md:gap-12", children: [{ step: "01", title: "Connect Your Systems", description: "Link your POS, payroll, and existing tools. Our team handles the setup." }, { step: "02", title: "Onboard Your Team", description: "Staff receive WhatsApp invites and start using Mizan immediately. Zero training needed." }, { step: "03", title: "Optimize & Grow", description: "Watch real-time insights, reduce costs, and improve operations from day one." }].map((a, c) => p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: c * .1 }, className: "text-center", children: [p.jsx("div", { className: "text-6xl font-bold text-primary-500 mb-4 opacity-50", children: a.step }), p.jsx("h3", { className: "text-white mb-3", children: a.title }), p.jsx("p", { className: "text-neutral-300", children: a.description })] }, c)) })] }) }), p.jsx("section", { className: "section-padding bg-gradient-to-br from-primary-600 to-primary-800 text-white", children: p.jsx("div", { className: "container-custom text-center", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, children: [p.jsx("h2", { className: "text-white mb-6", children: "Ready to transform your restaurant?" }), p.jsx("p", { className: "text-xl text-primary-100 mb-8 max-w-2xl mx-auto", children: "Join 500+ restaurants already saving time, reducing costs, and empowering their teams with Mizan AI" }), p.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [p.jsxs("a", { href: "#contact", className: "inline-flex items-center space-x-2 bg-white text-primary-600 px-8 py-4 rounded-lg hover:bg-neutral-100 transition-colors", children: [p.jsx("span", { children: "Start Free Trial" }), p.jsx(Xn, { size: 20 })] }), p.jsx("a", { href: "#contact", className: "border-2 border-white text-white px-8 py-4 rounded-lg hover:bg-white/10 transition-colors", children: "Book a Demo" })] }), p.jsx("p", { className: "text-primary-100 mt-6", children: "14-day free trial  No credit card required  Cancel anytime" })] }) }) }), p.jsx(Do, {})] }) } function _o(e, r = []) { let i = []; function s(c, u) { const f = w.createContext(u), h = i.length; i = [...i, u]; const g = v => { const { scope: S, children: k, ...P } = v, C = S?.[e]?.[h] || f, N = w.useMemo(() => P, Object.values(P)); return p.jsx(C.Provider, { value: N, children: k }) }; g.displayName = c + "Provider"; function y(v, S) { const k = S?.[e]?.[h] || f, P = w.useContext(k); if (P) return P; if (u !== void 0) return u; throw new Error(`\`${v}\` must be used within \`${c}\``) } return [g, y] } const a = () => { const c = i.map(u => w.createContext(u)); return function (f) { const h = f?.[e] || c; return w.useMemo(() => ({ [`__scope${e}`]: { ...f, [e]: h } }), [f, h]) } }; return a.scopeName = e, [s, mN(a, ...r)] } function mN(...e) { const r = e[0]; if (e.length === 1) return r; const i = () => { const s = e.map(a => ({ useScope: a(), scopeName: a.scopeName })); return function (c) { const u = s.reduce((f, { useScope: h, scopeName: g }) => { const v = h(c)[`__scope${g}`]; return { ...f, ...v } }, {}); return w.useMemo(() => ({ [`__scope${r.scopeName}`]: u }), [u]) } }; return i.scopeName = r.scopeName, i } function pg(e, r) { if (typeof e == "function") return e(r); e != null && (e.current = r) } function Lo(...e) { return r => { let i = !1; const s = e.map(a => { const c = pg(a, r); return !i && typeof c == "function" && (i = !0), c }); if (i) return () => { for (let a = 0; a < s.length; a++) { const c = s[a]; typeof c == "function" ? c() : pg(e[a], null) } } } } function Xe(...e) { return w.useCallback(Lo(...e), e) } function hg(e) { const r = gN(e), i = w.forwardRef((s, a) => { const { children: c, ...u } = s, f = w.Children.toArray(c), h = f.find(vN); if (h) { const g = h.props.children, y = f.map(v => v === h ? w.Children.count(g) > 1 ? w.Children.only(null) : w.isValidElement(g) ? g.props.children : null : v); return p.jsx(r, { ...u, ref: a, children: w.isValidElement(g) ? w.cloneElement(g, void 0, y) : null }) } return p.jsx(r, { ...u, ref: a, children: c }) }); return i.displayName = `${e}.Slot`, i } function gN(e) { const r = w.forwardRef((i, s) => { const { children: a, ...c } = i; if (w.isValidElement(a)) { const u = wN(a), f = xN(c, a.props); return a.type !== w.Fragment && (f.ref = s ? Lo(s, u) : u), w.cloneElement(a, f) } return w.Children.count(a) > 1 ? w.Children.only(null) : null }); return r.displayName = `${e}.SlotClone`, r } var yN = Symbol("radix.slottable"); function vN(e) { return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === yN } function xN(e, r) { const i = { ...r }; for (const s in r) { const a = e[s], c = r[s]; /^on[A-Z]/.test(s) ? a && c ? i[s] = (...f) => { const h = c(...f); return a(...f), h } : a && (i[s] = a) : s === "style" ? i[s] = { ...a, ...c } : s === "className" && (i[s] = [a, c].filter(Boolean).join(" ")) } return { ...e, ...i } } function wN(e) { let r = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? e.ref : (r = Object.getOwnPropertyDescriptor(e, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? e.props.ref : e.props.ref || e.ref) } function Iv(e) { const r = e + "CollectionProvider", [i, s] = _o(r), [a, c] = i(r, { collectionRef: { current: null }, itemMap: new Map }), u = C => { const { scope: N, children: j } = C, E = Ke.useRef(null), R = Ke.useRef(new Map).current; return p.jsx(a, { scope: N, itemMap: R, collectionRef: E, children: j }) }; u.displayName = r; const f = e + "CollectionSlot", h = hg(f), g = Ke.forwardRef((C, N) => { const { scope: j, children: E } = C, R = c(f, j), O = Xe(N, R.collectionRef); return p.jsx(h, { ref: O, children: E }) }); g.displayName = f; const y = e + "CollectionItemSlot", v = "data-radix-collection-item", S = hg(y), k = Ke.forwardRef((C, N) => { const { scope: j, children: E, ...R } = C, O = Ke.useRef(null), V = Xe(N, O), B = c(y, j); return Ke.useEffect(() => (B.itemMap.set(O, { ref: O, ...R }), () => void B.itemMap.delete(O))), p.jsx(S, { [v]: "", ref: V, children: E }) }); k.displayName = y; function P(C) { const N = c(e + "CollectionConsumer", C); return Ke.useCallback(() => { const E = N.collectionRef.current; if (!E) return []; const R = Array.from(E.querySelectorAll(`[${v}]`)); return Array.from(N.itemMap.values()).sort((B, z) => R.indexOf(B.ref.current) - R.indexOf(z.ref.current)) }, [N.collectionRef, N.itemMap]) } return [{ Provider: u, Slot: g, ItemSlot: k }, P, s] } function $e(e, r, { checkForDefaultPrevented: i = !0 } = {}) { return function (a) { if (e?.(a), i === !1 || !a.defaultPrevented) return r?.(a) } } var at = globalThis?.document ? w.useLayoutEffect : () => { }, SN = Ju[" useInsertionEffect ".trim().toString()] || at; function Po({ prop: e, defaultProp: r, onChange: i = () => { }, caller: s }) { const [a, c, u] = CN({ defaultProp: r, onChange: i }), f = e !== void 0, h = f ? e : a; { const y = w.useRef(e !== void 0); w.useEffect(() => { const v = y.current; v !== f && console.warn(`${s} is changing from ${v ? "controlled" : "uncontrolled"} to ${f ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), y.current = f }, [f, s]) } const g = w.useCallback(y => { if (f) { const v = kN(y) ? y(e) : y; v !== e && u.current?.(v) } else c(y) }, [f, e, c, u]); return [h, g] } function CN({ defaultProp: e, onChange: r }) { const [i, s] = w.useState(e), a = w.useRef(i), c = w.useRef(r); return SN(() => { c.current = r }, [r]), w.useEffect(() => { a.current !== i && (c.current?.(i), a.current = i) }, [i, a]), [i, s, c] } function kN(e) { return typeof e == "function" } var Oo = Kg(); const bN = Hg(Oo); function NN(e) { const r = PN(e), i = w.forwardRef((s, a) => { const { children: c, ...u } = s, f = w.Children.toArray(c), h = f.find(TN); if (h) { const g = h.props.children, y = f.map(v => v === h ? w.Children.count(g) > 1 ? w.Children.only(null) : w.isValidElement(g) ? g.props.children : null : v); return p.jsx(r, { ...u, ref: a, children: w.isValidElement(g) ? w.cloneElement(g, void 0, y) : null }) } return p.jsx(r, { ...u, ref: a, children: c }) }); return i.displayName = `${e}.Slot`, i } function PN(e) { const r = w.forwardRef((i, s) => { const { children: a, ...c } = i; if (w.isValidElement(a)) { const u = AN(a), f = jN(c, a.props); return a.type !== w.Fragment && (f.ref = s ? Lo(s, u) : u), w.cloneElement(a, f) } return w.Children.count(a) > 1 ? w.Children.only(null) : null }); return r.displayName = `${e}.SlotClone`, r } var EN = Symbol("radix.slottable"); function TN(e) { return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === EN } function jN(e, r) { const i = { ...r }; for (const s in r) { const a = e[s], c = r[s]; /^on[A-Z]/.test(s) ? a && c ? i[s] = (...f) => { const h = c(...f); return a(...f), h } : a && (i[s] = a) : s === "style" ? i[s] = { ...a, ...c } : s === "className" && (i[s] = [a, c].filter(Boolean).join(" ")) } return { ...e, ...i } } function AN(e) { let r = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? e.ref : (r = Object.getOwnPropertyDescriptor(e, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? e.props.ref : e.props.ref || e.ref) } var RN = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], Ie = RN.reduce((e, r) => { const i = NN(`Primitive.${r}`), s = w.forwardRef((a, c) => { const { asChild: u, ...f } = a, h = u ? i : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), p.jsx(h, { ...f, ref: c }) }); return s.displayName = `Primitive.${r}`, { ...e, [r]: s } }, {}); function MN(e, r) { e && Oo.flushSync(() => e.dispatchEvent(r)) } function IN(e, r) { return w.useReducer((i, s) => r[i][s] ?? i, e) } var Dv = e => { const { present: r, children: i } = e, s = DN(r), a = typeof i == "function" ? i({ present: s.isPresent }) : w.Children.only(i), c = Xe(s.ref, _N(a)); return typeof i == "function" || s.isPresent ? w.cloneElement(a, { ref: c }) : null }; Dv.displayName = "Presence"; function DN(e) { const [r, i] = w.useState(), s = w.useRef(null), a = w.useRef(e), c = w.useRef("none"), u = e ? "mounted" : "unmounted", [f, h] = IN(u, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return w.useEffect(() => { const g = Js(s.current); c.current = f === "mounted" ? g : "none" }, [f]), at(() => { const g = s.current, y = a.current; if (y !== e) { const S = c.current, k = Js(g); e ? h("MOUNT") : k === "none" || g?.display === "none" ? h("UNMOUNT") : h(y && S !== k ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e } }, [e, h]), at(() => { if (r) { let g; const y = r.ownerDocument.defaultView ?? window, v = k => { const C = Js(s.current).includes(CSS.escape(k.animationName)); if (k.target === r && C && (h("ANIMATION_END"), !a.current)) { const N = r.style.animationFillMode; r.style.animationFillMode = "forwards", g = y.setTimeout(() => { r.style.animationFillMode === "forwards" && (r.style.animationFillMode = N) }) } }, S = k => { k.target === r && (c.current = Js(s.current)) }; return r.addEventListener("animationstart", S), r.addEventListener("animationcancel", v), r.addEventListener("animationend", v), () => { y.clearTimeout(g), r.removeEventListener("animationstart", S), r.removeEventListener("animationcancel", v), r.removeEventListener("animationend", v) } } else h("ANIMATION_END") }, [r, h]), { isPresent: ["mounted", "unmountSuspended"].includes(f), ref: w.useCallback(g => { s.current = g ? getComputedStyle(g) : null, i(g) }, []) } } function Js(e) { return e?.animationName || "none" } function _N(e) { let r = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? e.ref : (r = Object.getOwnPropertyDescriptor(e, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? e.props.ref : e.props.ref || e.ref) } var LN = Ju[" useId ".trim().toString()] || (() => { }), ON = 0; function Vo(e) { const [r, i] = w.useState(LN()); return at(() => { i(s => s ?? String(ON++)) }, [e]), r ? `radix-${r}` : "" } var Ma = "Collapsible", [VN, _v] = _o(Ma), [FN, Dd] = VN(Ma), Lv = w.forwardRef((e, r) => { const { __scopeCollapsible: i, open: s, defaultOpen: a, disabled: c, onOpenChange: u, ...f } = e, [h, g] = Po({ prop: s, defaultProp: a ?? !1, onChange: u, caller: Ma }); return p.jsx(FN, { scope: i, disabled: c, contentId: Vo(), open: h, onOpenToggle: w.useCallback(() => g(y => !y), [g]), children: p.jsx(Ie.div, { "data-state": Ld(h), "data-disabled": c ? "" : void 0, ...f, ref: r }) }) }); Lv.displayName = Ma; var Ov = "CollapsibleTrigger", Vv = w.forwardRef((e, r) => { const { __scopeCollapsible: i, ...s } = e, a = Dd(Ov, i); return p.jsx(Ie.button, { type: "button", "aria-controls": a.contentId, "aria-expanded": a.open || !1, "data-state": Ld(a.open), "data-disabled": a.disabled ? "" : void 0, disabled: a.disabled, ...s, ref: r, onClick: $e(e.onClick, a.onOpenToggle) }) }); Vv.displayName = Ov; var _d = "CollapsibleContent", Fv = w.forwardRef((e, r) => { const { forceMount: i, ...s } = e, a = Dd(_d, e.__scopeCollapsible); return p.jsx(Dv, { present: i || a.open, children: ({ present: c }) => p.jsx(zN, { ...s, ref: r, present: c }) }) }); Fv.displayName = _d; var zN = w.forwardRef((e, r) => { const { __scopeCollapsible: i, present: s, children: a, ...c } = e, u = Dd(_d, i), [f, h] = w.useState(s), g = w.useRef(null), y = Xe(r, g), v = w.useRef(0), S = v.current, k = w.useRef(0), P = k.current, C = u.open || f, N = w.useRef(C), j = w.useRef(void 0); return w.useEffect(() => { const E = requestAnimationFrame(() => N.current = !1); return () => cancelAnimationFrame(E) }, []), at(() => { const E = g.current; if (E) { j.current = j.current || { transitionDuration: E.style.transitionDuration, animationName: E.style.animationName }, E.style.transitionDuration = "0s", E.style.animationName = "none"; const R = E.getBoundingClientRect(); v.current = R.height, k.current = R.width, N.current || (E.style.transitionDuration = j.current.transitionDuration, E.style.animationName = j.current.animationName), h(s) } }, [u.open, s]), p.jsx(Ie.div, { "data-state": Ld(u.open), "data-disabled": u.disabled ? "" : void 0, id: u.contentId, hidden: !C, ...c, ref: y, style: { "--radix-collapsible-content-height": S ? `${S}px` : void 0, "--radix-collapsible-content-width": P ? `${P}px` : void 0, ...e.style }, children: C && a }) }); function Ld(e) { return e ? "open" : "closed" } var BN = Lv, WN = Vv, $N = Fv, UN = w.createContext(void 0); function zv(e) { const r = w.useContext(UN); return e || r || "ltr" } var Jt = "Accordion", HN = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Od, KN, GN] = Iv(Jt), [Ia] = _o(Jt, [GN, _v]), Vd = _v(), Bv = Ke.forwardRef((e, r) => { const { type: i, ...s } = e, a = s, c = s; return p.jsx(Od.Provider, { scope: e.__scopeAccordion, children: i === "multiple" ? p.jsx(QN, { ...c, ref: r }) : p.jsx(qN, { ...a, ref: r }) }) }); Bv.displayName = Jt; var [Wv, YN] = Ia(Jt), [$v, XN] = Ia(Jt, { collapsible: !1 }), qN = Ke.forwardRef((e, r) => { const { value: i, defaultValue: s, onValueChange: a = () => { }, collapsible: c = !1, ...u } = e, [f, h] = Po({ prop: i, defaultProp: s ?? "", onChange: a, caller: Jt }); return p.jsx(Wv, { scope: e.__scopeAccordion, value: Ke.useMemo(() => f ? [f] : [], [f]), onItemOpen: h, onItemClose: Ke.useCallback(() => c && h(""), [c, h]), children: p.jsx($v, { scope: e.__scopeAccordion, collapsible: c, children: p.jsx(Uv, { ...u, ref: r }) }) }) }), QN = Ke.forwardRef((e, r) => { const { value: i, defaultValue: s, onValueChange: a = () => { }, ...c } = e, [u, f] = Po({ prop: i, defaultProp: s ?? [], onChange: a, caller: Jt }), h = Ke.useCallback(y => f((v = []) => [...v, y]), [f]), g = Ke.useCallback(y => f((v = []) => v.filter(S => S !== y)), [f]); return p.jsx(Wv, { scope: e.__scopeAccordion, value: u, onItemOpen: h, onItemClose: g, children: p.jsx($v, { scope: e.__scopeAccordion, collapsible: !0, children: p.jsx(Uv, { ...c, ref: r }) }) }) }), [ZN, Da] = Ia(Jt), Uv = Ke.forwardRef((e, r) => { const { __scopeAccordion: i, disabled: s, dir: a, orientation: c = "vertical", ...u } = e, f = Ke.useRef(null), h = Xe(f, r), g = KN(i), v = zv(a) === "ltr", S = $e(e.onKeyDown, k => { if (!HN.includes(k.key)) return; const P = k.target, C = g().filter(F => !F.ref.current?.disabled), N = C.findIndex(F => F.ref.current === P), j = C.length; if (N === -1) return; k.preventDefault(); let E = N; const R = 0, O = j - 1, V = () => { E = N + 1, E > O && (E = R) }, B = () => { E = N - 1, E < R && (E = O) }; switch (k.key) { case "Home": E = R; break; case "End": E = O; break; case "ArrowRight": c === "horizontal" && (v ? V() : B()); break; case "ArrowDown": c === "vertical" && V(); break; case "ArrowLeft": c === "horizontal" && (v ? B() : V()); break; case "ArrowUp": c === "vertical" && B(); break }const z = E % j; C[z].ref.current?.focus() }); return p.jsx(ZN, { scope: i, disabled: s, direction: a, orientation: c, children: p.jsx(Od.Slot, { scope: i, children: p.jsx(Ie.div, { ...u, "data-orientation": c, ref: h, onKeyDown: s ? void 0 : S }) }) }) }), wa = "AccordionItem", [JN, Fd] = Ia(wa), Hv = Ke.forwardRef((e, r) => { const { __scopeAccordion: i, value: s, ...a } = e, c = Da(wa, i), u = YN(wa, i), f = Vd(i), h = Vo(), g = s && u.value.includes(s) || !1, y = c.disabled || e.disabled; return p.jsx(JN, { scope: i, open: g, disabled: y, triggerId: h, children: p.jsx(BN, { "data-orientation": c.orientation, "data-state": Qv(g), ...f, ...a, ref: r, disabled: y, open: g, onOpenChange: v => { v ? u.onItemOpen(s) : u.onItemClose(s) } }) }) }); Hv.displayName = wa; var Kv = "AccordionHeader", Gv = Ke.forwardRef((e, r) => { const { __scopeAccordion: i, ...s } = e, a = Da(Jt, i), c = Fd(Kv, i); return p.jsx(Ie.h3, { "data-orientation": a.orientation, "data-state": Qv(c.open), "data-disabled": c.disabled ? "" : void 0, ...s, ref: r }) }); Gv.displayName = Kv; var zu = "AccordionTrigger", Yv = Ke.forwardRef((e, r) => { const { __scopeAccordion: i, ...s } = e, a = Da(Jt, i), c = Fd(zu, i), u = XN(zu, i), f = Vd(i); return p.jsx(Od.ItemSlot, { scope: i, children: p.jsx(WN, { "aria-disabled": c.open && !u.collapsible || void 0, "data-orientation": a.orientation, id: c.triggerId, ...f, ...s, ref: r }) }) }); Yv.displayName = zu; var Xv = "AccordionContent", qv = Ke.forwardRef((e, r) => { const { __scopeAccordion: i, ...s } = e, a = Da(Jt, i), c = Fd(Xv, i), u = Vd(i); return p.jsx($N, { role: "region", "aria-labelledby": c.triggerId, "data-orientation": a.orientation, ...u, ...s, ref: r, style: { "--radix-accordion-content-height": "var(--radix-collapsible-content-height)", "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", ...e.style } }) }); qv.displayName = Xv; function Qv(e) { return e ? "open" : "closed" } var eP = Bv, tP = Hv, nP = Gv, rP = Yv, iP = qv; function Zv(e) { var r, i, s = ""; if (typeof e == "string" || typeof e == "number") s += e; else if (typeof e == "object") if (Array.isArray(e)) { var a = e.length; for (r = 0; r < a; r++)e[r] && (i = Zv(e[r])) && (s && (s += " "), s += i) } else for (i in e) e[i] && (s && (s += " "), s += i); return s } function oP() { for (var e, r, i = 0, s = "", a = arguments.length; i < a; i++)(e = arguments[i]) && (r = Zv(e)) && (s && (s += " "), s += r); return s } const sP = (e, r) => { const i = new Array(e.length + r.length); for (let s = 0; s < e.length; s++)i[s] = e[s]; for (let s = 0; s < r.length; s++)i[e.length + s] = r[s]; return i }, aP = (e, r) => ({ classGroupId: e, validator: r }), Jv = (e = new Map, r = null, i) => ({ nextPart: e, validators: r, classGroupId: i }), Sa = "-", mg = [], lP = "arbitrary..", cP = e => { const r = dP(e), { conflictingClassGroups: i, conflictingClassGroupModifiers: s } = e; return { getClassGroupId: u => { if (u.startsWith("[") && u.endsWith("]")) return uP(u); const f = u.split(Sa), h = f[0] === "" && f.length > 1 ? 1 : 0; return e0(f, h, r) }, getConflictingClassGroupIds: (u, f) => { if (f) { const h = s[u], g = i[u]; return h ? g ? sP(g, h) : h : g || mg } return i[u] || mg } } }, e0 = (e, r, i) => { if (e.length - r === 0) return i.classGroupId; const a = e[r], c = i.nextPart.get(a); if (c) { const g = e0(e, r + 1, c); if (g) return g } const u = i.validators; if (u === null) return; const f = r === 0 ? e.join(Sa) : e.slice(r).join(Sa), h = u.length; for (let g = 0; g < h; g++) { const y = u[g]; if (y.validator(f)) return y.classGroupId } }, uP = e => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => { const r = e.slice(1, -1), i = r.indexOf(":"), s = r.slice(0, i); return s ? lP + s : void 0 })(), dP = e => { const { theme: r, classGroups: i } = e; return fP(i, r) }, fP = (e, r) => { const i = Jv(); for (const s in e) { const a = e[s]; zd(a, i, s, r) } return i }, zd = (e, r, i, s) => { const a = e.length; for (let c = 0; c < a; c++) { const u = e[c]; pP(u, r, i, s) } }, pP = (e, r, i, s) => { if (typeof e == "string") { hP(e, r, i); return } if (typeof e == "function") { mP(e, r, i, s); return } gP(e, r, i, s) }, hP = (e, r, i) => { const s = e === "" ? r : t0(r, e); s.classGroupId = i }, mP = (e, r, i, s) => { if (yP(e)) { zd(e(s), r, i, s); return } r.validators === null && (r.validators = []), r.validators.push(aP(i, e)) }, gP = (e, r, i, s) => { const a = Object.entries(e), c = a.length; for (let u = 0; u < c; u++) { const [f, h] = a[u]; zd(h, t0(r, f), i, s) } }, t0 = (e, r) => { let i = e; const s = r.split(Sa), a = s.length; for (let c = 0; c < a; c++) { const u = s[c]; let f = i.nextPart.get(u); f || (f = Jv(), i.nextPart.set(u, f)), i = f } return i }, yP = e => "isThemeGetter" in e && e.isThemeGetter === !0, vP = e => { if (e < 1) return { get: () => { }, set: () => { } }; let r = 0, i = Object.create(null), s = Object.create(null); const a = (c, u) => { i[c] = u, r++, r > e && (r = 0, s = i, i = Object.create(null)) }; return { get(c) { let u = i[c]; if (u !== void 0) return u; if ((u = s[c]) !== void 0) return a(c, u), u }, set(c, u) { c in i ? i[c] = u : a(c, u) } } }, Bu = "!", gg = ":", xP = [], yg = (e, r, i, s, a) => ({ modifiers: e, hasImportantModifier: r, baseClassName: i, maybePostfixModifierPosition: s, isExternal: a }), wP = e => { const { prefix: r, experimentalParseClassName: i } = e; let s = a => { const c = []; let u = 0, f = 0, h = 0, g; const y = a.length; for (let C = 0; C < y; C++) { const N = a[C]; if (u === 0 && f === 0) { if (N === gg) { c.push(a.slice(h, C)), h = C + 1; continue } if (N === "/") { g = C; continue } } N === "[" ? u++ : N === "]" ? u-- : N === "(" ? f++ : N === ")" && f-- } const v = c.length === 0 ? a : a.slice(h); let S = v, k = !1; v.endsWith(Bu) ? (S = v.slice(0, -1), k = !0) : v.startsWith(Bu) && (S = v.slice(1), k = !0); const P = g && g > h ? g - h : void 0; return yg(c, k, S, P) }; if (r) { const a = r + gg, c = s; s = u => u.startsWith(a) ? c(u.slice(a.length)) : yg(xP, !1, u, void 0, !0) } if (i) { const a = s; s = c => i({ className: c, parseClassName: a }) } return s }, SP = e => { const r = new Map; return e.orderSensitiveModifiers.forEach((i, s) => { r.set(i, 1e6 + s) }), i => { const s = []; let a = []; for (let c = 0; c < i.length; c++) { const u = i[c], f = u[0] === "[", h = r.has(u); f || h ? (a.length > 0 && (a.sort(), s.push(...a), a = []), s.push(u)) : a.push(u) } return a.length > 0 && (a.sort(), s.push(...a)), s } }, CP = e => ({ cache: vP(e.cacheSize), parseClassName: wP(e), sortModifiers: SP(e), ...cP(e) }), kP = /\s+/, bP = (e, r) => { const { parseClassName: i, getClassGroupId: s, getConflictingClassGroupIds: a, sortModifiers: c } = r, u = [], f = e.trim().split(kP); let h = ""; for (let g = f.length - 1; g >= 0; g -= 1) { const y = f[g], { isExternal: v, modifiers: S, hasImportantModifier: k, baseClassName: P, maybePostfixModifierPosition: C } = i(y); if (v) { h = y + (h.length > 0 ? " " + h : h); continue } let N = !!C, j = s(N ? P.substring(0, C) : P); if (!j) { if (!N) { h = y + (h.length > 0 ? " " + h : h); continue } if (j = s(P), !j) { h = y + (h.length > 0 ? " " + h : h); continue } N = !1 } const E = S.length === 0 ? "" : S.length === 1 ? S[0] : c(S).join(":"), R = k ? E + Bu : E, O = R + j; if (u.indexOf(O) > -1) continue; u.push(O); const V = a(j, N); for (let B = 0; B < V.length; ++B) { const z = V[B]; u.push(R + z) } h = y + (h.length > 0 ? " " + h : h) } return h }, NP = (...e) => { let r = 0, i, s, a = ""; for (; r < e.length;)(i = e[r++]) && (s = n0(i)) && (a && (a += " "), a += s); return a }, n0 = e => { if (typeof e == "string") return e; let r, i = ""; for (let s = 0; s < e.length; s++)e[s] && (r = n0(e[s])) && (i && (i += " "), i += r); return i }, PP = (e, ...r) => { let i, s, a, c; const u = h => { const g = r.reduce((y, v) => v(y), e()); return i = CP(g), s = i.cache.get, a = i.cache.set, c = f, f(h) }, f = h => { const g = s(h); if (g) return g; const y = bP(h, i); return a(h, y), y }; return c = u, (...h) => c(NP(...h)) }, EP = [], Ze = e => { const r = i => i[e] || EP; return r.isThemeGetter = !0, r }, r0 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, i0 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, TP = /^\d+\/\d+$/, jP = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, AP = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, RP = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, MP = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, IP = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, ti = e => TP.test(e), ke = e => !!e && !Number.isNaN(Number(e)), Kn = e => !!e && Number.isInteger(Number(e)), nu = e => e.endsWith("%") && ke(e.slice(0, -1)), Sn = e => jP.test(e), DP = () => !0, _P = e => AP.test(e) && !RP.test(e), o0 = () => !1, LP = e => MP.test(e), OP = e => IP.test(e), VP = e => !te(e) && !ne(e), FP = e => xi(e, l0, o0), te = e => r0.test(e), vr = e => xi(e, c0, _P), ru = e => xi(e, UP, ke), vg = e => xi(e, s0, o0), zP = e => xi(e, a0, OP), ea = e => xi(e, u0, LP), ne = e => i0.test(e), fo = e => wi(e, c0), BP = e => wi(e, HP), xg = e => wi(e, s0), WP = e => wi(e, l0), $P = e => wi(e, a0), ta = e => wi(e, u0, !0), xi = (e, r, i) => { const s = r0.exec(e); return s ? s[1] ? r(s[1]) : i(s[2]) : !1 }, wi = (e, r, i = !1) => { const s = i0.exec(e); return s ? s[1] ? r(s[1]) : i : !1 }, s0 = e => e === "position" || e === "percentage", a0 = e => e === "image" || e === "url", l0 = e => e === "length" || e === "size" || e === "bg-size", c0 = e => e === "length", UP = e => e === "number", HP = e => e === "family-name", u0 = e => e === "shadow", KP = () => { const e = Ze("color"), r = Ze("font"), i = Ze("text"), s = Ze("font-weight"), a = Ze("tracking"), c = Ze("leading"), u = Ze("breakpoint"), f = Ze("container"), h = Ze("spacing"), g = Ze("radius"), y = Ze("shadow"), v = Ze("inset-shadow"), S = Ze("text-shadow"), k = Ze("drop-shadow"), P = Ze("blur"), C = Ze("perspective"), N = Ze("aspect"), j = Ze("ease"), E = Ze("animate"), R = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], O = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], V = () => [...O(), ne, te], B = () => ["auto", "hidden", "clip", "visible", "scroll"], z = () => ["auto", "contain", "none"], F = () => [ne, te, h], Z = () => [ti, "full", "auto", ...F()], ie = () => [Kn, "none", "subgrid", ne, te], fe = () => ["auto", { span: ["full", Kn, ne, te] }, Kn, ne, te], me = () => [Kn, "auto", ne, te], ge = () => ["auto", "min", "max", "fr", ne, te], pe = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], xe = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], se = () => ["auto", ...F()], q = () => [ti, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...F()], I = () => [e, ne, te], X = () => [...O(), xg, vg, { position: [ne, te] }], G = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], M = () => ["auto", "cover", "contain", WP, FP, { size: [ne, te] }], W = () => [nu, fo, vr], oe = () => ["", "none", "full", g, ne, te], ae = () => ["", ke, fo, vr], we = () => ["solid", "dashed", "dotted", "double"], Ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], K = () => [ke, nu, xg, vg], ce = () => ["", "none", P, ne, te], ve = () => ["none", ke, ne, te], Se = () => ["none", ke, ne, te], Pe = () => [ke, ne, te], Re = () => [ti, "full", ...F()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [Sn], breakpoint: [Sn], color: [DP], container: [Sn], "drop-shadow": [Sn], ease: ["in", "out", "in-out"], font: [VP], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [Sn], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [Sn], shadow: [Sn], spacing: ["px", ke], text: [Sn], "text-shadow": [Sn], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", ti, te, ne, N] }], container: ["container"], columns: [{ columns: [ke, te, ne, f] }], "break-after": [{ "break-after": R() }], "break-before": [{ "break-before": R() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: V() }], overflow: [{ overflow: B() }], "overflow-x": [{ "overflow-x": B() }], "overflow-y": [{ "overflow-y": B() }], overscroll: [{ overscroll: z() }], "overscroll-x": [{ "overscroll-x": z() }], "overscroll-y": [{ "overscroll-y": z() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: Z() }], "inset-x": [{ "inset-x": Z() }], "inset-y": [{ "inset-y": Z() }], start: [{ start: Z() }], end: [{ end: Z() }], top: [{ top: Z() }], right: [{ right: Z() }], bottom: [{ bottom: Z() }], left: [{ left: Z() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [Kn, "auto", ne, te] }], basis: [{ basis: [ti, "full", "auto", f, ...F()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [ke, ti, "auto", "initial", "none", te] }], grow: [{ grow: ["", ke, ne, te] }], shrink: [{ shrink: ["", ke, ne, te] }], order: [{ order: [Kn, "first", "last", "none", ne, te] }], "grid-cols": [{ "grid-cols": ie() }], "col-start-end": [{ col: fe() }], "col-start": [{ "col-start": me() }], "col-end": [{ "col-end": me() }], "grid-rows": [{ "grid-rows": ie() }], "row-start-end": [{ row: fe() }], "row-start": [{ "row-start": me() }], "row-end": [{ "row-end": me() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ge() }], "auto-rows": [{ "auto-rows": ge() }], gap: [{ gap: F() }], "gap-x": [{ "gap-x": F() }], "gap-y": [{ "gap-y": F() }], "justify-content": [{ justify: [...pe(), "normal"] }], "justify-items": [{ "justify-items": [...xe(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...xe()] }], "align-content": [{ content: ["normal", ...pe()] }], "align-items": [{ items: [...xe(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...xe(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": pe() }], "place-items": [{ "place-items": [...xe(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...xe()] }], p: [{ p: F() }], px: [{ px: F() }], py: [{ py: F() }], ps: [{ ps: F() }], pe: [{ pe: F() }], pt: [{ pt: F() }], pr: [{ pr: F() }], pb: [{ pb: F() }], pl: [{ pl: F() }], m: [{ m: se() }], mx: [{ mx: se() }], my: [{ my: se() }], ms: [{ ms: se() }], me: [{ me: se() }], mt: [{ mt: se() }], mr: [{ mr: se() }], mb: [{ mb: se() }], ml: [{ ml: se() }], "space-x": [{ "space-x": F() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": F() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: q() }], w: [{ w: [f, "screen", ...q()] }], "min-w": [{ "min-w": [f, "screen", "none", ...q()] }], "max-w": [{ "max-w": [f, "screen", "none", "prose", { screen: [u] }, ...q()] }], h: [{ h: ["screen", "lh", ...q()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...q()] }], "max-h": [{ "max-h": ["screen", "lh", ...q()] }], "font-size": [{ text: ["base", i, fo, vr] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [s, ne, ru] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", nu, te] }], "font-family": [{ font: [BP, te, r] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [a, ne, te] }], "line-clamp": [{ "line-clamp": [ke, "none", ne, ru] }], leading: [{ leading: [c, ...F()] }], "list-image": [{ "list-image": ["none", ne, te] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", ne, te] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: I() }], "text-color": [{ text: I() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...we(), "wavy"] }], "text-decoration-thickness": [{ decoration: [ke, "from-font", "auto", ne, vr] }], "text-decoration-color": [{ decoration: I() }], "underline-offset": [{ "underline-offset": [ke, "auto", ne, te] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: F() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ne, te] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", ne, te] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: X() }], "bg-repeat": [{ bg: G() }], "bg-size": [{ bg: M() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Kn, ne, te], radial: ["", ne, te], conic: [Kn, ne, te] }, $P, zP] }], "bg-color": [{ bg: I() }], "gradient-from-pos": [{ from: W() }], "gradient-via-pos": [{ via: W() }], "gradient-to-pos": [{ to: W() }], "gradient-from": [{ from: I() }], "gradient-via": [{ via: I() }], "gradient-to": [{ to: I() }], rounded: [{ rounded: oe() }], "rounded-s": [{ "rounded-s": oe() }], "rounded-e": [{ "rounded-e": oe() }], "rounded-t": [{ "rounded-t": oe() }], "rounded-r": [{ "rounded-r": oe() }], "rounded-b": [{ "rounded-b": oe() }], "rounded-l": [{ "rounded-l": oe() }], "rounded-ss": [{ "rounded-ss": oe() }], "rounded-se": [{ "rounded-se": oe() }], "rounded-ee": [{ "rounded-ee": oe() }], "rounded-es": [{ "rounded-es": oe() }], "rounded-tl": [{ "rounded-tl": oe() }], "rounded-tr": [{ "rounded-tr": oe() }], "rounded-br": [{ "rounded-br": oe() }], "rounded-bl": [{ "rounded-bl": oe() }], "border-w": [{ border: ae() }], "border-w-x": [{ "border-x": ae() }], "border-w-y": [{ "border-y": ae() }], "border-w-s": [{ "border-s": ae() }], "border-w-e": [{ "border-e": ae() }], "border-w-t": [{ "border-t": ae() }], "border-w-r": [{ "border-r": ae() }], "border-w-b": [{ "border-b": ae() }], "border-w-l": [{ "border-l": ae() }], "divide-x": [{ "divide-x": ae() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": ae() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...we(), "hidden", "none"] }], "divide-style": [{ divide: [...we(), "hidden", "none"] }], "border-color": [{ border: I() }], "border-color-x": [{ "border-x": I() }], "border-color-y": [{ "border-y": I() }], "border-color-s": [{ "border-s": I() }], "border-color-e": [{ "border-e": I() }], "border-color-t": [{ "border-t": I() }], "border-color-r": [{ "border-r": I() }], "border-color-b": [{ "border-b": I() }], "border-color-l": [{ "border-l": I() }], "divide-color": [{ divide: I() }], "outline-style": [{ outline: [...we(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [ke, ne, te] }], "outline-w": [{ outline: ["", ke, fo, vr] }], "outline-color": [{ outline: I() }], shadow: [{ shadow: ["", "none", y, ta, ea] }], "shadow-color": [{ shadow: I() }], "inset-shadow": [{ "inset-shadow": ["none", v, ta, ea] }], "inset-shadow-color": [{ "inset-shadow": I() }], "ring-w": [{ ring: ae() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: I() }], "ring-offset-w": [{ "ring-offset": [ke, vr] }], "ring-offset-color": [{ "ring-offset": I() }], "inset-ring-w": [{ "inset-ring": ae() }], "inset-ring-color": [{ "inset-ring": I() }], "text-shadow": [{ "text-shadow": ["none", S, ta, ea] }], "text-shadow-color": [{ "text-shadow": I() }], opacity: [{ opacity: [ke, ne, te] }], "mix-blend": [{ "mix-blend": [...Ce(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": Ce() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [ke] }], "mask-image-linear-from-pos": [{ "mask-linear-from": K() }], "mask-image-linear-to-pos": [{ "mask-linear-to": K() }], "mask-image-linear-from-color": [{ "mask-linear-from": I() }], "mask-image-linear-to-color": [{ "mask-linear-to": I() }], "mask-image-t-from-pos": [{ "mask-t-from": K() }], "mask-image-t-to-pos": [{ "mask-t-to": K() }], "mask-image-t-from-color": [{ "mask-t-from": I() }], "mask-image-t-to-color": [{ "mask-t-to": I() }], "mask-image-r-from-pos": [{ "mask-r-from": K() }], "mask-image-r-to-pos": [{ "mask-r-to": K() }], "mask-image-r-from-color": [{ "mask-r-from": I() }], "mask-image-r-to-color": [{ "mask-r-to": I() }], "mask-image-b-from-pos": [{ "mask-b-from": K() }], "mask-image-b-to-pos": [{ "mask-b-to": K() }], "mask-image-b-from-color": [{ "mask-b-from": I() }], "mask-image-b-to-color": [{ "mask-b-to": I() }], "mask-image-l-from-pos": [{ "mask-l-from": K() }], "mask-image-l-to-pos": [{ "mask-l-to": K() }], "mask-image-l-from-color": [{ "mask-l-from": I() }], "mask-image-l-to-color": [{ "mask-l-to": I() }], "mask-image-x-from-pos": [{ "mask-x-from": K() }], "mask-image-x-to-pos": [{ "mask-x-to": K() }], "mask-image-x-from-color": [{ "mask-x-from": I() }], "mask-image-x-to-color": [{ "mask-x-to": I() }], "mask-image-y-from-pos": [{ "mask-y-from": K() }], "mask-image-y-to-pos": [{ "mask-y-to": K() }], "mask-image-y-from-color": [{ "mask-y-from": I() }], "mask-image-y-to-color": [{ "mask-y-to": I() }], "mask-image-radial": [{ "mask-radial": [ne, te] }], "mask-image-radial-from-pos": [{ "mask-radial-from": K() }], "mask-image-radial-to-pos": [{ "mask-radial-to": K() }], "mask-image-radial-from-color": [{ "mask-radial-from": I() }], "mask-image-radial-to-color": [{ "mask-radial-to": I() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": O() }], "mask-image-conic-pos": [{ "mask-conic": [ke] }], "mask-image-conic-from-pos": [{ "mask-conic-from": K() }], "mask-image-conic-to-pos": [{ "mask-conic-to": K() }], "mask-image-conic-from-color": [{ "mask-conic-from": I() }], "mask-image-conic-to-color": [{ "mask-conic-to": I() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: X() }], "mask-repeat": [{ mask: G() }], "mask-size": [{ mask: M() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", ne, te] }], filter: [{ filter: ["", "none", ne, te] }], blur: [{ blur: ce() }], brightness: [{ brightness: [ke, ne, te] }], contrast: [{ contrast: [ke, ne, te] }], "drop-shadow": [{ "drop-shadow": ["", "none", k, ta, ea] }], "drop-shadow-color": [{ "drop-shadow": I() }], grayscale: [{ grayscale: ["", ke, ne, te] }], "hue-rotate": [{ "hue-rotate": [ke, ne, te] }], invert: [{ invert: ["", ke, ne, te] }], saturate: [{ saturate: [ke, ne, te] }], sepia: [{ sepia: ["", ke, ne, te] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", ne, te] }], "backdrop-blur": [{ "backdrop-blur": ce() }], "backdrop-brightness": [{ "backdrop-brightness": [ke, ne, te] }], "backdrop-contrast": [{ "backdrop-contrast": [ke, ne, te] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", ke, ne, te] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [ke, ne, te] }], "backdrop-invert": [{ "backdrop-invert": ["", ke, ne, te] }], "backdrop-opacity": [{ "backdrop-opacity": [ke, ne, te] }], "backdrop-saturate": [{ "backdrop-saturate": [ke, ne, te] }], "backdrop-sepia": [{ "backdrop-sepia": ["", ke, ne, te] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": F() }], "border-spacing-x": [{ "border-spacing-x": F() }], "border-spacing-y": [{ "border-spacing-y": F() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ne, te] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [ke, "initial", ne, te] }], ease: [{ ease: ["linear", "initial", j, ne, te] }], delay: [{ delay: [ke, ne, te] }], animate: [{ animate: ["none", E, ne, te] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [C, ne, te] }], "perspective-origin": [{ "perspective-origin": V() }], rotate: [{ rotate: ve() }], "rotate-x": [{ "rotate-x": ve() }], "rotate-y": [{ "rotate-y": ve() }], "rotate-z": [{ "rotate-z": ve() }], scale: [{ scale: Se() }], "scale-x": [{ "scale-x": Se() }], "scale-y": [{ "scale-y": Se() }], "scale-z": [{ "scale-z": Se() }], "scale-3d": ["scale-3d"], skew: [{ skew: Pe() }], "skew-x": [{ "skew-x": Pe() }], "skew-y": [{ "skew-y": Pe() }], transform: [{ transform: [ne, te, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: V() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: Re() }], "translate-x": [{ "translate-x": Re() }], "translate-y": [{ "translate-y": Re() }], "translate-z": [{ "translate-z": Re() }], "translate-none": ["translate-none"], accent: [{ accent: I() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: I() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ne, te] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": F() }], "scroll-mx": [{ "scroll-mx": F() }], "scroll-my": [{ "scroll-my": F() }], "scroll-ms": [{ "scroll-ms": F() }], "scroll-me": [{ "scroll-me": F() }], "scroll-mt": [{ "scroll-mt": F() }], "scroll-mr": [{ "scroll-mr": F() }], "scroll-mb": [{ "scroll-mb": F() }], "scroll-ml": [{ "scroll-ml": F() }], "scroll-p": [{ "scroll-p": F() }], "scroll-px": [{ "scroll-px": F() }], "scroll-py": [{ "scroll-py": F() }], "scroll-ps": [{ "scroll-ps": F() }], "scroll-pe": [{ "scroll-pe": F() }], "scroll-pt": [{ "scroll-pt": F() }], "scroll-pr": [{ "scroll-pr": F() }], "scroll-pb": [{ "scroll-pb": F() }], "scroll-pl": [{ "scroll-pl": F() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", ne, te] }], fill: [{ fill: ["none", ...I()] }], "stroke-w": [{ stroke: [ke, fo, vr, ru] }], stroke: [{ stroke: ["none", ...I()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, GP = PP(KP); function Ft(...e) { return GP(oP(e)) } function YP({ ...e }) { return p.jsx(eP, { "data-slot": "accordion", ...e }) } function XP({ className: e, ...r }) { return p.jsx(tP, { "data-slot": "accordion-item", className: Ft("border-b last:border-b-0", e), ...r }) } function qP({ className: e, children: r, ...i }) { return p.jsx(nP, { className: "flex", children: p.jsxs(rP, { "data-slot": "accordion-trigger", className: Ft("focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180", e), ...i, children: [r, p.jsx(Id, { className: "text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" })] }) }) } function QP({ className: e, children: r, ...i }) { return p.jsx(iP, { "data-slot": "accordion-content", className: "data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm", ...i, children: p.jsx("div", { className: Ft("pt-0 pb-4", e), children: r }) }) } function ZP() { const [e, r] = w.useState(25), [i, s] = w.useState("monthly"), a = [{ name: "Starter", description: "Perfect for single-location restaurants", basePrice: 79, pricePerEmployee: 2, maxEmployees: 30, features: ["Smart scheduling", "WhatsApp integration", "Basic analytics", "Mobile apps", "Email support", "Up to 30 employees"], notIncluded: ["Multi-location support", "Advanced analytics", "Custom integrations", "Dedicated account manager"], recommended: !1 }, { name: "Professional", description: "For growing restaurant businesses", basePrice: 149, pricePerEmployee: 3, maxEmployees: 100, features: ["Everything in Starter", "Advanced analytics & reports", "Performance tracking", "Labor cost optimization", "Priority support", "Up to 100 employees", "API access", "Custom reporting"], notIncluded: ["Multi-location support", "Dedicated account manager"], recommended: !0 }, { name: "Enterprise", description: "For multi-location operators", basePrice: null, pricePerEmployee: null, maxEmployees: null, features: ["Everything in Professional", "Multi-location management", "Consolidated reporting", "Custom integrations", "Dedicated account manager", "Unlimited employees", "SLA guarantee", "Custom training", "Advanced security"], notIncluded: [], recommended: !1 }], c = f => { if (f.basePrice === null) return null; const h = Math.min(e, f.maxEmployees || e), g = f.basePrice + h * f.pricePerEmployee; return i === "annual" ? Math.floor(g * 12 * .85) : g }, u = [{ question: "How does the 14-day free trial work?", answer: "Start using Mizan immediately with full access to all features. No credit card required. After 14 days, choose a plan that fits your needs or continue with our free tier." }, { question: "Can I change plans later?", answer: "Absolutely! You can upgrade or downgrade your plan at any time. Changes take effect immediately, and we'll prorate any charges." }, { question: "What counts as an employee?", answer: "An employee is any team member who needs to be scheduled, tracked, or managed in the system. This includes full-time, part-time, and seasonal staff." }, { question: "Is there a setup fee?", answer: "No setup fees, ever. We include onboarding and training with all plans to ensure your success." }, { question: "What payment methods do you accept?", answer: "We accept all major credit cards (Visa, Mastercard, American Express) and ACH/bank transfers for annual plans." }, { question: "Can I cancel anytime?", answer: "Yes, you can cancel your subscription at any time. No long-term contracts or cancellation fees. Your data is always yours to export." }, { question: "Do you offer discounts for annual billing?", answer: "Yes! Save 15% when you pay annually. That's like getting almost 2 months free." }, { question: "What kind of support is included?", answer: "All plans include email support. Professional and Enterprise plans get priority support with faster response times. Enterprise customers get a dedicated account manager." }]; return p.jsxs("div", { className: "min-h-screen bg-white", children: [p.jsx(Io, {}), p.jsx("section", { className: "pt-32 pb-20 md:pt-40 md:pb-28 bg-gradient-to-br from-neutral-50 to-primary-50/30", children: p.jsx("div", { className: "container-custom text-center", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [p.jsx("h1", { className: "text-neutral-900 mb-6", children: "Simple, transparent pricing" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto mb-8", children: "Choose the plan that's right for your restaurant. Start with a 14-day free trial." }), p.jsxs("div", { className: "inline-flex items-center bg-white rounded-lg p-1 shadow-sm", children: [p.jsx("button", { onClick: () => s("monthly"), className: `px-6 py-2 rounded-md transition-colors ${i === "monthly" ? "bg-primary-600 text-white" : "text-neutral-600 hover:text-neutral-900"}`, children: "Monthly" }), p.jsxs("button", { onClick: () => s("annual"), className: `px-6 py-2 rounded-md transition-colors ${i === "annual" ? "bg-primary-600 text-white" : "text-neutral-600 hover:text-neutral-900"}`, children: ["Annual", p.jsx("span", { className: "ml-2 text-xs bg-secondary-100 text-secondary-700 px-2 py-1 rounded", children: "Save 15%" })] })] })] }) }) }), p.jsx("section", { className: "section-padding-sm bg-white", children: p.jsxs("div", { className: "container-custom", children: [p.jsx("div", { className: "max-w-2xl mx-auto mb-16", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "bg-neutral-50 rounded-2xl p-8", children: [p.jsx("h3", { className: "text-neutral-900 mb-6 text-center", children: "How many employees do you have?" }), p.jsxs("div", { className: "space-y-4", children: [p.jsx("input", { type: "range", min: "5", max: "150", value: e, onChange: f => r(parseInt(f.target.value)), className: "w-full h-2 bg-primary-200 rounded-lg appearance-none cursor-pointer accent-primary-600" }), p.jsxs("div", { className: "text-center", children: [p.jsxs("div", { className: "text-4xl font-bold text-primary-600 mb-2", children: [e, " employees"] }), p.jsx("p", { className: "text-neutral-600", children: "Slide to estimate your monthly cost" })] })] })] }) }), p.jsx("div", { className: "grid md:grid-cols-3 gap-8", children: a.map((f, h) => { const g = c(f), y = f.recommended; return p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, transition: { delay: h * .1 }, className: `bg-white rounded-2xl p-8 relative ${y ? "border-2 border-primary-600 shadow-xl" : "border border-neutral-200"}`, children: [y && p.jsx("div", { className: "absolute -top-4 left-1/2 -translate-x-1/2 bg-primary-600 text-white px-4 py-1 rounded-full text-sm", children: "Most Popular" }), p.jsxs("div", { className: "mb-6", children: [p.jsx("h3", { className: "text-neutral-900 mb-2", children: f.name }), p.jsx("p", { className: "text-neutral-600", children: f.description })] }), p.jsx("div", { className: "mb-6", children: g !== null ? p.jsxs(p.Fragment, { children: [p.jsxs("div", { className: "flex items-baseline", children: [p.jsxs("span", { className: "text-5xl font-bold text-neutral-900", children: ["$", i === "annual" ? Math.floor(g / 12) : g] }), p.jsx("span", { className: "text-neutral-600 ml-2", children: "/month" })] }), i === "annual" && p.jsxs("p", { className: "text-sm text-neutral-500 mt-2", children: ["$", g, "/year (billed annually)"] }), p.jsxs("p", { className: "text-sm text-neutral-500 mt-2", children: ["For ", e <= (f.maxEmployees || 999) ? e : f.maxEmployees, " employees"] })] }) : p.jsxs("div", { children: [p.jsx("div", { className: "text-3xl font-bold text-neutral-900 mb-2", children: "Custom Pricing" }), p.jsx("p", { className: "text-neutral-600", children: "Tailored to your needs" })] }) }), p.jsx("a", { href: "#contact", className: `w-full block text-center py-3 rounded-lg transition-colors mb-6 ${y ? "bg-primary-600 text-white hover:bg-primary-700" : "border-2 border-neutral-300 text-neutral-900 hover:border-primary-600"}`, children: g !== null ? "Start Free Trial" : "Contact Sales" }), p.jsxs("div", { className: "space-y-3", children: [f.features.map((v, S) => p.jsxs("div", { className: "flex items-start space-x-3", children: [p.jsx(jv, { className: "text-primary-600 flex-shrink-0 mt-0.5", size: 20 }), p.jsx("span", { className: "text-neutral-700", children: v })] }, S)), f.notIncluded.map((v, S) => p.jsxs("div", { className: "flex items-start space-x-3 opacity-50", children: [p.jsx(Mv, { className: "text-neutral-400 flex-shrink-0 mt-0.5", size: 20 }), p.jsx("span", { className: "text-neutral-500", children: v })] }, S))] })] }, h) }) }), p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "mt-16 bg-neutral-50 rounded-2xl p-8", children: [p.jsx("h3", { className: "text-neutral-900 mb-6 text-center", children: "Not sure which plan is right for you?" }), p.jsxs("div", { className: "grid md:grid-cols-3 gap-6 text-center", children: [p.jsxs("div", { children: [p.jsx("div", { className: "text-2xl mb-2", children: "" }), p.jsx("h4", { className: "text-neutral-900 mb-2", children: "Single Location" }), p.jsx("p", { className: "text-neutral-600 mb-3", children: "Under 30 employees" }), p.jsx("p", { className: "text-primary-600", children: " Starter Plan" })] }), p.jsxs("div", { children: [p.jsx("div", { className: "text-2xl mb-2", children: "" }), p.jsx("h4", { className: "text-neutral-900 mb-2", children: "Growing Business" }), p.jsx("p", { className: "text-neutral-600 mb-3", children: "30-100 employees" }), p.jsx("p", { className: "text-primary-600", children: " Professional Plan" })] }), p.jsxs("div", { children: [p.jsx("div", { className: "text-2xl mb-2", children: "" }), p.jsx("h4", { className: "text-neutral-900 mb-2", children: "Multi-Location" }), p.jsx("p", { className: "text-neutral-600 mb-3", children: "100+ employees" }), p.jsx("p", { className: "text-primary-600", children: " Enterprise Plan" })] })] })] })] }) }), p.jsx("section", { className: "section-padding bg-neutral-50", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mb-16", children: [p.jsx("h2", { className: "text-neutral-900 mb-4", children: "Frequently asked questions" }), p.jsx("p", { className: "text-xl text-neutral-600", children: "Everything you need to know about pricing and billing" })] }), p.jsx("div", { className: "max-w-3xl mx-auto", children: p.jsx(YP, { type: "single", collapsible: !0, className: "space-y-4", children: u.map((f, h) => p.jsxs(XP, { value: `item-${h}`, className: "bg-white border border-neutral-200 rounded-xl px-6", children: [p.jsx(qP, { className: "hover:no-underline", children: p.jsx("span", { className: "text-left text-neutral-900", children: f.question }) }), p.jsx(QP, { className: "text-neutral-600", children: f.answer })] }, h)) }) }), p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, className: "text-center mt-12", children: [p.jsx("p", { className: "text-neutral-600 mb-4", children: "Still have questions?" }), p.jsxs("a", { href: "#contact", className: "inline-flex items-center space-x-2 text-primary-600 hover:text-primary-700", children: [p.jsx("span", { children: "Contact our sales team" }), p.jsx(Xn, { size: 20 })] })] })] }) }), p.jsx("section", { className: "section-padding bg-gradient-to-br from-primary-600 to-primary-800 text-white", children: p.jsx("div", { className: "container-custom text-center", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, viewport: { once: !0 }, children: [p.jsx("h2", { className: "text-white mb-6", children: "Ready to get started?" }), p.jsx("p", { className: "text-xl text-primary-100 mb-8 max-w-2xl mx-auto", children: "Start your 14-day free trial today. No credit card required." }), p.jsxs("a", { href: "#contact", className: "inline-flex items-center space-x-2 bg-white text-primary-600 px-8 py-4 rounded-lg hover:bg-neutral-100 transition-colors", children: [p.jsx("span", { children: "Start Free Trial" }), p.jsx(Xn, { size: 20 })] })] }) }) }), p.jsx(Do, {})] }) } function po({ className: e, type: r, ...i }) { return p.jsx("input", { type: r, "data-slot": "input", className: Ft("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base bg-input-background transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", e), ...i }) } function JP({ className: e, ...r }) { return p.jsx("textarea", { "data-slot": "textarea", className: Ft("resize-none border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-input-background px-3 py-2 text-base transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e), ...r }) } var eE = Symbol.for("react.lazy"), Ca = Ju[" use ".trim().toString()]; function tE(e) { return typeof e == "object" && e !== null && "then" in e } function d0(e) { return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === eE && "_payload" in e && tE(e._payload) } function nE(e) { const r = rE(e), i = w.forwardRef((s, a) => { let { children: c, ...u } = s; d0(c) && typeof Ca == "function" && (c = Ca(c._payload)); const f = w.Children.toArray(c), h = f.find(oE); if (h) { const g = h.props.children, y = f.map(v => v === h ? w.Children.count(g) > 1 ? w.Children.only(null) : w.isValidElement(g) ? g.props.children : null : v); return p.jsx(r, { ...u, ref: a, children: w.isValidElement(g) ? w.cloneElement(g, void 0, y) : null }) } return p.jsx(r, { ...u, ref: a, children: c }) }); return i.displayName = `${e}.Slot`, i } function rE(e) { const r = w.forwardRef((i, s) => { let { children: a, ...c } = i; if (d0(a) && typeof Ca == "function" && (a = Ca(a._payload)), w.isValidElement(a)) { const u = aE(a), f = sE(c, a.props); return a.type !== w.Fragment && (f.ref = s ? Lo(s, u) : u), w.cloneElement(a, f) } return w.Children.count(a) > 1 ? w.Children.only(null) : null }); return r.displayName = `${e}.SlotClone`, r } var iE = Symbol("radix.slottable"); function oE(e) { return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === iE } function sE(e, r) { const i = { ...r }; for (const s in r) { const a = e[s], c = r[s]; /^on[A-Z]/.test(s) ? a && c ? i[s] = (...f) => { const h = c(...f); return a(...f), h } : a && (i[s] = a) : s === "style" ? i[s] = { ...a, ...c } : s === "className" && (i[s] = [a, c].filter(Boolean).join(" ")) } return { ...e, ...i } } function aE(e) { let r = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? e.ref : (r = Object.getOwnPropertyDescriptor(e, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? e.props.ref : e.props.ref || e.ref) } var lE = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], cE = lE.reduce((e, r) => { const i = nE(`Primitive.${r}`), s = w.forwardRef((a, c) => { const { asChild: u, ...f } = a, h = u ? i : r; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), p.jsx(h, { ...f, ref: c }) }); return s.displayName = `Primitive.${r}`, { ...e, [r]: s } }, {}), uE = "Label", f0 = w.forwardRef((e, r) => p.jsx(cE.label, { ...e, ref: r, onMouseDown: i => { i.target.closest("button, input, select, textarea") || (e.onMouseDown?.(i), !i.defaultPrevented && i.detail > 1 && i.preventDefault()) } })); f0.displayName = uE; var dE = f0; function Cn({ className: e, ...r }) { return p.jsx(dE, { "data-slot": "label", className: Ft("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", e), ...r }) } function wg(e, [r, i]) { return Math.min(i, Math.max(r, e)) } function br(e) { const r = w.useRef(e); return w.useEffect(() => { r.current = e }), w.useMemo(() => (...i) => r.current?.(...i), []) } function fE(e, r = globalThis?.document) { const i = br(e); w.useEffect(() => { const s = a => { a.key === "Escape" && i(a) }; return r.addEventListener("keydown", s, { capture: !0 }), () => r.removeEventListener("keydown", s, { capture: !0 }) }, [i, r]) } var pE = "DismissableLayer", Wu = "dismissableLayer.update", hE = "dismissableLayer.pointerDownOutside", mE = "dismissableLayer.focusOutside", Sg, p0 = w.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), h0 = w.forwardRef((e, r) => { const { disableOutsidePointerEvents: i = !1, onEscapeKeyDown: s, onPointerDownOutside: a, onFocusOutside: c, onInteractOutside: u, onDismiss: f, ...h } = e, g = w.useContext(p0), [y, v] = w.useState(null), S = y?.ownerDocument ?? globalThis?.document, [, k] = w.useState({}), P = Xe(r, z => v(z)), C = Array.from(g.layers), [N] = [...g.layersWithOutsidePointerEventsDisabled].slice(-1), j = C.indexOf(N), E = y ? C.indexOf(y) : -1, R = g.layersWithOutsidePointerEventsDisabled.size > 0, O = E >= j, V = vE(z => { const F = z.target, Z = [...g.branches].some(ie => ie.contains(F)); !O || Z || (a?.(z), u?.(z), z.defaultPrevented || f?.()) }, S), B = xE(z => { const F = z.target;[...g.branches].some(ie => ie.contains(F)) || (c?.(z), u?.(z), z.defaultPrevented || f?.()) }, S); return fE(z => { E === g.layers.size - 1 && (s?.(z), !z.defaultPrevented && f && (z.preventDefault(), f())) }, S), w.useEffect(() => { if (y) return i && (g.layersWithOutsidePointerEventsDisabled.size === 0 && (Sg = S.body.style.pointerEvents, S.body.style.pointerEvents = "none"), g.layersWithOutsidePointerEventsDisabled.add(y)), g.layers.add(y), Cg(), () => { i && g.layersWithOutsidePointerEventsDisabled.size === 1 && (S.body.style.pointerEvents = Sg) } }, [y, S, i, g]), w.useEffect(() => () => { y && (g.layers.delete(y), g.layersWithOutsidePointerEventsDisabled.delete(y), Cg()) }, [y, g]), w.useEffect(() => { const z = () => k({}); return document.addEventListener(Wu, z), () => document.removeEventListener(Wu, z) }, []), p.jsx(Ie.div, { ...h, ref: P, style: { pointerEvents: R ? O ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: $e(e.onFocusCapture, B.onFocusCapture), onBlurCapture: $e(e.onBlurCapture, B.onBlurCapture), onPointerDownCapture: $e(e.onPointerDownCapture, V.onPointerDownCapture) }) }); h0.displayName = pE; var gE = "DismissableLayerBranch", yE = w.forwardRef((e, r) => { const i = w.useContext(p0), s = w.useRef(null), a = Xe(r, s); return w.useEffect(() => { const c = s.current; if (c) return i.branches.add(c), () => { i.branches.delete(c) } }, [i.branches]), p.jsx(Ie.div, { ...e, ref: a }) }); yE.displayName = gE; function vE(e, r = globalThis?.document) { const i = br(e), s = w.useRef(!1), a = w.useRef(() => { }); return w.useEffect(() => { const c = f => { if (f.target && !s.current) { let h = function () { m0(hE, i, g, { discrete: !0 }) }; const g = { originalEvent: f }; f.pointerType === "touch" ? (r.removeEventListener("click", a.current), a.current = h, r.addEventListener("click", a.current, { once: !0 })) : h() } else r.removeEventListener("click", a.current); s.current = !1 }, u = window.setTimeout(() => { r.addEventListener("pointerdown", c) }, 0); return () => { window.clearTimeout(u), r.removeEventListener("pointerdown", c), r.removeEventListener("click", a.current) } }, [r, i]), { onPointerDownCapture: () => s.current = !0 } } function xE(e, r = globalThis?.document) { const i = br(e), s = w.useRef(!1); return w.useEffect(() => { const a = c => { c.target && !s.current && m0(mE, i, { originalEvent: c }, { discrete: !1 }) }; return r.addEventListener("focusin", a), () => r.removeEventListener("focusin", a) }, [r, i]), { onFocusCapture: () => s.current = !0, onBlurCapture: () => s.current = !1 } } function Cg() { const e = new CustomEvent(Wu); document.dispatchEvent(e) } function m0(e, r, i, { discrete: s }) { const a = i.originalEvent.target, c = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: i }); r && a.addEventListener(e, r, { once: !0 }), s ? MN(a, c) : a.dispatchEvent(c) } var iu = 0; function wE() { w.useEffect(() => { const e = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", e[0] ?? kg()), document.body.insertAdjacentElement("beforeend", e[1] ?? kg()), iu++, () => { iu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), iu-- } }, []) } function kg() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e } var ou = "focusScope.autoFocusOnMount", su = "focusScope.autoFocusOnUnmount", bg = { bubbles: !1, cancelable: !0 }, SE = "FocusScope", g0 = w.forwardRef((e, r) => { const { loop: i = !1, trapped: s = !1, onMountAutoFocus: a, onUnmountAutoFocus: c, ...u } = e, [f, h] = w.useState(null), g = br(a), y = br(c), v = w.useRef(null), S = Xe(r, C => h(C)), k = w.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; w.useEffect(() => { if (s) { let C = function (R) { if (k.paused || !f) return; const O = R.target; f.contains(O) ? v.current = O : Yn(v.current, { select: !0 }) }, N = function (R) { if (k.paused || !f) return; const O = R.relatedTarget; O !== null && (f.contains(O) || Yn(v.current, { select: !0 })) }, j = function (R) { if (document.activeElement === document.body) for (const V of R) V.removedNodes.length > 0 && Yn(f) }; document.addEventListener("focusin", C), document.addEventListener("focusout", N); const E = new MutationObserver(j); return f && E.observe(f, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", C), document.removeEventListener("focusout", N), E.disconnect() } } }, [s, f, k.paused]), w.useEffect(() => { if (f) { Pg.add(k); const C = document.activeElement; if (!f.contains(C)) { const j = new CustomEvent(ou, bg); f.addEventListener(ou, g), f.dispatchEvent(j), j.defaultPrevented || (CE(EE(y0(f)), { select: !0 }), document.activeElement === C && Yn(f)) } return () => { f.removeEventListener(ou, g), setTimeout(() => { const j = new CustomEvent(su, bg); f.addEventListener(su, y), f.dispatchEvent(j), j.defaultPrevented || Yn(C ?? document.body, { select: !0 }), f.removeEventListener(su, y), Pg.remove(k) }, 0) } } }, [f, g, y, k]); const P = w.useCallback(C => { if (!i && !s || k.paused) return; const N = C.key === "Tab" && !C.altKey && !C.ctrlKey && !C.metaKey, j = document.activeElement; if (N && j) { const E = C.currentTarget, [R, O] = kE(E); R && O ? !C.shiftKey && j === O ? (C.preventDefault(), i && Yn(R, { select: !0 })) : C.shiftKey && j === R && (C.preventDefault(), i && Yn(O, { select: !0 })) : j === E && C.preventDefault() } }, [i, s, k.paused]); return p.jsx(Ie.div, { tabIndex: -1, ...u, ref: S, onKeyDown: P }) }); g0.displayName = SE; function CE(e, { select: r = !1 } = {}) { const i = document.activeElement; for (const s of e) if (Yn(s, { select: r }), document.activeElement !== i) return } function kE(e) { const r = y0(e), i = Ng(r, e), s = Ng(r.reverse(), e); return [i, s] } function y0(e) { const r = [], i = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: s => { const a = s.tagName === "INPUT" && s.type === "hidden"; return s.disabled || s.hidden || a ? NodeFilter.FILTER_SKIP : s.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; i.nextNode();)r.push(i.currentNode); return r } function Ng(e, r) { for (const i of e) if (!bE(i, { upTo: r })) return i } function bE(e, { upTo: r }) { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (r !== void 0 && e === r) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 } function NE(e) { return e instanceof HTMLInputElement && "select" in e } function Yn(e, { select: r = !1 } = {}) { if (e && e.focus) { const i = document.activeElement; e.focus({ preventScroll: !0 }), e !== i && NE(e) && r && e.select() } } var Pg = PE(); function PE() { let e = []; return { add(r) { const i = e[0]; r !== i && i?.pause(), e = Eg(e, r), e.unshift(r) }, remove(r) { e = Eg(e, r), e[0]?.resume() } } } function Eg(e, r) { const i = [...e], s = i.indexOf(r); return s !== -1 && i.splice(s, 1), i } function EE(e) { return e.filter(r => r.tagName !== "A") } const TE = ["top", "right", "bottom", "left"], Zn = Math.min, Tt = Math.max, ka = Math.round, na = Math.floor, un = e => ({ x: e, y: e }), jE = { left: "right", right: "left", bottom: "top", top: "bottom" }, AE = { start: "end", end: "start" }; function $u(e, r, i) { return Tt(e, Zn(r, i)) } function Nn(e, r) { return typeof e == "function" ? e(r) : e } function Pn(e) { return e.split("-")[0] } function Si(e) { return e.split("-")[1] } function Bd(e) { return e === "x" ? "y" : "x" } function Wd(e) { return e === "y" ? "height" : "width" } const RE = new Set(["top", "bottom"]); function an(e) { return RE.has(Pn(e)) ? "y" : "x" } function $d(e) { return Bd(an(e)) } function ME(e, r, i) { i === void 0 && (i = !1); const s = Si(e), a = $d(e), c = Wd(a); let u = a === "x" ? s === (i ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top"; return r.reference[c] > r.floating[c] && (u = ba(u)), [u, ba(u)] } function IE(e) { const r = ba(e); return [Uu(e), r, Uu(r)] } function Uu(e) { return e.replace(/start|end/g, r => AE[r]) } const Tg = ["left", "right"], jg = ["right", "left"], DE = ["top", "bottom"], _E = ["bottom", "top"]; function LE(e, r, i) { switch (e) { case "top": case "bottom": return i ? r ? jg : Tg : r ? Tg : jg; case "left": case "right": return r ? DE : _E; default: return [] } } function OE(e, r, i, s) { const a = Si(e); let c = LE(Pn(e), i === "start", s); return a && (c = c.map(u => u + "-" + a), r && (c = c.concat(c.map(Uu)))), c } function ba(e) { return e.replace(/left|right|bottom|top/g, r => jE[r]) } function VE(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function v0(e) { return typeof e != "number" ? VE(e) : { top: e, right: e, bottom: e, left: e } } function Na(e) { const { x: r, y: i, width: s, height: a } = e; return { width: s, height: a, top: i, left: r, right: r + s, bottom: i + a, x: r, y: i } } function Ag(e, r, i) { let { reference: s, floating: a } = e; const c = an(r), u = $d(r), f = Wd(u), h = Pn(r), g = c === "y", y = s.x + s.width / 2 - a.width / 2, v = s.y + s.height / 2 - a.height / 2, S = s[f] / 2 - a[f] / 2; let k; switch (h) { case "top": k = { x: y, y: s.y - a.height }; break; case "bottom": k = { x: y, y: s.y + s.height }; break; case "right": k = { x: s.x + s.width, y: v }; break; case "left": k = { x: s.x - a.width, y: v }; break; default: k = { x: s.x, y: s.y } }switch (Si(r)) { case "start": k[u] -= S * (i && g ? -1 : 1); break; case "end": k[u] += S * (i && g ? -1 : 1); break }return k } const FE = async (e, r, i) => { const { placement: s = "bottom", strategy: a = "absolute", middleware: c = [], platform: u } = i, f = c.filter(Boolean), h = await (u.isRTL == null ? void 0 : u.isRTL(r)); let g = await u.getElementRects({ reference: e, floating: r, strategy: a }), { x: y, y: v } = Ag(g, s, h), S = s, k = {}, P = 0; for (let C = 0; C < f.length; C++) { const { name: N, fn: j } = f[C], { x: E, y: R, data: O, reset: V } = await j({ x: y, y: v, initialPlacement: s, placement: S, strategy: a, middlewareData: k, rects: g, platform: u, elements: { reference: e, floating: r } }); y = E ?? y, v = R ?? v, k = { ...k, [N]: { ...k[N], ...O } }, V && P <= 50 && (P++, typeof V == "object" && (V.placement && (S = V.placement), V.rects && (g = V.rects === !0 ? await u.getElementRects({ reference: e, floating: r, strategy: a }) : V.rects), { x: y, y: v } = Ag(g, S, h)), C = -1) } return { x: y, y: v, placement: S, strategy: a, middlewareData: k } }; async function Eo(e, r) { var i; r === void 0 && (r = {}); const { x: s, y: a, platform: c, rects: u, elements: f, strategy: h } = e, { boundary: g = "clippingAncestors", rootBoundary: y = "viewport", elementContext: v = "floating", altBoundary: S = !1, padding: k = 0 } = Nn(r, e), P = v0(k), N = f[S ? v === "floating" ? "reference" : "floating" : v], j = Na(await c.getClippingRect({ element: (i = await (c.isElement == null ? void 0 : c.isElement(N))) == null || i ? N : N.contextElement || await (c.getDocumentElement == null ? void 0 : c.getDocumentElement(f.floating)), boundary: g, rootBoundary: y, strategy: h })), E = v === "floating" ? { x: s, y: a, width: u.floating.width, height: u.floating.height } : u.reference, R = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(f.floating)), O = await (c.isElement == null ? void 0 : c.isElement(R)) ? await (c.getScale == null ? void 0 : c.getScale(R)) || { x: 1, y: 1 } : { x: 1, y: 1 }, V = Na(c.convertOffsetParentRelativeRectToViewportRelativeRect ? await c.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: f, rect: E, offsetParent: R, strategy: h }) : E); return { top: (j.top - V.top + P.top) / O.y, bottom: (V.bottom - j.bottom + P.bottom) / O.y, left: (j.left - V.left + P.left) / O.x, right: (V.right - j.right + P.right) / O.x } } const zE = e => ({ name: "arrow", options: e, async fn(r) { const { x: i, y: s, placement: a, rects: c, platform: u, elements: f, middlewareData: h } = r, { element: g, padding: y = 0 } = Nn(e, r) || {}; if (g == null) return {}; const v = v0(y), S = { x: i, y: s }, k = $d(a), P = Wd(k), C = await u.getDimensions(g), N = k === "y", j = N ? "top" : "left", E = N ? "bottom" : "right", R = N ? "clientHeight" : "clientWidth", O = c.reference[P] + c.reference[k] - S[k] - c.floating[P], V = S[k] - c.reference[k], B = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(g)); let z = B ? B[R] : 0; (!z || !await (u.isElement == null ? void 0 : u.isElement(B))) && (z = f.floating[R] || c.floating[P]); const F = O / 2 - V / 2, Z = z / 2 - C[P] / 2 - 1, ie = Zn(v[j], Z), fe = Zn(v[E], Z), me = ie, ge = z - C[P] - fe, pe = z / 2 - C[P] / 2 + F, xe = $u(me, pe, ge), se = !h.arrow && Si(a) != null && pe !== xe && c.reference[P] / 2 - (pe < me ? ie : fe) - C[P] / 2 < 0, q = se ? pe < me ? pe - me : pe - ge : 0; return { [k]: S[k] + q, data: { [k]: xe, centerOffset: pe - xe - q, ...se && { alignmentOffset: q } }, reset: se } } }), BE = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(r) { var i, s; const { placement: a, middlewareData: c, rects: u, initialPlacement: f, platform: h, elements: g } = r, { mainAxis: y = !0, crossAxis: v = !0, fallbackPlacements: S, fallbackStrategy: k = "bestFit", fallbackAxisSideDirection: P = "none", flipAlignment: C = !0, ...N } = Nn(e, r); if ((i = c.arrow) != null && i.alignmentOffset) return {}; const j = Pn(a), E = an(f), R = Pn(f) === f, O = await (h.isRTL == null ? void 0 : h.isRTL(g.floating)), V = S || (R || !C ? [ba(f)] : IE(f)), B = P !== "none"; !S && B && V.push(...OE(f, C, P, O)); const z = [f, ...V], F = await Eo(r, N), Z = []; let ie = ((s = c.flip) == null ? void 0 : s.overflows) || []; if (y && Z.push(F[j]), v) { const pe = ME(a, u, O); Z.push(F[pe[0]], F[pe[1]]) } if (ie = [...ie, { placement: a, overflows: Z }], !Z.every(pe => pe <= 0)) { var fe, me; const pe = (((fe = c.flip) == null ? void 0 : fe.index) || 0) + 1, xe = z[pe]; if (xe && (!(v === "alignment" ? E !== an(xe) : !1) || ie.every(I => an(I.placement) === E ? I.overflows[0] > 0 : !0))) return { data: { index: pe, overflows: ie }, reset: { placement: xe } }; let se = (me = ie.filter(q => q.overflows[0] <= 0).sort((q, I) => q.overflows[1] - I.overflows[1])[0]) == null ? void 0 : me.placement; if (!se) switch (k) { case "bestFit": { var ge; const q = (ge = ie.filter(I => { if (B) { const X = an(I.placement); return X === E || X === "y" } return !0 }).map(I => [I.placement, I.overflows.filter(X => X > 0).reduce((X, G) => X + G, 0)]).sort((I, X) => I[1] - X[1])[0]) == null ? void 0 : ge[0]; q && (se = q); break } case "initialPlacement": se = f; break }if (a !== se) return { reset: { placement: se } } } return {} } } }; function Rg(e, r) { return { top: e.top - r.height, right: e.right - r.width, bottom: e.bottom - r.height, left: e.left - r.width } } function Mg(e) { return TE.some(r => e[r] >= 0) } const WE = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(r) { const { rects: i } = r, { strategy: s = "referenceHidden", ...a } = Nn(e, r); switch (s) { case "referenceHidden": { const c = await Eo(r, { ...a, elementContext: "reference" }), u = Rg(c, i.reference); return { data: { referenceHiddenOffsets: u, referenceHidden: Mg(u) } } } case "escaped": { const c = await Eo(r, { ...a, altBoundary: !0 }), u = Rg(c, i.floating); return { data: { escapedOffsets: u, escaped: Mg(u) } } } default: return {} } } } }, x0 = new Set(["left", "top"]); async function $E(e, r) { const { placement: i, platform: s, elements: a } = e, c = await (s.isRTL == null ? void 0 : s.isRTL(a.floating)), u = Pn(i), f = Si(i), h = an(i) === "y", g = x0.has(u) ? -1 : 1, y = c && h ? -1 : 1, v = Nn(r, e); let { mainAxis: S, crossAxis: k, alignmentAxis: P } = typeof v == "number" ? { mainAxis: v, crossAxis: 0, alignmentAxis: null } : { mainAxis: v.mainAxis || 0, crossAxis: v.crossAxis || 0, alignmentAxis: v.alignmentAxis }; return f && typeof P == "number" && (k = f === "end" ? P * -1 : P), h ? { x: k * y, y: S * g } : { x: S * g, y: k * y } } const UE = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(r) { var i, s; const { x: a, y: c, placement: u, middlewareData: f } = r, h = await $E(r, e); return u === ((i = f.offset) == null ? void 0 : i.placement) && (s = f.arrow) != null && s.alignmentOffset ? {} : { x: a + h.x, y: c + h.y, data: { ...h, placement: u } } } } }, HE = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(r) { const { x: i, y: s, placement: a } = r, { mainAxis: c = !0, crossAxis: u = !1, limiter: f = { fn: N => { let { x: j, y: E } = N; return { x: j, y: E } } }, ...h } = Nn(e, r), g = { x: i, y: s }, y = await Eo(r, h), v = an(Pn(a)), S = Bd(v); let k = g[S], P = g[v]; if (c) { const N = S === "y" ? "top" : "left", j = S === "y" ? "bottom" : "right", E = k + y[N], R = k - y[j]; k = $u(E, k, R) } if (u) { const N = v === "y" ? "top" : "left", j = v === "y" ? "bottom" : "right", E = P + y[N], R = P - y[j]; P = $u(E, P, R) } const C = f.fn({ ...r, [S]: k, [v]: P }); return { ...C, data: { x: C.x - i, y: C.y - s, enabled: { [S]: c, [v]: u } } } } } }, KE = function (e) { return e === void 0 && (e = {}), { options: e, fn(r) { const { x: i, y: s, placement: a, rects: c, middlewareData: u } = r, { offset: f = 0, mainAxis: h = !0, crossAxis: g = !0 } = Nn(e, r), y = { x: i, y: s }, v = an(a), S = Bd(v); let k = y[S], P = y[v]; const C = Nn(f, r), N = typeof C == "number" ? { mainAxis: C, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...C }; if (h) { const R = S === "y" ? "height" : "width", O = c.reference[S] - c.floating[R] + N.mainAxis, V = c.reference[S] + c.reference[R] - N.mainAxis; k < O ? k = O : k > V && (k = V) } if (g) { var j, E; const R = S === "y" ? "width" : "height", O = x0.has(Pn(a)), V = c.reference[v] - c.floating[R] + (O && ((j = u.offset) == null ? void 0 : j[v]) || 0) + (O ? 0 : N.crossAxis), B = c.reference[v] + c.reference[R] + (O ? 0 : ((E = u.offset) == null ? void 0 : E[v]) || 0) - (O ? N.crossAxis : 0); P < V ? P = V : P > B && (P = B) } return { [S]: k, [v]: P } } } }, GE = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(r) { var i, s; const { placement: a, rects: c, platform: u, elements: f } = r, { apply: h = () => { }, ...g } = Nn(e, r), y = await Eo(r, g), v = Pn(a), S = Si(a), k = an(a) === "y", { width: P, height: C } = c.floating; let N, j; v === "top" || v === "bottom" ? (N = v, j = S === (await (u.isRTL == null ? void 0 : u.isRTL(f.floating)) ? "start" : "end") ? "left" : "right") : (j = v, N = S === "end" ? "top" : "bottom"); const E = C - y.top - y.bottom, R = P - y.left - y.right, O = Zn(C - y[N], E), V = Zn(P - y[j], R), B = !r.middlewareData.shift; let z = O, F = V; if ((i = r.middlewareData.shift) != null && i.enabled.x && (F = R), (s = r.middlewareData.shift) != null && s.enabled.y && (z = E), B && !S) { const ie = Tt(y.left, 0), fe = Tt(y.right, 0), me = Tt(y.top, 0), ge = Tt(y.bottom, 0); k ? F = P - 2 * (ie !== 0 || fe !== 0 ? ie + fe : Tt(y.left, y.right)) : z = C - 2 * (me !== 0 || ge !== 0 ? me + ge : Tt(y.top, y.bottom)) } await h({ ...r, availableWidth: F, availableHeight: z }); const Z = await u.getDimensions(f.floating); return P !== Z.width || C !== Z.height ? { reset: { rects: !0 } } : {} } } }; function _a() { return typeof window < "u" } function Ci(e) { return w0(e) ? (e.nodeName || "").toLowerCase() : "#document" } function jt(e) { var r; return (e == null || (r = e.ownerDocument) == null ? void 0 : r.defaultView) || window } function fn(e) { var r; return (r = (w0(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : r.documentElement } function w0(e) { return _a() ? e instanceof Node || e instanceof jt(e).Node : !1 } function Qt(e) { return _a() ? e instanceof Element || e instanceof jt(e).Element : !1 } function dn(e) { return _a() ? e instanceof HTMLElement || e instanceof jt(e).HTMLElement : !1 } function Ig(e) { return !_a() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof jt(e).ShadowRoot } const YE = new Set(["inline", "contents"]); function Fo(e) { const { overflow: r, overflowX: i, overflowY: s, display: a } = Zt(e); return /auto|scroll|overlay|hidden|clip/.test(r + s + i) && !YE.has(a) } const XE = new Set(["table", "td", "th"]); function qE(e) { return XE.has(Ci(e)) } const QE = [":popover-open", ":modal"]; function La(e) { return QE.some(r => { try { return e.matches(r) } catch { return !1 } }) } const ZE = ["transform", "translate", "scale", "rotate", "perspective"], JE = ["transform", "translate", "scale", "rotate", "perspective", "filter"], eT = ["paint", "layout", "strict", "content"]; function Ud(e) { const r = Hd(), i = Qt(e) ? Zt(e) : e; return ZE.some(s => i[s] ? i[s] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !r && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !r && (i.filter ? i.filter !== "none" : !1) || JE.some(s => (i.willChange || "").includes(s)) || eT.some(s => (i.contain || "").includes(s)) } function tT(e) { let r = Jn(e); for (; dn(r) && !mi(r);) { if (Ud(r)) return r; if (La(r)) return null; r = Jn(r) } return null } function Hd() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const nT = new Set(["html", "body", "#document"]); function mi(e) { return nT.has(Ci(e)) } function Zt(e) { return jt(e).getComputedStyle(e) } function Oa(e) { return Qt(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function Jn(e) { if (Ci(e) === "html") return e; const r = e.assignedSlot || e.parentNode || Ig(e) && e.host || fn(e); return Ig(r) ? r.host : r } function S0(e) { const r = Jn(e); return mi(r) ? e.ownerDocument ? e.ownerDocument.body : e.body : dn(r) && Fo(r) ? r : S0(r) } function To(e, r, i) { var s; r === void 0 && (r = []), i === void 0 && (i = !0); const a = S0(e), c = a === ((s = e.ownerDocument) == null ? void 0 : s.body), u = jt(a); if (c) { const f = Hu(u); return r.concat(u, u.visualViewport || [], Fo(a) ? a : [], f && i ? To(f) : []) } return r.concat(a, To(a, [], i)) } function Hu(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function C0(e) { const r = Zt(e); let i = parseFloat(r.width) || 0, s = parseFloat(r.height) || 0; const a = dn(e), c = a ? e.offsetWidth : i, u = a ? e.offsetHeight : s, f = ka(i) !== c || ka(s) !== u; return f && (i = c, s = u), { width: i, height: s, $: f } } function Kd(e) { return Qt(e) ? e : e.contextElement } function di(e) { const r = Kd(e); if (!dn(r)) return un(1); const i = r.getBoundingClientRect(), { width: s, height: a, $: c } = C0(r); let u = (c ? ka(i.width) : i.width) / s, f = (c ? ka(i.height) : i.height) / a; return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), { x: u, y: f } } const rT = un(0); function k0(e) { const r = jt(e); return !Hd() || !r.visualViewport ? rT : { x: r.visualViewport.offsetLeft, y: r.visualViewport.offsetTop } } function iT(e, r, i) { return r === void 0 && (r = !1), !i || r && i !== jt(e) ? !1 : r } function Nr(e, r, i, s) { r === void 0 && (r = !1), i === void 0 && (i = !1); const a = e.getBoundingClientRect(), c = Kd(e); let u = un(1); r && (s ? Qt(s) && (u = di(s)) : u = di(e)); const f = iT(c, i, s) ? k0(c) : un(0); let h = (a.left + f.x) / u.x, g = (a.top + f.y) / u.y, y = a.width / u.x, v = a.height / u.y; if (c) { const S = jt(c), k = s && Qt(s) ? jt(s) : s; let P = S, C = Hu(P); for (; C && s && k !== P;) { const N = di(C), j = C.getBoundingClientRect(), E = Zt(C), R = j.left + (C.clientLeft + parseFloat(E.paddingLeft)) * N.x, O = j.top + (C.clientTop + parseFloat(E.paddingTop)) * N.y; h *= N.x, g *= N.y, y *= N.x, v *= N.y, h += R, g += O, P = jt(C), C = Hu(P) } } return Na({ width: y, height: v, x: h, y: g }) } function Va(e, r) { const i = Oa(e).scrollLeft; return r ? r.left + i : Nr(fn(e)).left + i } function b0(e, r) { const i = e.getBoundingClientRect(), s = i.left + r.scrollLeft - Va(e, i), a = i.top + r.scrollTop; return { x: s, y: a } } function oT(e) { let { elements: r, rect: i, offsetParent: s, strategy: a } = e; const c = a === "fixed", u = fn(s), f = r ? La(r.floating) : !1; if (s === u || f && c) return i; let h = { scrollLeft: 0, scrollTop: 0 }, g = un(1); const y = un(0), v = dn(s); if ((v || !v && !c) && ((Ci(s) !== "body" || Fo(u)) && (h = Oa(s)), dn(s))) { const k = Nr(s); g = di(s), y.x = k.x + s.clientLeft, y.y = k.y + s.clientTop } const S = u && !v && !c ? b0(u, h) : un(0); return { width: i.width * g.x, height: i.height * g.y, x: i.x * g.x - h.scrollLeft * g.x + y.x + S.x, y: i.y * g.y - h.scrollTop * g.y + y.y + S.y } } function sT(e) { return Array.from(e.getClientRects()) } function aT(e) { const r = fn(e), i = Oa(e), s = e.ownerDocument.body, a = Tt(r.scrollWidth, r.clientWidth, s.scrollWidth, s.clientWidth), c = Tt(r.scrollHeight, r.clientHeight, s.scrollHeight, s.clientHeight); let u = -i.scrollLeft + Va(e); const f = -i.scrollTop; return Zt(s).direction === "rtl" && (u += Tt(r.clientWidth, s.clientWidth) - a), { width: a, height: c, x: u, y: f } } const Dg = 25; function lT(e, r) { const i = jt(e), s = fn(e), a = i.visualViewport; let c = s.clientWidth, u = s.clientHeight, f = 0, h = 0; if (a) { c = a.width, u = a.height; const y = Hd(); (!y || y && r === "fixed") && (f = a.offsetLeft, h = a.offsetTop) } const g = Va(s); if (g <= 0) { const y = s.ownerDocument, v = y.body, S = getComputedStyle(v), k = y.compatMode === "CSS1Compat" && parseFloat(S.marginLeft) + parseFloat(S.marginRight) || 0, P = Math.abs(s.clientWidth - v.clientWidth - k); P <= Dg && (c -= P) } else g <= Dg && (c += g); return { width: c, height: u, x: f, y: h } } const cT = new Set(["absolute", "fixed"]); function uT(e, r) { const i = Nr(e, !0, r === "fixed"), s = i.top + e.clientTop, a = i.left + e.clientLeft, c = dn(e) ? di(e) : un(1), u = e.clientWidth * c.x, f = e.clientHeight * c.y, h = a * c.x, g = s * c.y; return { width: u, height: f, x: h, y: g } } function _g(e, r, i) { let s; if (r === "viewport") s = lT(e, i); else if (r === "document") s = aT(fn(e)); else if (Qt(r)) s = uT(r, i); else { const a = k0(e); s = { x: r.x - a.x, y: r.y - a.y, width: r.width, height: r.height } } return Na(s) } function N0(e, r) { const i = Jn(e); return i === r || !Qt(i) || mi(i) ? !1 : Zt(i).position === "fixed" || N0(i, r) } function dT(e, r) { const i = r.get(e); if (i) return i; let s = To(e, [], !1).filter(f => Qt(f) && Ci(f) !== "body"), a = null; const c = Zt(e).position === "fixed"; let u = c ? Jn(e) : e; for (; Qt(u) && !mi(u);) { const f = Zt(u), h = Ud(u); !h && f.position === "fixed" && (a = null), (c ? !h && !a : !h && f.position === "static" && !!a && cT.has(a.position) || Fo(u) && !h && N0(e, u)) ? s = s.filter(y => y !== u) : a = f, u = Jn(u) } return r.set(e, s), s } function fT(e) { let { element: r, boundary: i, rootBoundary: s, strategy: a } = e; const u = [...i === "clippingAncestors" ? La(r) ? [] : dT(r, this._c) : [].concat(i), s], f = u[0], h = u.reduce((g, y) => { const v = _g(r, y, a); return g.top = Tt(v.top, g.top), g.right = Zn(v.right, g.right), g.bottom = Zn(v.bottom, g.bottom), g.left = Tt(v.left, g.left), g }, _g(r, f, a)); return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top } } function pT(e) { const { width: r, height: i } = C0(e); return { width: r, height: i } } function hT(e, r, i) { const s = dn(r), a = fn(r), c = i === "fixed", u = Nr(e, !0, c, r); let f = { scrollLeft: 0, scrollTop: 0 }; const h = un(0); function g() { h.x = Va(a) } if (s || !s && !c) if ((Ci(r) !== "body" || Fo(a)) && (f = Oa(r)), s) { const k = Nr(r, !0, c, r); h.x = k.x + r.clientLeft, h.y = k.y + r.clientTop } else a && g(); c && !s && a && g(); const y = a && !s && !c ? b0(a, f) : un(0), v = u.left + f.scrollLeft - h.x - y.x, S = u.top + f.scrollTop - h.y - y.y; return { x: v, y: S, width: u.width, height: u.height } } function au(e) { return Zt(e).position === "static" } function Lg(e, r) { if (!dn(e) || Zt(e).position === "fixed") return null; if (r) return r(e); let i = e.offsetParent; return fn(e) === i && (i = i.ownerDocument.body), i } function P0(e, r) { const i = jt(e); if (La(e)) return i; if (!dn(e)) { let a = Jn(e); for (; a && !mi(a);) { if (Qt(a) && !au(a)) return a; a = Jn(a) } return i } let s = Lg(e, r); for (; s && qE(s) && au(s);)s = Lg(s, r); return s && mi(s) && au(s) && !Ud(s) ? i : s || tT(e) || i } const mT = async function (e) { const r = this.getOffsetParent || P0, i = this.getDimensions, s = await i(e.floating); return { reference: hT(e.reference, await r(e.floating), e.strategy), floating: { x: 0, y: 0, width: s.width, height: s.height } } }; function gT(e) { return Zt(e).direction === "rtl" } const yT = { convertOffsetParentRelativeRectToViewportRelativeRect: oT, getDocumentElement: fn, getClippingRect: fT, getOffsetParent: P0, getElementRects: mT, getClientRects: sT, getDimensions: pT, getScale: di, isElement: Qt, isRTL: gT }; function E0(e, r) { return e.x === r.x && e.y === r.y && e.width === r.width && e.height === r.height } function vT(e, r) { let i = null, s; const a = fn(e); function c() { var f; clearTimeout(s), (f = i) == null || f.disconnect(), i = null } function u(f, h) { f === void 0 && (f = !1), h === void 0 && (h = 1), c(); const g = e.getBoundingClientRect(), { left: y, top: v, width: S, height: k } = g; if (f || r(), !S || !k) return; const P = na(v), C = na(a.clientWidth - (y + S)), N = na(a.clientHeight - (v + k)), j = na(y), R = { rootMargin: -P + "px " + -C + "px " + -N + "px " + -j + "px", threshold: Tt(0, Zn(1, h)) || 1 }; let O = !0; function V(B) { const z = B[0].intersectionRatio; if (z !== h) { if (!O) return u(); z ? u(!1, z) : s = setTimeout(() => { u(!1, 1e-7) }, 1e3) } z === 1 && !E0(g, e.getBoundingClientRect()) && u(), O = !1 } try { i = new IntersectionObserver(V, { ...R, root: a.ownerDocument }) } catch { i = new IntersectionObserver(V, R) } i.observe(e) } return u(!0), c } function xT(e, r, i, s) { s === void 0 && (s = {}); const { ancestorScroll: a = !0, ancestorResize: c = !0, elementResize: u = typeof ResizeObserver == "function", layoutShift: f = typeof IntersectionObserver == "function", animationFrame: h = !1 } = s, g = Kd(e), y = a || c ? [...g ? To(g) : [], ...To(r)] : []; y.forEach(j => { a && j.addEventListener("scroll", i, { passive: !0 }), c && j.addEventListener("resize", i) }); const v = g && f ? vT(g, i) : null; let S = -1, k = null; u && (k = new ResizeObserver(j => { let [E] = j; E && E.target === g && k && (k.unobserve(r), cancelAnimationFrame(S), S = requestAnimationFrame(() => { var R; (R = k) == null || R.observe(r) })), i() }), g && !h && k.observe(g), k.observe(r)); let P, C = h ? Nr(e) : null; h && N(); function N() { const j = Nr(e); C && !E0(C, j) && i(), C = j, P = requestAnimationFrame(N) } return i(), () => { var j; y.forEach(E => { a && E.removeEventListener("scroll", i), c && E.removeEventListener("resize", i) }), v?.(), (j = k) == null || j.disconnect(), k = null, h && cancelAnimationFrame(P) } } const wT = UE, ST = HE, CT = BE, kT = GE, bT = WE, Og = zE, NT = KE, PT = (e, r, i) => { const s = new Map, a = { platform: yT, ...i }, c = { ...a.platform, _c: s }; return FE(e, r, { ...a, platform: c }) }; var ET = typeof document < "u", TT = function () { }, da = ET ? w.useLayoutEffect : TT; function Pa(e, r) { if (e === r) return !0; if (typeof e != typeof r) return !1; if (typeof e == "function" && e.toString() === r.toString()) return !0; let i, s, a; if (e && r && typeof e == "object") { if (Array.isArray(e)) { if (i = e.length, i !== r.length) return !1; for (s = i; s-- !== 0;)if (!Pa(e[s], r[s])) return !1; return !0 } if (a = Object.keys(e), i = a.length, i !== Object.keys(r).length) return !1; for (s = i; s-- !== 0;)if (!{}.hasOwnProperty.call(r, a[s])) return !1; for (s = i; s-- !== 0;) { const c = a[s]; if (!(c === "_owner" && e.$$typeof) && !Pa(e[c], r[c])) return !1 } return !0 } return e !== e && r !== r } function T0(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Vg(e, r) { const i = T0(e); return Math.round(r * i) / i } function lu(e) { const r = w.useRef(e); return da(() => { r.current = e }), r } function jT(e) { e === void 0 && (e = {}); const { placement: r = "bottom", strategy: i = "absolute", middleware: s = [], platform: a, elements: { reference: c, floating: u } = {}, transform: f = !0, whileElementsMounted: h, open: g } = e, [y, v] = w.useState({ x: 0, y: 0, strategy: i, placement: r, middlewareData: {}, isPositioned: !1 }), [S, k] = w.useState(s); Pa(S, s) || k(s); const [P, C] = w.useState(null), [N, j] = w.useState(null), E = w.useCallback(I => { I !== B.current && (B.current = I, C(I)) }, []), R = w.useCallback(I => { I !== z.current && (z.current = I, j(I)) }, []), O = c || P, V = u || N, B = w.useRef(null), z = w.useRef(null), F = w.useRef(y), Z = h != null, ie = lu(h), fe = lu(a), me = lu(g), ge = w.useCallback(() => { if (!B.current || !z.current) return; const I = { placement: r, strategy: i, middleware: S }; fe.current && (I.platform = fe.current), PT(B.current, z.current, I).then(X => { const G = { ...X, isPositioned: me.current !== !1 }; pe.current && !Pa(F.current, G) && (F.current = G, Oo.flushSync(() => { v(G) })) }) }, [S, r, i, fe, me]); da(() => { g === !1 && F.current.isPositioned && (F.current.isPositioned = !1, v(I => ({ ...I, isPositioned: !1 }))) }, [g]); const pe = w.useRef(!1); da(() => (pe.current = !0, () => { pe.current = !1 }), []), da(() => { if (O && (B.current = O), V && (z.current = V), O && V) { if (ie.current) return ie.current(O, V, ge); ge() } }, [O, V, ge, ie, Z]); const xe = w.useMemo(() => ({ reference: B, floating: z, setReference: E, setFloating: R }), [E, R]), se = w.useMemo(() => ({ reference: O, floating: V }), [O, V]), q = w.useMemo(() => { const I = { position: i, left: 0, top: 0 }; if (!se.floating) return I; const X = Vg(se.floating, y.x), G = Vg(se.floating, y.y); return f ? { ...I, transform: "translate(" + X + "px, " + G + "px)", ...T0(se.floating) >= 1.5 && { willChange: "transform" } } : { position: i, left: X, top: G } }, [i, f, se.floating, y.x, y.y]); return w.useMemo(() => ({ ...y, update: ge, refs: xe, elements: se, floatingStyles: q }), [y, ge, xe, se, q]) } const AT = e => { function r(i) { return {}.hasOwnProperty.call(i, "current") } return { name: "arrow", options: e, fn(i) { const { element: s, padding: a } = typeof e == "function" ? e(i) : e; return s && r(s) ? s.current != null ? Og({ element: s.current, padding: a }).fn(i) : {} : s ? Og({ element: s, padding: a }).fn(i) : {} } } }, RT = (e, r) => ({ ...wT(e), options: [e, r] }), MT = (e, r) => ({ ...ST(e), options: [e, r] }), IT = (e, r) => ({ ...NT(e), options: [e, r] }), DT = (e, r) => ({ ...CT(e), options: [e, r] }), _T = (e, r) => ({ ...kT(e), options: [e, r] }), LT = (e, r) => ({ ...bT(e), options: [e, r] }), OT = (e, r) => ({ ...AT(e), options: [e, r] }); var VT = "Arrow", j0 = w.forwardRef((e, r) => { const { children: i, width: s = 10, height: a = 5, ...c } = e; return p.jsx(Ie.svg, { ...c, ref: r, width: s, height: a, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? i : p.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); j0.displayName = VT; var FT = j0; function zT(e) { const [r, i] = w.useState(void 0); return at(() => { if (e) { i({ width: e.offsetWidth, height: e.offsetHeight }); const s = new ResizeObserver(a => { if (!Array.isArray(a) || !a.length) return; const c = a[0]; let u, f; if ("borderBoxSize" in c) { const h = c.borderBoxSize, g = Array.isArray(h) ? h[0] : h; u = g.inlineSize, f = g.blockSize } else u = e.offsetWidth, f = e.offsetHeight; i({ width: u, height: f }) }); return s.observe(e, { box: "border-box" }), () => s.unobserve(e) } else i(void 0) }, [e]), r } var Gd = "Popper", [A0, R0] = _o(Gd), [BT, M0] = A0(Gd), I0 = e => { const { __scopePopper: r, children: i } = e, [s, a] = w.useState(null); return p.jsx(BT, { scope: r, anchor: s, onAnchorChange: a, children: i }) }; I0.displayName = Gd; var D0 = "PopperAnchor", _0 = w.forwardRef((e, r) => { const { __scopePopper: i, virtualRef: s, ...a } = e, c = M0(D0, i), u = w.useRef(null), f = Xe(r, u), h = w.useRef(null); return w.useEffect(() => { const g = h.current; h.current = s?.current || u.current, g !== h.current && c.onAnchorChange(h.current) }), s ? null : p.jsx(Ie.div, { ...a, ref: f }) }); _0.displayName = D0; var Yd = "PopperContent", [WT, $T] = A0(Yd), L0 = w.forwardRef((e, r) => { const { __scopePopper: i, side: s = "bottom", sideOffset: a = 0, align: c = "center", alignOffset: u = 0, arrowPadding: f = 0, avoidCollisions: h = !0, collisionBoundary: g = [], collisionPadding: y = 0, sticky: v = "partial", hideWhenDetached: S = !1, updatePositionStrategy: k = "optimized", onPlaced: P, ...C } = e, N = M0(Yd, i), [j, E] = w.useState(null), R = Xe(r, K => E(K)), [O, V] = w.useState(null), B = zT(O), z = B?.width ?? 0, F = B?.height ?? 0, Z = s + (c !== "center" ? "-" + c : ""), ie = typeof y == "number" ? y : { top: 0, right: 0, bottom: 0, left: 0, ...y }, fe = Array.isArray(g) ? g : [g], me = fe.length > 0, ge = { padding: ie, boundary: fe.filter(HT), altBoundary: me }, { refs: pe, floatingStyles: xe, placement: se, isPositioned: q, middlewareData: I } = jT({ strategy: "fixed", placement: Z, whileElementsMounted: (...K) => xT(...K, { animationFrame: k === "always" }), elements: { reference: N.anchor }, middleware: [RT({ mainAxis: a + F, alignmentAxis: u }), h && MT({ mainAxis: !0, crossAxis: !1, limiter: v === "partial" ? IT() : void 0, ...ge }), h && DT({ ...ge }), _T({ ...ge, apply: ({ elements: K, rects: ce, availableWidth: ve, availableHeight: Se }) => { const { width: Pe, height: Re } = ce.reference, rt = K.floating.style; rt.setProperty("--radix-popper-available-width", `${ve}px`), rt.setProperty("--radix-popper-available-height", `${Se}px`), rt.setProperty("--radix-popper-anchor-width", `${Pe}px`), rt.setProperty("--radix-popper-anchor-height", `${Re}px`) } }), O && OT({ element: O, padding: f }), KT({ arrowWidth: z, arrowHeight: F }), S && LT({ strategy: "referenceHidden", ...ge })] }), [X, G] = F0(se), M = br(P); at(() => { q && M?.() }, [q, M]); const W = I.arrow?.x, oe = I.arrow?.y, ae = I.arrow?.centerOffset !== 0, [we, Ce] = w.useState(); return at(() => { j && Ce(window.getComputedStyle(j).zIndex) }, [j]), p.jsx("div", { ref: pe.setFloating, "data-radix-popper-content-wrapper": "", style: { ...xe, transform: q ? xe.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: we, "--radix-popper-transform-origin": [I.transformOrigin?.x, I.transformOrigin?.y].join(" "), ...I.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: p.jsx(WT, { scope: i, placedSide: X, onArrowChange: V, arrowX: W, arrowY: oe, shouldHideArrow: ae, children: p.jsx(Ie.div, { "data-side": X, "data-align": G, ...C, ref: R, style: { ...C.style, animation: q ? void 0 : "none" } }) }) }) }); L0.displayName = Yd; var O0 = "PopperArrow", UT = { top: "bottom", right: "left", bottom: "top", left: "right" }, V0 = w.forwardRef(function (r, i) { const { __scopePopper: s, ...a } = r, c = $T(O0, s), u = UT[c.placedSide]; return p.jsx("span", { ref: c.onArrowChange, style: { position: "absolute", left: c.arrowX, top: c.arrowY, [u]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[c.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[c.placedSide], visibility: c.shouldHideArrow ? "hidden" : void 0 }, children: p.jsx(FT, { ...a, ref: i, style: { ...a.style, display: "block" } }) }) }); V0.displayName = O0; function HT(e) { return e !== null } var KT = e => ({ name: "transformOrigin", options: e, fn(r) { const { placement: i, rects: s, middlewareData: a } = r, u = a.arrow?.centerOffset !== 0, f = u ? 0 : e.arrowWidth, h = u ? 0 : e.arrowHeight, [g, y] = F0(i), v = { start: "0%", center: "50%", end: "100%" }[y], S = (a.arrow?.x ?? 0) + f / 2, k = (a.arrow?.y ?? 0) + h / 2; let P = "", C = ""; return g === "bottom" ? (P = u ? v : `${S}px`, C = `${-h}px`) : g === "top" ? (P = u ? v : `${S}px`, C = `${s.floating.height + h}px`) : g === "right" ? (P = `${-h}px`, C = u ? v : `${k}px`) : g === "left" && (P = `${s.floating.width + h}px`, C = u ? v : `${k}px`), { data: { x: P, y: C } } } }); function F0(e) { const [r, i = "center"] = e.split("-"); return [r, i] } var GT = I0, YT = _0, XT = L0, qT = V0, QT = "Portal", z0 = w.forwardRef((e, r) => { const { container: i, ...s } = e, [a, c] = w.useState(!1); at(() => c(!0), []); const u = i || a && globalThis?.document?.body; return u ? bN.createPortal(p.jsx(Ie.div, { ...s, ref: r }), u) : null }); z0.displayName = QT; function ZT(e) { const r = JT(e), i = w.forwardRef((s, a) => { const { children: c, ...u } = s, f = w.Children.toArray(c), h = f.find(tj); if (h) { const g = h.props.children, y = f.map(v => v === h ? w.Children.count(g) > 1 ? w.Children.only(null) : w.isValidElement(g) ? g.props.children : null : v); return p.jsx(r, { ...u, ref: a, children: w.isValidElement(g) ? w.cloneElement(g, void 0, y) : null }) } return p.jsx(r, { ...u, ref: a, children: c }) }); return i.displayName = `${e}.Slot`, i } function JT(e) { const r = w.forwardRef((i, s) => { const { children: a, ...c } = i; if (w.isValidElement(a)) { const u = rj(a), f = nj(c, a.props); return a.type !== w.Fragment && (f.ref = s ? Lo(s, u) : u), w.cloneElement(a, f) } return w.Children.count(a) > 1 ? w.Children.only(null) : null }); return r.displayName = `${e}.SlotClone`, r } var ej = Symbol("radix.slottable"); function tj(e) { return w.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === ej } function nj(e, r) { const i = { ...r }; for (const s in r) { const a = e[s], c = r[s]; /^on[A-Z]/.test(s) ? a && c ? i[s] = (...f) => { const h = c(...f); return a(...f), h } : a && (i[s] = a) : s === "style" ? i[s] = { ...a, ...c } : s === "className" && (i[s] = [a, c].filter(Boolean).join(" ")) } return { ...e, ...i } } function rj(e) { let r = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning; return i ? e.ref : (r = Object.getOwnPropertyDescriptor(e, "ref")?.get, i = r && "isReactWarning" in r && r.isReactWarning, i ? e.props.ref : e.props.ref || e.ref) } function ij(e) { const r = w.useRef({ value: e, previous: e }); return w.useMemo(() => (r.current.value !== e && (r.current.previous = r.current.value, r.current.value = e), r.current.previous), [e]) } var B0 = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), oj = "VisuallyHidden", sj = w.forwardRef((e, r) => p.jsx(Ie.span, { ...e, ref: r, style: { ...B0, ...e.style } })); sj.displayName = oj; var aj = function (e) { if (typeof document > "u") return null; var r = Array.isArray(e) ? e[0] : e; return r.ownerDocument.body }, ni = new WeakMap, ra = new WeakMap, ia = {}, cu = 0, W0 = function (e) { return e && (e.host || W0(e.parentNode)) }, lj = function (e, r) { return r.map(function (i) { if (e.contains(i)) return i; var s = W0(i); return s && e.contains(s) ? s : (console.error("aria-hidden", i, "in not contained inside", e, ". Doing nothing"), null) }).filter(function (i) { return !!i }) }, cj = function (e, r, i, s) { var a = lj(r, Array.isArray(e) ? e : [e]); ia[i] || (ia[i] = new WeakMap); var c = ia[i], u = [], f = new Set, h = new Set(a), g = function (v) { !v || f.has(v) || (f.add(v), g(v.parentNode)) }; a.forEach(g); var y = function (v) { !v || h.has(v) || Array.prototype.forEach.call(v.children, function (S) { if (f.has(S)) y(S); else try { var k = S.getAttribute(s), P = k !== null && k !== "false", C = (ni.get(S) || 0) + 1, N = (c.get(S) || 0) + 1; ni.set(S, C), c.set(S, N), u.push(S), C === 1 && P && ra.set(S, !0), N === 1 && S.setAttribute(i, "true"), P || S.setAttribute(s, "true") } catch (j) { console.error("aria-hidden: cannot operate on ", S, j) } }) }; return y(r), f.clear(), cu++, function () { u.forEach(function (v) { var S = ni.get(v) - 1, k = c.get(v) - 1; ni.set(v, S), c.set(v, k), S || (ra.has(v) || v.removeAttribute(s), ra.delete(v)), k || v.removeAttribute(i) }), cu--, cu || (ni = new WeakMap, ni = new WeakMap, ra = new WeakMap, ia = {}) } }, uj = function (e, r, i) { i === void 0 && (i = "data-aria-hidden"); var s = Array.from(Array.isArray(e) ? e : [e]), a = aj(e); return a ? (s.push.apply(s, Array.from(a.querySelectorAll("[aria-live], script"))), cj(s, a, i, "aria-hidden")) : function () { return null } }, sn = function () { return sn = Object.assign || function (r) { for (var i, s = 1, a = arguments.length; s < a; s++) { i = arguments[s]; for (var c in i) Object.prototype.hasOwnProperty.call(i, c) && (r[c] = i[c]) } return r }, sn.apply(this, arguments) }; function $0(e, r) { var i = {}; for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (i[s] = e[s]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (i[s[a]] = e[s[a]]); return i } function dj(e, r, i) { if (i || arguments.length === 2) for (var s = 0, a = r.length, c; s < a; s++)(c || !(s in r)) && (c || (c = Array.prototype.slice.call(r, 0, s)), c[s] = r[s]); return e.concat(c || Array.prototype.slice.call(r)) } var fa = "right-scroll-bar-position", pa = "width-before-scroll-bar", fj = "with-scroll-bars-hidden", pj = "--removed-body-scroll-bar-size"; function uu(e, r) { return typeof e == "function" ? e(r) : e && (e.current = r), e } function hj(e, r) { var i = w.useState(function () { return { value: e, callback: r, facade: { get current() { return i.value }, set current(s) { var a = i.value; a !== s && (i.value = s, i.callback(s, a)) } } } })[0]; return i.callback = r, i.facade } var mj = typeof window < "u" ? w.useLayoutEffect : w.useEffect, Fg = new WeakMap; function gj(e, r) { var i = hj(null, function (s) { return e.forEach(function (a) { return uu(a, s) }) }); return mj(function () { var s = Fg.get(i); if (s) { var a = new Set(s), c = new Set(e), u = i.current; a.forEach(function (f) { c.has(f) || uu(f, null) }), c.forEach(function (f) { a.has(f) || uu(f, u) }) } Fg.set(i, e) }, [e]), i } function yj(e) { return e } function vj(e, r) { r === void 0 && (r = yj); var i = [], s = !1, a = { read: function () { if (s) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return i.length ? i[i.length - 1] : e }, useMedium: function (c) { var u = r(c, s); return i.push(u), function () { i = i.filter(function (f) { return f !== u }) } }, assignSyncMedium: function (c) { for (s = !0; i.length;) { var u = i; i = [], u.forEach(c) } i = { push: function (f) { return c(f) }, filter: function () { return i } } }, assignMedium: function (c) { s = !0; var u = []; if (i.length) { var f = i; i = [], f.forEach(c), u = i } var h = function () { var y = u; u = [], y.forEach(c) }, g = function () { return Promise.resolve().then(h) }; g(), i = { push: function (y) { u.push(y), g() }, filter: function (y) { return u = u.filter(y), i } } } }; return a } function xj(e) { e === void 0 && (e = {}); var r = vj(null); return r.options = sn({ async: !0, ssr: !1 }, e), r } var U0 = function (e) { var r = e.sideCar, i = $0(e, ["sideCar"]); if (!r) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var s = r.read(); if (!s) throw new Error("Sidecar medium not found"); return w.createElement(s, sn({}, i)) }; U0.isSideCarExport = !0; function wj(e, r) { return e.useMedium(r), U0 } var H0 = xj(), du = function () { }, Fa = w.forwardRef(function (e, r) { var i = w.useRef(null), s = w.useState({ onScrollCapture: du, onWheelCapture: du, onTouchMoveCapture: du }), a = s[0], c = s[1], u = e.forwardProps, f = e.children, h = e.className, g = e.removeScrollBar, y = e.enabled, v = e.shards, S = e.sideCar, k = e.noRelative, P = e.noIsolation, C = e.inert, N = e.allowPinchZoom, j = e.as, E = j === void 0 ? "div" : j, R = e.gapMode, O = $0(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), V = S, B = gj([i, r]), z = sn(sn({}, O), a); return w.createElement(w.Fragment, null, y && w.createElement(V, { sideCar: H0, removeScrollBar: g, shards: v, noRelative: k, noIsolation: P, inert: C, setCallbacks: c, allowPinchZoom: !!N, lockRef: i, gapMode: R }), u ? w.cloneElement(w.Children.only(f), sn(sn({}, z), { ref: B })) : w.createElement(E, sn({}, z, { className: h, ref: B }), f)) }); Fa.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; Fa.classNames = { fullWidth: pa, zeroRight: fa }; var Sj = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function Cj() { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var r = Sj(); return r && e.setAttribute("nonce", r), e } function kj(e, r) { e.styleSheet ? e.styleSheet.cssText = r : e.appendChild(document.createTextNode(r)) } function bj(e) { var r = document.head || document.getElementsByTagName("head")[0]; r.appendChild(e) } var Nj = function () { var e = 0, r = null; return { add: function (i) { e == 0 && (r = Cj()) && (kj(r, i), bj(r)), e++ }, remove: function () { e--, !e && r && (r.parentNode && r.parentNode.removeChild(r), r = null) } } }, Pj = function () { var e = Nj(); return function (r, i) { w.useEffect(function () { return e.add(r), function () { e.remove() } }, [r && i]) } }, K0 = function () { var e = Pj(), r = function (i) { var s = i.styles, a = i.dynamic; return e(s, a), null }; return r }, Ej = { left: 0, top: 0, right: 0, gap: 0 }, fu = function (e) { return parseInt(e || "", 10) || 0 }, Tj = function (e) { var r = window.getComputedStyle(document.body), i = r[e === "padding" ? "paddingLeft" : "marginLeft"], s = r[e === "padding" ? "paddingTop" : "marginTop"], a = r[e === "padding" ? "paddingRight" : "marginRight"]; return [fu(i), fu(s), fu(a)] }, jj = function (e) { if (e === void 0 && (e = "margin"), typeof window > "u") return Ej; var r = Tj(e), i = document.documentElement.clientWidth, s = window.innerWidth; return { left: r[0], top: r[1], right: r[2], gap: Math.max(0, s - i + r[2] - r[0]) } }, Aj = K0(), fi = "data-scroll-locked", Rj = function (e, r, i, s) {
  var a = e.left, c = e.top, u = e.right, f = e.gap; return i === void 0 && (i = "margin"), `
  .`.concat(fj, ` {
   overflow: hidden `).concat(s, `;
   padding-right: `).concat(f, "px ").concat(s, `;
  }
  body[`).concat(fi, `] {
    overflow: hidden `).concat(s, `;
    overscroll-behavior: contain;
    `).concat([r && "position: relative ".concat(s, ";"), i === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(c, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(s, `;
    `), i === "padding" && "padding-right: ".concat(f, "px ").concat(s, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(fa, ` {
    right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(pa, ` {
    margin-right: `).concat(f, "px ").concat(s, `;
  }
  
  .`).concat(fa, " .").concat(fa, ` {
    right: 0 `).concat(s, `;
  }
  
  .`).concat(pa, " .").concat(pa, ` {
    margin-right: 0 `).concat(s, `;
  }
  
  body[`).concat(fi, `] {
    `).concat(pj, ": ").concat(f, `px;
  }
`)
}, zg = function () { var e = parseInt(document.body.getAttribute(fi) || "0", 10); return isFinite(e) ? e : 0 }, Mj = function () { w.useEffect(function () { return document.body.setAttribute(fi, (zg() + 1).toString()), function () { var e = zg() - 1; e <= 0 ? document.body.removeAttribute(fi) : document.body.setAttribute(fi, e.toString()) } }, []) }, Ij = function (e) { var r = e.noRelative, i = e.noImportant, s = e.gapMode, a = s === void 0 ? "margin" : s; Mj(); var c = w.useMemo(function () { return jj(a) }, [a]); return w.createElement(Aj, { styles: Rj(c, !r, a, i ? "" : "!important") }) }, Ku = !1; if (typeof window < "u") try { var oa = Object.defineProperty({}, "passive", { get: function () { return Ku = !0, !0 } }); window.addEventListener("test", oa, oa), window.removeEventListener("test", oa, oa) } catch { Ku = !1 } var ri = Ku ? { passive: !1 } : !1, Dj = function (e) { return e.tagName === "TEXTAREA" }, G0 = function (e, r) { if (!(e instanceof Element)) return !1; var i = window.getComputedStyle(e); return i[r] !== "hidden" && !(i.overflowY === i.overflowX && !Dj(e) && i[r] === "visible") }, _j = function (e) { return G0(e, "overflowY") }, Lj = function (e) { return G0(e, "overflowX") }, Bg = function (e, r) { var i = r.ownerDocument, s = r; do { typeof ShadowRoot < "u" && s instanceof ShadowRoot && (s = s.host); var a = Y0(e, s); if (a) { var c = X0(e, s), u = c[1], f = c[2]; if (u > f) return !0 } s = s.parentNode } while (s && s !== i.body); return !1 }, Oj = function (e) { var r = e.scrollTop, i = e.scrollHeight, s = e.clientHeight; return [r, i, s] }, Vj = function (e) { var r = e.scrollLeft, i = e.scrollWidth, s = e.clientWidth; return [r, i, s] }, Y0 = function (e, r) { return e === "v" ? _j(r) : Lj(r) }, X0 = function (e, r) { return e === "v" ? Oj(r) : Vj(r) }, Fj = function (e, r) { return e === "h" && r === "rtl" ? -1 : 1 }, zj = function (e, r, i, s, a) { var c = Fj(e, window.getComputedStyle(r).direction), u = c * s, f = i.target, h = r.contains(f), g = !1, y = u > 0, v = 0, S = 0; do { if (!f) break; var k = X0(e, f), P = k[0], C = k[1], N = k[2], j = C - N - c * P; (P || j) && Y0(e, f) && (v += j, S += P); var E = f.parentNode; f = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E } while (!h && f !== document.body || h && (r.contains(f) || r === f)); return (y && Math.abs(v) < 1 || !y && Math.abs(S) < 1) && (g = !0), g }, sa = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, Wg = function (e) { return [e.deltaX, e.deltaY] }, $g = function (e) { return e && "current" in e ? e.current : e }, Bj = function (e, r) { return e[0] === r[0] && e[1] === r[1] }, Wj = function (e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}, $j = 0, ii = []; function Uj(e) { var r = w.useRef([]), i = w.useRef([0, 0]), s = w.useRef(), a = w.useState($j++)[0], c = w.useState(K0)[0], u = w.useRef(e); w.useEffect(function () { u.current = e }, [e]), w.useEffect(function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(a)); var C = dj([e.lockRef.current], (e.shards || []).map($g), !0).filter(Boolean); return C.forEach(function (N) { return N.classList.add("allow-interactivity-".concat(a)) }), function () { document.body.classList.remove("block-interactivity-".concat(a)), C.forEach(function (N) { return N.classList.remove("allow-interactivity-".concat(a)) }) } } }, [e.inert, e.lockRef.current, e.shards]); var f = w.useCallback(function (C, N) { if ("touches" in C && C.touches.length === 2 || C.type === "wheel" && C.ctrlKey) return !u.current.allowPinchZoom; var j = sa(C), E = i.current, R = "deltaX" in C ? C.deltaX : E[0] - j[0], O = "deltaY" in C ? C.deltaY : E[1] - j[1], V, B = C.target, z = Math.abs(R) > Math.abs(O) ? "h" : "v"; if ("touches" in C && z === "h" && B.type === "range") return !1; var F = window.getSelection(), Z = F && F.anchorNode, ie = Z ? Z === B || Z.contains(B) : !1; if (ie) return !1; var fe = Bg(z, B); if (!fe) return !0; if (fe ? V = z : (V = z === "v" ? "h" : "v", fe = Bg(z, B)), !fe) return !1; if (!s.current && "changedTouches" in C && (R || O) && (s.current = V), !V) return !0; var me = s.current || V; return zj(me, N, C, me === "h" ? R : O) }, []), h = w.useCallback(function (C) { var N = C; if (!(!ii.length || ii[ii.length - 1] !== c)) { var j = "deltaY" in N ? Wg(N) : sa(N), E = r.current.filter(function (V) { return V.name === N.type && (V.target === N.target || N.target === V.shadowParent) && Bj(V.delta, j) })[0]; if (E && E.should) { N.cancelable && N.preventDefault(); return } if (!E) { var R = (u.current.shards || []).map($g).filter(Boolean).filter(function (V) { return V.contains(N.target) }), O = R.length > 0 ? f(N, R[0]) : !u.current.noIsolation; O && N.cancelable && N.preventDefault() } } }, []), g = w.useCallback(function (C, N, j, E) { var R = { name: C, delta: N, target: j, should: E, shadowParent: Hj(j) }; r.current.push(R), setTimeout(function () { r.current = r.current.filter(function (O) { return O !== R }) }, 1) }, []), y = w.useCallback(function (C) { i.current = sa(C), s.current = void 0 }, []), v = w.useCallback(function (C) { g(C.type, Wg(C), C.target, f(C, e.lockRef.current)) }, []), S = w.useCallback(function (C) { g(C.type, sa(C), C.target, f(C, e.lockRef.current)) }, []); w.useEffect(function () { return ii.push(c), e.setCallbacks({ onScrollCapture: v, onWheelCapture: v, onTouchMoveCapture: S }), document.addEventListener("wheel", h, ri), document.addEventListener("touchmove", h, ri), document.addEventListener("touchstart", y, ri), function () { ii = ii.filter(function (C) { return C !== c }), document.removeEventListener("wheel", h, ri), document.removeEventListener("touchmove", h, ri), document.removeEventListener("touchstart", y, ri) } }, []); var k = e.removeScrollBar, P = e.inert; return w.createElement(w.Fragment, null, P ? w.createElement(c, { styles: Wj(a) }) : null, k ? w.createElement(Ij, { noRelative: e.noRelative, gapMode: e.gapMode }) : null) } function Hj(e) { for (var r = null; e !== null;)e instanceof ShadowRoot && (r = e.host, e = e.host), e = e.parentNode; return r } const Kj = wj(H0, Uj); var q0 = w.forwardRef(function (e, r) { return w.createElement(Fa, sn({}, e, { ref: r, sideCar: Kj })) }); q0.classNames = Fa.classNames; var Gj = [" ", "Enter", "ArrowUp", "ArrowDown"], Yj = [" ", "Enter"], Pr = "Select", [za, Ba, Xj] = Iv(Pr), [ki] = _o(Pr, [Xj, R0]), Wa = R0(), [qj, tr] = ki(Pr), [Qj, Zj] = ki(Pr), Q0 = e => { const { __scopeSelect: r, children: i, open: s, defaultOpen: a, onOpenChange: c, value: u, defaultValue: f, onValueChange: h, dir: g, name: y, autoComplete: v, disabled: S, required: k, form: P } = e, C = Wa(r), [N, j] = w.useState(null), [E, R] = w.useState(null), [O, V] = w.useState(!1), B = zv(g), [z, F] = Po({ prop: s, defaultProp: a ?? !1, onChange: c, caller: Pr }), [Z, ie] = Po({ prop: u, defaultProp: f, onChange: h, caller: Pr }), fe = w.useRef(null), me = N ? P || !!N.closest("form") : !0, [ge, pe] = w.useState(new Set), xe = Array.from(ge).map(se => se.props.value).join(";"); return p.jsx(GT, { ...C, children: p.jsxs(qj, { required: k, scope: r, trigger: N, onTriggerChange: j, valueNode: E, onValueNodeChange: R, valueNodeHasChildren: O, onValueNodeHasChildrenChange: V, contentId: Vo(), value: Z, onValueChange: ie, open: z, onOpenChange: F, dir: B, triggerPointerDownPosRef: fe, disabled: S, children: [p.jsx(za.Provider, { scope: r, children: p.jsx(Qj, { scope: e.__scopeSelect, onNativeOptionAdd: w.useCallback(se => { pe(q => new Set(q).add(se)) }, []), onNativeOptionRemove: w.useCallback(se => { pe(q => { const I = new Set(q); return I.delete(se), I }) }, []), children: i }) }), me ? p.jsxs(xx, { "aria-hidden": !0, required: k, tabIndex: -1, name: y, autoComplete: v, value: Z, onChange: se => ie(se.target.value), disabled: S, form: P, children: [Z === void 0 ? p.jsx("option", { value: "" }) : null, Array.from(ge)] }, xe) : null] }) }) }; Q0.displayName = Pr; var Z0 = "SelectTrigger", J0 = w.forwardRef((e, r) => { const { __scopeSelect: i, disabled: s = !1, ...a } = e, c = Wa(i), u = tr(Z0, i), f = u.disabled || s, h = Xe(r, u.onTriggerChange), g = Ba(i), y = w.useRef("touch"), [v, S, k] = Sx(C => { const N = g().filter(R => !R.disabled), j = N.find(R => R.value === u.value), E = Cx(N, C, j); E !== void 0 && u.onValueChange(E.value) }), P = C => { f || (u.onOpenChange(!0), k()), C && (u.triggerPointerDownPosRef.current = { x: Math.round(C.pageX), y: Math.round(C.pageY) }) }; return p.jsx(YT, { asChild: !0, ...c, children: p.jsx(Ie.button, { type: "button", role: "combobox", "aria-controls": u.contentId, "aria-expanded": u.open, "aria-required": u.required, "aria-autocomplete": "none", dir: u.dir, "data-state": u.open ? "open" : "closed", disabled: f, "data-disabled": f ? "" : void 0, "data-placeholder": wx(u.value) ? "" : void 0, ...a, ref: h, onClick: $e(a.onClick, C => { C.currentTarget.focus(), y.current !== "mouse" && P(C) }), onPointerDown: $e(a.onPointerDown, C => { y.current = C.pointerType; const N = C.target; N.hasPointerCapture(C.pointerId) && N.releasePointerCapture(C.pointerId), C.button === 0 && C.ctrlKey === !1 && C.pointerType === "mouse" && (P(C), C.preventDefault()) }), onKeyDown: $e(a.onKeyDown, C => { const N = v.current !== ""; !(C.ctrlKey || C.altKey || C.metaKey) && C.key.length === 1 && S(C.key), !(N && C.key === " ") && Gj.includes(C.key) && (P(), C.preventDefault()) }) }) }) }); J0.displayName = Z0; var ex = "SelectValue", tx = w.forwardRef((e, r) => { const { __scopeSelect: i, className: s, style: a, children: c, placeholder: u = "", ...f } = e, h = tr(ex, i), { onValueNodeHasChildrenChange: g } = h, y = c !== void 0, v = Xe(r, h.onValueNodeChange); return at(() => { g(y) }, [g, y]), p.jsx(Ie.span, { ...f, ref: v, style: { pointerEvents: "none" }, children: wx(h.value) ? p.jsx(p.Fragment, { children: u }) : c }) }); tx.displayName = ex; var Jj = "SelectIcon", nx = w.forwardRef((e, r) => { const { __scopeSelect: i, children: s, ...a } = e; return p.jsx(Ie.span, { "aria-hidden": !0, ...a, ref: r, children: s || "" }) }); nx.displayName = Jj; var eA = "SelectPortal", rx = e => p.jsx(z0, { asChild: !0, ...e }); rx.displayName = eA; var Er = "SelectContent", ix = w.forwardRef((e, r) => { const i = tr(Er, e.__scopeSelect), [s, a] = w.useState(); if (at(() => { a(new DocumentFragment) }, []), !i.open) { const c = s; return c ? Oo.createPortal(p.jsx(ox, { scope: e.__scopeSelect, children: p.jsx(za.Slot, { scope: e.__scopeSelect, children: p.jsx("div", { children: e.children }) }) }), c) : null } return p.jsx(sx, { ...e, ref: r }) }); ix.displayName = Er; var qt = 10, [ox, nr] = ki(Er), tA = "SelectContentImpl", nA = ZT("SelectContent.RemoveScroll"), sx = w.forwardRef((e, r) => { const { __scopeSelect: i, position: s = "item-aligned", onCloseAutoFocus: a, onEscapeKeyDown: c, onPointerDownOutside: u, side: f, sideOffset: h, align: g, alignOffset: y, arrowPadding: v, collisionBoundary: S, collisionPadding: k, sticky: P, hideWhenDetached: C, avoidCollisions: N, ...j } = e, E = tr(Er, i), [R, O] = w.useState(null), [V, B] = w.useState(null), z = Xe(r, K => O(K)), [F, Z] = w.useState(null), [ie, fe] = w.useState(null), me = Ba(i), [ge, pe] = w.useState(!1), xe = w.useRef(!1); w.useEffect(() => { if (R) return uj(R) }, [R]), wE(); const se = w.useCallback(K => { const [ce, ...ve] = me().map(Re => Re.ref.current), [Se] = ve.slice(-1), Pe = document.activeElement; for (const Re of K) if (Re === Pe || (Re?.scrollIntoView({ block: "nearest" }), Re === ce && V && (V.scrollTop = 0), Re === Se && V && (V.scrollTop = V.scrollHeight), Re?.focus(), document.activeElement !== Pe)) return }, [me, V]), q = w.useCallback(() => se([F, R]), [se, F, R]); w.useEffect(() => { ge && q() }, [ge, q]); const { onOpenChange: I, triggerPointerDownPosRef: X } = E; w.useEffect(() => { if (R) { let K = { x: 0, y: 0 }; const ce = Se => { K = { x: Math.abs(Math.round(Se.pageX) - (X.current?.x ?? 0)), y: Math.abs(Math.round(Se.pageY) - (X.current?.y ?? 0)) } }, ve = Se => { K.x <= 10 && K.y <= 10 ? Se.preventDefault() : R.contains(Se.target) || I(!1), document.removeEventListener("pointermove", ce), X.current = null }; return X.current !== null && (document.addEventListener("pointermove", ce), document.addEventListener("pointerup", ve, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", ce), document.removeEventListener("pointerup", ve, { capture: !0 }) } } }, [R, I, X]), w.useEffect(() => { const K = () => I(!1); return window.addEventListener("blur", K), window.addEventListener("resize", K), () => { window.removeEventListener("blur", K), window.removeEventListener("resize", K) } }, [I]); const [G, M] = Sx(K => { const ce = me().filter(Pe => !Pe.disabled), ve = ce.find(Pe => Pe.ref.current === document.activeElement), Se = Cx(ce, K, ve); Se && setTimeout(() => Se.ref.current.focus()) }), W = w.useCallback((K, ce, ve) => { const Se = !xe.current && !ve; (E.value !== void 0 && E.value === ce || Se) && (Z(K), Se && (xe.current = !0)) }, [E.value]), oe = w.useCallback(() => R?.focus(), [R]), ae = w.useCallback((K, ce, ve) => { const Se = !xe.current && !ve; (E.value !== void 0 && E.value === ce || Se) && fe(K) }, [E.value]), we = s === "popper" ? Gu : ax, Ce = we === Gu ? { side: f, sideOffset: h, align: g, alignOffset: y, arrowPadding: v, collisionBoundary: S, collisionPadding: k, sticky: P, hideWhenDetached: C, avoidCollisions: N } : {}; return p.jsx(ox, { scope: i, content: R, viewport: V, onViewportChange: B, itemRefCallback: W, selectedItem: F, onItemLeave: oe, itemTextRefCallback: ae, focusSelectedItem: q, selectedItemText: ie, position: s, isPositioned: ge, searchRef: G, children: p.jsx(q0, { as: nA, allowPinchZoom: !0, children: p.jsx(g0, { asChild: !0, trapped: E.open, onMountAutoFocus: K => { K.preventDefault() }, onUnmountAutoFocus: $e(a, K => { E.trigger?.focus({ preventScroll: !0 }), K.preventDefault() }), children: p.jsx(h0, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: c, onPointerDownOutside: u, onFocusOutside: K => K.preventDefault(), onDismiss: () => E.onOpenChange(!1), children: p.jsx(we, { role: "listbox", id: E.contentId, "data-state": E.open ? "open" : "closed", dir: E.dir, onContextMenu: K => K.preventDefault(), ...j, ...Ce, onPlaced: () => pe(!0), ref: z, style: { display: "flex", flexDirection: "column", outline: "none", ...j.style }, onKeyDown: $e(j.onKeyDown, K => { const ce = K.ctrlKey || K.altKey || K.metaKey; if (K.key === "Tab" && K.preventDefault(), !ce && K.key.length === 1 && M(K.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(K.key)) { let Se = me().filter(Pe => !Pe.disabled).map(Pe => Pe.ref.current); if (["ArrowUp", "End"].includes(K.key) && (Se = Se.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(K.key)) { const Pe = K.target, Re = Se.indexOf(Pe); Se = Se.slice(Re + 1) } setTimeout(() => se(Se)), K.preventDefault() } }) }) }) }) }) }) }); sx.displayName = tA; var rA = "SelectItemAlignedPosition", ax = w.forwardRef((e, r) => { const { __scopeSelect: i, onPlaced: s, ...a } = e, c = tr(Er, i), u = nr(Er, i), [f, h] = w.useState(null), [g, y] = w.useState(null), v = Xe(r, z => y(z)), S = Ba(i), k = w.useRef(!1), P = w.useRef(!0), { viewport: C, selectedItem: N, selectedItemText: j, focusSelectedItem: E } = u, R = w.useCallback(() => { if (c.trigger && c.valueNode && f && g && C && N && j) { const z = c.trigger.getBoundingClientRect(), F = g.getBoundingClientRect(), Z = c.valueNode.getBoundingClientRect(), ie = j.getBoundingClientRect(); if (c.dir !== "rtl") { const Pe = ie.left - F.left, Re = Z.left - Pe, rt = z.left - Re, zt = z.width + rt, Tr = Math.max(zt, F.width), jr = window.innerWidth - qt, rr = wg(Re, [qt, Math.max(qt, jr - Tr)]); f.style.minWidth = zt + "px", f.style.left = rr + "px" } else { const Pe = F.right - ie.right, Re = window.innerWidth - Z.right - Pe, rt = window.innerWidth - z.right - Re, zt = z.width + rt, Tr = Math.max(zt, F.width), jr = window.innerWidth - qt, rr = wg(Re, [qt, Math.max(qt, jr - Tr)]); f.style.minWidth = zt + "px", f.style.right = rr + "px" } const fe = S(), me = window.innerHeight - qt * 2, ge = C.scrollHeight, pe = window.getComputedStyle(g), xe = parseInt(pe.borderTopWidth, 10), se = parseInt(pe.paddingTop, 10), q = parseInt(pe.borderBottomWidth, 10), I = parseInt(pe.paddingBottom, 10), X = xe + se + ge + I + q, G = Math.min(N.offsetHeight * 5, X), M = window.getComputedStyle(C), W = parseInt(M.paddingTop, 10), oe = parseInt(M.paddingBottom, 10), ae = z.top + z.height / 2 - qt, we = me - ae, Ce = N.offsetHeight / 2, K = N.offsetTop + Ce, ce = xe + se + K, ve = X - ce; if (ce <= ae) { const Pe = fe.length > 0 && N === fe[fe.length - 1].ref.current; f.style.bottom = "0px"; const Re = g.clientHeight - C.offsetTop - C.offsetHeight, rt = Math.max(we, Ce + (Pe ? oe : 0) + Re + q), zt = ce + rt; f.style.height = zt + "px" } else { const Pe = fe.length > 0 && N === fe[0].ref.current; f.style.top = "0px"; const rt = Math.max(ae, xe + C.offsetTop + (Pe ? W : 0) + Ce) + ve; f.style.height = rt + "px", C.scrollTop = ce - ae + C.offsetTop } f.style.margin = `${qt}px 0`, f.style.minHeight = G + "px", f.style.maxHeight = me + "px", s?.(), requestAnimationFrame(() => k.current = !0) } }, [S, c.trigger, c.valueNode, f, g, C, N, j, c.dir, s]); at(() => R(), [R]); const [O, V] = w.useState(); at(() => { g && V(window.getComputedStyle(g).zIndex) }, [g]); const B = w.useCallback(z => { z && P.current === !0 && (R(), E?.(), P.current = !1) }, [R, E]); return p.jsx(oA, { scope: i, contentWrapper: f, shouldExpandOnScrollRef: k, onScrollButtonChange: B, children: p.jsx("div", { ref: h, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: O }, children: p.jsx(Ie.div, { ...a, ref: v, style: { boxSizing: "border-box", maxHeight: "100%", ...a.style } }) }) }) }); ax.displayName = rA; var iA = "SelectPopperPosition", Gu = w.forwardRef((e, r) => { const { __scopeSelect: i, align: s = "start", collisionPadding: a = qt, ...c } = e, u = Wa(i); return p.jsx(XT, { ...u, ...c, ref: r, align: s, collisionPadding: a, style: { boxSizing: "border-box", ...c.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); Gu.displayName = iA; var [oA, Xd] = ki(Er, {}), Yu = "SelectViewport", lx = w.forwardRef((e, r) => { const { __scopeSelect: i, nonce: s, ...a } = e, c = nr(Yu, i), u = Xd(Yu, i), f = Xe(r, c.onViewportChange), h = w.useRef(0); return p.jsxs(p.Fragment, { children: [p.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: s }), p.jsx(za.Slot, { scope: i, children: p.jsx(Ie.div, { "data-radix-select-viewport": "", role: "presentation", ...a, ref: f, style: { position: "relative", flex: 1, overflow: "hidden auto", ...a.style }, onScroll: $e(a.onScroll, g => { const y = g.currentTarget, { contentWrapper: v, shouldExpandOnScrollRef: S } = u; if (S?.current && v) { const k = Math.abs(h.current - y.scrollTop); if (k > 0) { const P = window.innerHeight - qt * 2, C = parseFloat(v.style.minHeight), N = parseFloat(v.style.height), j = Math.max(C, N); if (j < P) { const E = j + k, R = Math.min(P, E), O = E - R; v.style.height = R + "px", v.style.bottom === "0px" && (y.scrollTop = O > 0 ? O : 0, v.style.justifyContent = "flex-end") } } } h.current = y.scrollTop }) }) })] }) }); lx.displayName = Yu; var cx = "SelectGroup", [sA, aA] = ki(cx), lA = w.forwardRef((e, r) => { const { __scopeSelect: i, ...s } = e, a = Vo(); return p.jsx(sA, { scope: i, id: a, children: p.jsx(Ie.div, { role: "group", "aria-labelledby": a, ...s, ref: r }) }) }); lA.displayName = cx; var ux = "SelectLabel", cA = w.forwardRef((e, r) => { const { __scopeSelect: i, ...s } = e, a = aA(ux, i); return p.jsx(Ie.div, { id: a.id, ...s, ref: r }) }); cA.displayName = ux; var Ea = "SelectItem", [uA, dx] = ki(Ea), fx = w.forwardRef((e, r) => { const { __scopeSelect: i, value: s, disabled: a = !1, textValue: c, ...u } = e, f = tr(Ea, i), h = nr(Ea, i), g = f.value === s, [y, v] = w.useState(c ?? ""), [S, k] = w.useState(!1), P = Xe(r, E => h.itemRefCallback?.(E, s, a)), C = Vo(), N = w.useRef("touch"), j = () => { a || (f.onValueChange(s), f.onOpenChange(!1)) }; if (s === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return p.jsx(uA, { scope: i, value: s, disabled: a, textId: C, isSelected: g, onItemTextChange: w.useCallback(E => { v(R => R || (E?.textContent ?? "").trim()) }, []), children: p.jsx(za.ItemSlot, { scope: i, value: s, disabled: a, textValue: y, children: p.jsx(Ie.div, { role: "option", "aria-labelledby": C, "data-highlighted": S ? "" : void 0, "aria-selected": g && S, "data-state": g ? "checked" : "unchecked", "aria-disabled": a || void 0, "data-disabled": a ? "" : void 0, tabIndex: a ? void 0 : -1, ...u, ref: P, onFocus: $e(u.onFocus, () => k(!0)), onBlur: $e(u.onBlur, () => k(!1)), onClick: $e(u.onClick, () => { N.current !== "mouse" && j() }), onPointerUp: $e(u.onPointerUp, () => { N.current === "mouse" && j() }), onPointerDown: $e(u.onPointerDown, E => { N.current = E.pointerType }), onPointerMove: $e(u.onPointerMove, E => { N.current = E.pointerType, a ? h.onItemLeave?.() : N.current === "mouse" && E.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: $e(u.onPointerLeave, E => { E.currentTarget === document.activeElement && h.onItemLeave?.() }), onKeyDown: $e(u.onKeyDown, E => { h.searchRef?.current !== "" && E.key === " " || (Yj.includes(E.key) && j(), E.key === " " && E.preventDefault()) }) }) }) }) }); fx.displayName = Ea; var mo = "SelectItemText", px = w.forwardRef((e, r) => { const { __scopeSelect: i, className: s, style: a, ...c } = e, u = tr(mo, i), f = nr(mo, i), h = dx(mo, i), g = Zj(mo, i), [y, v] = w.useState(null), S = Xe(r, j => v(j), h.onItemTextChange, j => f.itemTextRefCallback?.(j, h.value, h.disabled)), k = y?.textContent, P = w.useMemo(() => p.jsx("option", { value: h.value, disabled: h.disabled, children: k }, h.value), [h.disabled, h.value, k]), { onNativeOptionAdd: C, onNativeOptionRemove: N } = g; return at(() => (C(P), () => N(P)), [C, N, P]), p.jsxs(p.Fragment, { children: [p.jsx(Ie.span, { id: h.textId, ...c, ref: S }), h.isSelected && u.valueNode && !u.valueNodeHasChildren ? Oo.createPortal(c.children, u.valueNode) : null] }) }); px.displayName = mo; var hx = "SelectItemIndicator", mx = w.forwardRef((e, r) => { const { __scopeSelect: i, ...s } = e; return dx(hx, i).isSelected ? p.jsx(Ie.span, { "aria-hidden": !0, ...s, ref: r }) : null }); mx.displayName = hx; var Xu = "SelectScrollUpButton", gx = w.forwardRef((e, r) => { const i = nr(Xu, e.__scopeSelect), s = Xd(Xu, e.__scopeSelect), [a, c] = w.useState(!1), u = Xe(r, s.onScrollButtonChange); return at(() => { if (i.viewport && i.isPositioned) { let f = function () { const g = h.scrollTop > 0; c(g) }; const h = i.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [i.viewport, i.isPositioned]), a ? p.jsx(vx, { ...e, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = i; f && h && (f.scrollTop = f.scrollTop - h.offsetHeight) } }) : null }); gx.displayName = Xu; var qu = "SelectScrollDownButton", yx = w.forwardRef((e, r) => { const i = nr(qu, e.__scopeSelect), s = Xd(qu, e.__scopeSelect), [a, c] = w.useState(!1), u = Xe(r, s.onScrollButtonChange); return at(() => { if (i.viewport && i.isPositioned) { let f = function () { const g = h.scrollHeight - h.clientHeight, y = Math.ceil(h.scrollTop) < g; c(y) }; const h = i.viewport; return f(), h.addEventListener("scroll", f), () => h.removeEventListener("scroll", f) } }, [i.viewport, i.isPositioned]), a ? p.jsx(vx, { ...e, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: h } = i; f && h && (f.scrollTop = f.scrollTop + h.offsetHeight) } }) : null }); yx.displayName = qu; var vx = w.forwardRef((e, r) => { const { __scopeSelect: i, onAutoScroll: s, ...a } = e, c = nr("SelectScrollButton", i), u = w.useRef(null), f = Ba(i), h = w.useCallback(() => { u.current !== null && (window.clearInterval(u.current), u.current = null) }, []); return w.useEffect(() => () => h(), [h]), at(() => { f().find(y => y.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [f]), p.jsx(Ie.div, { "aria-hidden": !0, ...a, ref: r, style: { flexShrink: 0, ...a.style }, onPointerDown: $e(a.onPointerDown, () => { u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerMove: $e(a.onPointerMove, () => { c.onItemLeave?.(), u.current === null && (u.current = window.setInterval(s, 50)) }), onPointerLeave: $e(a.onPointerLeave, () => { h() }) }) }), dA = "SelectSeparator", fA = w.forwardRef((e, r) => { const { __scopeSelect: i, ...s } = e; return p.jsx(Ie.div, { "aria-hidden": !0, ...s, ref: r }) }); fA.displayName = dA; var Qu = "SelectArrow", pA = w.forwardRef((e, r) => { const { __scopeSelect: i, ...s } = e, a = Wa(i), c = tr(Qu, i), u = nr(Qu, i); return c.open && u.position === "popper" ? p.jsx(qT, { ...a, ...s, ref: r }) : null }); pA.displayName = Qu; var hA = "SelectBubbleInput", xx = w.forwardRef(({ __scopeSelect: e, value: r, ...i }, s) => { const a = w.useRef(null), c = Xe(s, a), u = ij(r); return w.useEffect(() => { const f = a.current; if (!f) return; const h = window.HTMLSelectElement.prototype, y = Object.getOwnPropertyDescriptor(h, "value").set; if (u !== r && y) { const v = new Event("change", { bubbles: !0 }); y.call(f, r), f.dispatchEvent(v) } }, [u, r]), p.jsx(Ie.select, { ...i, style: { ...B0, ...i.style }, ref: c, defaultValue: r }) }); xx.displayName = hA; function wx(e) { return e === "" || e === void 0 } function Sx(e) { const r = br(e), i = w.useRef(""), s = w.useRef(0), a = w.useCallback(u => { const f = i.current + u; r(f), (function h(g) { i.current = g, window.clearTimeout(s.current), g !== "" && (s.current = window.setTimeout(() => h(""), 1e3)) })(f) }, [r]), c = w.useCallback(() => { i.current = "", window.clearTimeout(s.current) }, []); return w.useEffect(() => () => window.clearTimeout(s.current), []), [i, a, c] } function Cx(e, r, i) { const a = r.length > 1 && Array.from(r).every(g => g === r[0]) ? r[0] : r, c = i ? e.indexOf(i) : -1; let u = mA(e, Math.max(c, 0)); a.length === 1 && (u = u.filter(g => g !== i)); const h = u.find(g => g.textValue.toLowerCase().startsWith(a.toLowerCase())); return h !== i ? h : void 0 } function mA(e, r) { return e.map((i, s) => e[(r + s) % e.length]) } var gA = Q0, yA = J0, vA = tx, xA = nx, wA = rx, SA = ix, CA = lx, kA = fx, bA = px, NA = mx, PA = gx, EA = yx; function pu({ ...e }) { return p.jsx(gA, { "data-slot": "select", ...e }) } function hu({ ...e }) { return p.jsx(vA, { "data-slot": "select-value", ...e }) } function mu({ className: e, size: r = "default", children: i, ...s }) { return p.jsxs(yA, { "data-slot": "select-trigger", "data-size": r, className: Ft("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-full items-center justify-between gap-2 rounded-md border bg-input-background px-3 py-2 text-sm whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e), ...s, children: [i, p.jsx(xA, { asChild: !0, children: p.jsx(Id, { className: "size-4 opacity-50" }) })] }) } function gu({ className: e, children: r, position: i = "popper", ...s }) { return p.jsx(wA, { children: p.jsxs(SA, { "data-slot": "select-content", className: Ft("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", i === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e), position: i, ...s, children: [p.jsx(TA, {}), p.jsx(CA, { className: Ft("p-1", i === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"), children: r }), p.jsx(jA, {})] }) }) } function Et({ className: e, children: r, ...i }) { return p.jsxs(kA, { "data-slot": "select-item", className: Ft("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", e), ...i, children: [p.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: p.jsx(NA, { children: p.jsx(jv, { className: "size-4" }) }) }), p.jsx(bA, { children: r })] }) } function TA({ className: e, ...r }) { return p.jsx(PA, { "data-slot": "select-scroll-up-button", className: Ft("flex cursor-default items-center justify-center py-1", e), ...r, children: p.jsx(S2, { className: "size-4" }) }) } function jA({ className: e, ...r }) { return p.jsx(EA, { "data-slot": "select-scroll-down-button", className: Ft("flex cursor-default items-center justify-center py-1", e), ...r, children: p.jsx(Id, { className: "size-4" }) }) } function AA() { return p.jsxs("div", { className: "min-h-screen bg-white", children: [p.jsx(Io, {}), p.jsx("section", { className: "pt-32 pb-20 md:pt-40 md:pb-28 bg-gradient-to-br from-neutral-50 to-primary-50/30", children: p.jsx("div", { className: "container-custom text-center", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [p.jsx("h1", { className: "text-neutral-900 mb-6", children: "Let's talk about your restaurant" }), p.jsx("p", { className: "text-xl text-neutral-600 max-w-3xl mx-auto", children: "Whether you're ready to start a free trial or want to see a personalized demo, we're here to help" })] }) }) }), p.jsx("section", { className: "section-padding", children: p.jsx("div", { className: "container-custom", children: p.jsxs("div", { className: "grid md:grid-cols-2 gap-12 max-w-6xl mx-auto", children: [p.jsxs(Ne.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: .2 }, children: [p.jsx("h2", { className: "text-neutral-900 mb-6", children: "Get in touch" }), p.jsxs("form", { className: "space-y-6", children: [p.jsxs("div", { className: "grid md:grid-cols-2 gap-4", children: [p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "firstName", children: "First Name" }), p.jsx(po, { id: "firstName", placeholder: "John", className: "mt-2" })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "lastName", children: "Last Name" }), p.jsx(po, { id: "lastName", placeholder: "Doe", className: "mt-2" })] })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "email", children: "Email" }), p.jsx(po, { id: "email", type: "email", placeholder: "john@restaurant.com", className: "mt-2" })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "phone", children: "Phone Number" }), p.jsx(po, { id: "phone", type: "tel", placeholder: "+1 (555) 000-0000", className: "mt-2" })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "restaurantName", children: "Restaurant Name" }), p.jsx(po, { id: "restaurantName", placeholder: "Your Restaurant", className: "mt-2" })] }), p.jsxs("div", { className: "grid md:grid-cols-2 gap-4", children: [p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "locations", children: "Number of Locations" }), p.jsxs(pu, { children: [p.jsx(mu, { className: "mt-2", children: p.jsx(hu, { placeholder: "Select..." }) }), p.jsxs(gu, { children: [p.jsx(Et, { value: "1", children: "1 location" }), p.jsx(Et, { value: "2-3", children: "2-3 locations" }), p.jsx(Et, { value: "4-10", children: "4-10 locations" }), p.jsx(Et, { value: "11+", children: "11+ locations" })] })] })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "employees", children: "Number of Employees" }), p.jsxs(pu, { children: [p.jsx(mu, { className: "mt-2", children: p.jsx(hu, { placeholder: "Select..." }) }), p.jsxs(gu, { children: [p.jsx(Et, { value: "1-20", children: "1-20 employees" }), p.jsx(Et, { value: "21-50", children: "21-50 employees" }), p.jsx(Et, { value: "51-100", children: "51-100 employees" }), p.jsx(Et, { value: "101+", children: "101+ employees" })] })] })] })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "interest", children: "What are you interested in?" }), p.jsxs(pu, { children: [p.jsx(mu, { className: "mt-2", children: p.jsx(hu, { placeholder: "Select..." }) }), p.jsxs(gu, { children: [p.jsx(Et, { value: "trial", children: "Start a free trial" }), p.jsx(Et, { value: "demo", children: "Schedule a demo" }), p.jsx(Et, { value: "pricing", children: "Discuss pricing" }), p.jsx(Et, { value: "integration", children: "Integration questions" }), p.jsx(Et, { value: "other", children: "Other" })] })] })] }), p.jsxs("div", { children: [p.jsx(Cn, { htmlFor: "message", children: "Message" }), p.jsx(JP, { id: "message", placeholder: "Tell us about your restaurant and what you're looking for...", className: "mt-2 min-h-[120px]" })] }), p.jsxs("button", { type: "submit", className: "w-full bg-primary-600 text-white px-8 py-4 rounded-lg hover:bg-primary-700 transition-colors inline-flex items-center justify-center space-x-2", children: [p.jsx("span", { children: "Send Message" }), p.jsx(X2, { size: 20 })] }), p.jsx("p", { className: "text-sm text-neutral-500 text-center", children: "By submitting this form, you agree to our privacy policy" })] })] }), p.jsxs(Ne.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, transition: { delay: .3 }, className: "space-y-8", children: [p.jsxs("div", { children: [p.jsx("h3", { className: "text-neutral-900 mb-6", children: "Contact Information" }), p.jsxs("div", { className: "space-y-6", children: [p.jsxs("div", { className: "flex items-start space-x-4", children: [p.jsx("div", { className: "w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center flex-shrink-0", children: p.jsx(V2, { className: "text-primary-600", size: 20 }) }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-1", children: "Email" }), p.jsx("p", { className: "text-neutral-600", children: "sales@mizan.ai" }), p.jsx("p", { className: "text-neutral-600", children: "support@mizan.ai" })] })] }), p.jsxs("div", { className: "flex items-start space-x-4", children: [p.jsx("div", { className: "w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center flex-shrink-0", children: p.jsx(G2, { className: "text-primary-600", size: 20 }) }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-1", children: "Phone" }), p.jsx("p", { className: "text-neutral-600", children: "" }), p.jsx("p", { className: "text-sm text-neutral-500", children: "Mon-Fri, 9am-6pm EST" })] })] }), p.jsxs("div", { className: "flex items-start space-x-4", children: [p.jsx("div", { className: "w-12 h-12 bg-primary-100 rounded-xl flex items-center justify-center flex-shrink-0", children: p.jsx(z2, { className: "text-primary-600", size: 20 }) }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-1", children: "Office" }), p.jsxs("p", { className: "text-neutral-600", children: ["123 Tech Boulevard", p.jsx("br", {}), "San Francisco, CA 94102", p.jsx("br", {}), "United States"] })] })] })] })] }), p.jsxs("div", { className: "bg-gradient-to-br from-neutral-50 to-primary-50/30 rounded-2xl p-8", children: [p.jsx("h4", { className: "text-neutral-900 mb-4", children: "Why choose Mizan?" }), p.jsxs("ul", { className: "space-y-3", children: [p.jsxs("li", { className: "flex items-start space-x-3", children: [p.jsx("div", { className: "w-6 h-6 bg-primary-600 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5", children: p.jsx("span", { className: "text-white text-xs", children: "" }) }), p.jsx("span", { className: "text-neutral-700", children: "14-day free trial with full features" })] }), p.jsxs("li", { className: "flex items-start space-x-3", children: [p.jsx("div", { className: "w-6 h-6 bg-primary-600 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5", children: p.jsx("span", { className: "text-white text-xs", children: "" }) }), p.jsx("span", { className: "text-neutral-700", children: "Setup and training included" })] }), p.jsxs("li", { className: "flex items-start space-x-3", children: [p.jsx("div", { className: "w-6 h-6 bg-primary-600 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5", children: p.jsx("span", { className: "text-white text-xs", children: "" }) }), p.jsx("span", { className: "text-neutral-700", children: "Dedicated customer success team" })] }), p.jsxs("li", { className: "flex items-start space-x-3", children: [p.jsx("div", { className: "w-6 h-6 bg-primary-600 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5", children: p.jsx("span", { className: "text-white text-xs", children: "" }) }), p.jsx("span", { className: "text-neutral-700", children: "No long-term contracts" })] })] })] }), p.jsxs("div", { className: "bg-primary-600 rounded-2xl p-8 text-white", children: [p.jsx("h4", { className: "text-white mb-2", children: "Response Time" }), p.jsx("p", { className: "text-primary-100 mb-4", children: "We typically respond to all inquiries within 2 business hours during office hours." }), p.jsx("p", { className: "text-primary-100", children: "For urgent support needs, existing customers can reach us 24/7 through the in-app chat." })] })] })] }) }) }), p.jsx("section", { className: "section-padding bg-neutral-50", children: p.jsxs("div", { className: "container-custom", children: [p.jsxs("div", { className: "text-center mb-12", children: [p.jsx("h2", { className: "text-neutral-900 mb-4", children: "Quick Answers" }), p.jsx("p", { className: "text-xl text-neutral-600", children: "Frequently asked questions about getting started" })] }), p.jsxs("div", { className: "grid md:grid-cols-2 gap-8 max-w-4xl mx-auto", children: [p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-2", children: "How long does setup take?" }), p.jsx("p", { className: "text-neutral-600", children: "Most restaurants are up and running within 24-48 hours. We handle the technical setup and provide training for your team." })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-2", children: "Do you integrate with my POS?" }), p.jsx("p", { className: "text-neutral-600", children: "We integrate with major POS systems including Toast, Square, Clover, and more. Contact us to confirm your specific system." })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-2", children: "What if I need help after setup?" }), p.jsx("p", { className: "text-neutral-600", children: "You'll have access to our support team via email, chat, and phone. We also provide comprehensive documentation and training materials." })] }), p.jsxs("div", { children: [p.jsx("h4", { className: "text-neutral-900 mb-2", children: "Can I try before committing?" }), p.jsx("p", { className: "text-neutral-600", children: "Yes! Our 14-day free trial gives you full access to all features. No credit card required to start." })] })] })] }) }), p.jsx(Do, {})] }) } function Ug({ title: e, description: r }) { const i = () => { window.location.hash = "", window.scrollTo({ top: 0, behavior: "smooth" }) }, s = () => { window.location.hash = "contact" }; return p.jsxs("div", { className: "min-h-screen bg-white", children: [p.jsx(Io, {}), p.jsx("main", { className: "pt-32 pb-20", children: p.jsx("div", { className: "container-custom", children: p.jsxs(Ne.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, className: "max-w-2xl mx-auto text-center", children: [p.jsx("div", { className: "inline-flex items-center justify-center w-24 h-24 bg-primary-100 rounded-full mb-8", children: p.jsx(b2, { className: "w-12 h-12 text-primary-600" }) }), p.jsx("h1", { className: "text-neutral-900 mb-4", children: e }), p.jsx("p", { className: "text-neutral-600 mb-8 text-xl", children: r }), p.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 justify-center", children: [p.jsx("a", { href: "/", className: "inline-flex items-center justify-center px-8 py-3 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition-colors", onClick: i, children: "Back to Home" }), p.jsx("a", { href: "#contact", className: "inline-flex items-center justify-center px-8 py-3 border-2 border-primary-600 text-primary-600 rounded-lg hover:bg-primary-50 transition-colors", onClick: s, children: "Get Notified" })] })] }) }) }), p.jsx(Do, {})] }) } function RA() { const [e, r] = w.useState("home"); return w.useEffect(() => { const i = () => { const s = window.location.hash.slice(1); r(s === "features" ? "features" : s === "pricing" ? "pricing" : s === "contact" ? "contact" : s === "case-studies" ? "case-studies" : s === "blog" ? "blog" : "home"), window.scrollTo({ top: 0, behavior: "smooth" }) }; return i(), window.addEventListener("hashchange", i), () => { window.removeEventListener("hashchange", i) } }, []), e === "features" ? p.jsx(hN, {}) : e === "pricing" ? p.jsx(ZP, {}) : e === "contact" ? p.jsx(AA, {}) : e === "case-studies" ? p.jsx(Ug, { title: "Case Studies Coming Soon", description: "We're working hard to bring you inspiring success stories from restaurants that have transformed their operations with Mizan. Check back soon!" }) : e === "blog" ? p.jsx(Ug, { title: "Blog Coming Soon", description: "Our blog is on its way! Soon you'll find expert insights, industry trends, and best practices for restaurant management. Stay tuned!" }) : p.jsx(pN, {}) } E1.createRoot(document.getElementById("root")).render(p.jsx(RA, {}));
